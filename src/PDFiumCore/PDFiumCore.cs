// Built from precompiled binaries at https://github.com/bblanchon/pdfium-binaries/releases/tag/chromium/6164
// Github release api https://api.github.com/repos/bblanchon/pdfium-binaries/releases/132471191
// PDFium version v121.0.6164.0 chromium/6164 [master]
// Built on: Mon, 11 Dec 2023 22:09:01 GMT
// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace PDFiumCore
{
    public enum FPDF_TEXT_RENDERMODE
    {
        FPDF_TEXTRENDERMODE_UNKNOWN = -1,
        FPDF_TEXTRENDERMODE_FILL = 0,
        FPDF_TEXTRENDERMODE_STROKE = 1,
        FPDF_TEXTRENDERMODE_FILL_STROKE = 2,
        FPDF_TEXTRENDERMODE_INVISIBLE = 3,
        FPDF_TEXTRENDERMODE_FILL_CLIP = 4,
        FPDF_TEXTRENDERMODE_STROKE_CLIP = 5,
        FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP = 6,
        FPDF_TEXTRENDERMODE_CLIP = 7,
        FPDF_TEXTRENDERMODE_LAST = 7
    }

    public enum FPDF_DUPLEXTYPE_
    {
        DuplexUndefined = 0,
        Simplex = 1,
        DuplexFlipShortEdge = 2,
        DuplexFlipLongEdge = 3
    }

    public enum FPDF_RENDERER_TYPE
    {
        FPDF_RENDERERTYPE_AGG = 0,
        FPDF_RENDERERTYPE_SKIA = 1
    }

    public unsafe partial class FpdfActionT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfActionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfActionT>();

        protected bool __ownsNativeInstance;

        internal static FpdfActionT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfActionT(native.ToPointer(), skipVTables);
        }

        internal static FpdfActionT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfActionT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfActionT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfActionT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfActionT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfActionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfAnnotationT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAnnotationT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAnnotationT>();

        protected bool __ownsNativeInstance;

        internal static FpdfAnnotationT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfAnnotationT(native.ToPointer(), skipVTables);
        }

        internal static FpdfAnnotationT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfAnnotationT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfAnnotationT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfAnnotationT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfAnnotationT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfAnnotationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfAttachmentT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAttachmentT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAttachmentT>();

        protected bool __ownsNativeInstance;

        internal static FpdfAttachmentT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfAttachmentT(native.ToPointer(), skipVTables);
        }

        internal static FpdfAttachmentT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfAttachmentT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfAttachmentT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfAttachmentT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfAttachmentT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfAttachmentT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfAvailT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAvailT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAvailT>();

        protected bool __ownsNativeInstance;

        internal static FpdfAvailT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfAvailT(native.ToPointer(), skipVTables);
        }

        internal static FpdfAvailT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfAvailT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfAvailT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfAvailT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfAvailT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfAvailT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfBitmapT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBitmapT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBitmapT>();

        protected bool __ownsNativeInstance;

        internal static FpdfBitmapT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfBitmapT(native.ToPointer(), skipVTables);
        }

        internal static FpdfBitmapT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfBitmapT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfBitmapT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfBitmapT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfBitmapT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfBitmapT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfBookmarkT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBookmarkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBookmarkT>();

        protected bool __ownsNativeInstance;

        internal static FpdfBookmarkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfBookmarkT(native.ToPointer(), skipVTables);
        }

        internal static FpdfBookmarkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfBookmarkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfBookmarkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfBookmarkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfBookmarkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfBookmarkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfClippathT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfClippathT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfClippathT>();

        protected bool __ownsNativeInstance;

        internal static FpdfClippathT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfClippathT(native.ToPointer(), skipVTables);
        }

        internal static FpdfClippathT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfClippathT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfClippathT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfClippathT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfClippathT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfClippathT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfDestT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDestT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDestT>();

        protected bool __ownsNativeInstance;

        internal static FpdfDestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfDestT(native.ToPointer(), skipVTables);
        }

        internal static FpdfDestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfDestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfDestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfDestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfDestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfDestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfDocumentT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDocumentT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDocumentT>();

        protected bool __ownsNativeInstance;

        internal static FpdfDocumentT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfDocumentT(native.ToPointer(), skipVTables);
        }

        internal static FpdfDocumentT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfDocumentT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfDocumentT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfDocumentT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfDocumentT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfDocumentT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfFontT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFontT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFontT>();

        protected bool __ownsNativeInstance;

        internal static FpdfFontT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfFontT(native.ToPointer(), skipVTables);
        }

        internal static FpdfFontT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfFontT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfFontT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfFontT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfFontT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfFontT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfFormHandleT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFormHandleT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFormHandleT>();

        protected bool __ownsNativeInstance;

        internal static FpdfFormHandleT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfFormHandleT(native.ToPointer(), skipVTables);
        }

        internal static FpdfFormHandleT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfFormHandleT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfFormHandleT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfFormHandleT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfFormHandleT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfFormHandleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfGlyphpathT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfGlyphpathT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfGlyphpathT>();

        protected bool __ownsNativeInstance;

        internal static FpdfGlyphpathT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfGlyphpathT(native.ToPointer(), skipVTables);
        }

        internal static FpdfGlyphpathT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfGlyphpathT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfGlyphpathT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfGlyphpathT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfGlyphpathT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfGlyphpathT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfJavascriptActionT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfJavascriptActionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfJavascriptActionT>();

        protected bool __ownsNativeInstance;

        internal static FpdfJavascriptActionT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfJavascriptActionT(native.ToPointer(), skipVTables);
        }

        internal static FpdfJavascriptActionT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfJavascriptActionT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfJavascriptActionT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfJavascriptActionT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfJavascriptActionT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfJavascriptActionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfLinkT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfLinkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfLinkT>();

        protected bool __ownsNativeInstance;

        internal static FpdfLinkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfLinkT(native.ToPointer(), skipVTables);
        }

        internal static FpdfLinkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfLinkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfLinkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfLinkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfLinkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfLinkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfPageT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageT>();

        protected bool __ownsNativeInstance;

        internal static FpdfPageT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfPageT(native.ToPointer(), skipVTables);
        }

        internal static FpdfPageT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfPageT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfPageT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfPageT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPageT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfPagelinkT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagelinkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagelinkT>();

        protected bool __ownsNativeInstance;

        internal static FpdfPagelinkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfPagelinkT(native.ToPointer(), skipVTables);
        }

        internal static FpdfPagelinkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfPagelinkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfPagelinkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfPagelinkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPagelinkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPagelinkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfPageobjectT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectT>();

        protected bool __ownsNativeInstance;

        internal static FpdfPageobjectT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfPageobjectT(native.ToPointer(), skipVTables);
        }

        internal static FpdfPageobjectT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfPageobjectT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfPageobjectT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfPageobjectT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPageobjectT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPageobjectT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfPageobjectmarkT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectmarkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectmarkT>();

        protected bool __ownsNativeInstance;

        internal static FpdfPageobjectmarkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfPageobjectmarkT(native.ToPointer(), skipVTables);
        }

        internal static FpdfPageobjectmarkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfPageobjectmarkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfPageobjectmarkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfPageobjectmarkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPageobjectmarkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPageobjectmarkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfPagerangeT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagerangeT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagerangeT>();

        protected bool __ownsNativeInstance;

        internal static FpdfPagerangeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfPagerangeT(native.ToPointer(), skipVTables);
        }

        internal static FpdfPagerangeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfPagerangeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfPagerangeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfPagerangeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPagerangeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPagerangeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfPathsegmentT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPathsegmentT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPathsegmentT>();

        protected bool __ownsNativeInstance;

        internal static FpdfPathsegmentT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfPathsegmentT(native.ToPointer(), skipVTables);
        }

        internal static FpdfPathsegmentT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfPathsegmentT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfPathsegmentT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfPathsegmentT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPathsegmentT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPathsegmentT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfSchhandleT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSchhandleT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSchhandleT>();

        protected bool __ownsNativeInstance;

        internal static FpdfSchhandleT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfSchhandleT(native.ToPointer(), skipVTables);
        }

        internal static FpdfSchhandleT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfSchhandleT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfSchhandleT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfSchhandleT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfSchhandleT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfSchhandleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfSignatureT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSignatureT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSignatureT>();

        protected bool __ownsNativeInstance;

        internal static FpdfSignatureT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfSignatureT(native.ToPointer(), skipVTables);
        }

        internal static FpdfSignatureT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfSignatureT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfSignatureT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfSignatureT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfSignatureT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfSignatureT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfStructelementT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructelementT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructelementT>();

        protected bool __ownsNativeInstance;

        internal static FpdfStructelementT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfStructelementT(native.ToPointer(), skipVTables);
        }

        internal static FpdfStructelementT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfStructelementT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfStructelementT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfStructelementT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfStructelementT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfStructelementT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfStructelementAttrT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructelementAttrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructelementAttrT>();

        protected bool __ownsNativeInstance;

        internal static FpdfStructelementAttrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfStructelementAttrT(native.ToPointer(), skipVTables);
        }

        internal static FpdfStructelementAttrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfStructelementAttrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfStructelementAttrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfStructelementAttrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfStructelementAttrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfStructelementAttrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfStructtreeT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructtreeT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructtreeT>();

        protected bool __ownsNativeInstance;

        internal static FpdfStructtreeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfStructtreeT(native.ToPointer(), skipVTables);
        }

        internal static FpdfStructtreeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfStructtreeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfStructtreeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfStructtreeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfStructtreeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfStructtreeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfTextpageT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfTextpageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfTextpageT>();

        protected bool __ownsNativeInstance;

        internal static FpdfTextpageT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfTextpageT(native.ToPointer(), skipVTables);
        }

        internal static FpdfTextpageT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfTextpageT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfTextpageT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfTextpageT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfTextpageT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfTextpageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfWidgetT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfWidgetT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfWidgetT>();

        protected bool __ownsNativeInstance;

        internal static FpdfWidgetT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfWidgetT(native.ToPointer(), skipVTables);
        }

        internal static FpdfWidgetT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfWidgetT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfWidgetT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfWidgetT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfWidgetT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfWidgetT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfXobjectT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfXobjectT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfXobjectT>();

        protected bool __ownsNativeInstance;

        internal static FpdfXobjectT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FpdfXobjectT(native.ToPointer(), skipVTables);
        }

        internal static FpdfXobjectT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FpdfXobjectT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FpdfXobjectT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfXobjectT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfXobjectT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfXobjectT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_BSTR_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr str;
            internal int len;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_BSTR_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_BSTR_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_BSTR_>();

        protected bool __ownsNativeInstance;

        internal static FPDF_BSTR_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_BSTR_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_BSTR_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_BSTR_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_BSTR_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_BSTR_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_BSTR_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_BSTR_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_BSTR_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_BSTR_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_BSTR_(global::PDFiumCore.FPDF_BSTR_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_BSTR_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_BSTR_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_BSTR_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Str
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->str;
            }

            set
            {
                ((__Internal*)__Instance)->str = (__IntPtr) value;
            }
        }

        public int Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }
    }

    public unsafe partial class FS_MATRIX_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float a;
            internal float b;
            internal float c;
            internal float d;
            internal float e;
            internal float f;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FS_MATRIX_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_MATRIX_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_MATRIX_>();

        protected bool __ownsNativeInstance;

        internal static FS_MATRIX_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FS_MATRIX_(native.ToPointer(), skipVTables);
        }

        internal static FS_MATRIX_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FS_MATRIX_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FS_MATRIX_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_MATRIX_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_MATRIX_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_MATRIX_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_MATRIX_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_MATRIX_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_MATRIX_(global::PDFiumCore.FS_MATRIX_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_MATRIX_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance) = *((global::PDFiumCore.FS_MATRIX_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float A
        {
            get
            {
                return ((__Internal*)__Instance)->a;
            }

            set
            {
                ((__Internal*)__Instance)->a = value;
            }
        }

        public float B
        {
            get
            {
                return ((__Internal*)__Instance)->b;
            }

            set
            {
                ((__Internal*)__Instance)->b = value;
            }
        }

        public float C
        {
            get
            {
                return ((__Internal*)__Instance)->c;
            }

            set
            {
                ((__Internal*)__Instance)->c = value;
            }
        }

        public float D
        {
            get
            {
                return ((__Internal*)__Instance)->d;
            }

            set
            {
                ((__Internal*)__Instance)->d = value;
            }
        }

        public float E
        {
            get
            {
                return ((__Internal*)__Instance)->e;
            }

            set
            {
                ((__Internal*)__Instance)->e = value;
            }
        }

        public float F
        {
            get
            {
                return ((__Internal*)__Instance)->f;
            }

            set
            {
                ((__Internal*)__Instance)->f = value;
            }
        }
    }

    public unsafe partial class FS_RECTF_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float left;
            internal float top;
            internal float right;
            internal float bottom;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FS_RECTF_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_RECTF_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_RECTF_>();

        protected bool __ownsNativeInstance;

        internal static FS_RECTF_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FS_RECTF_(native.ToPointer(), skipVTables);
        }

        internal static FS_RECTF_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FS_RECTF_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FS_RECTF_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_RECTF_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_RECTF_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_RECTF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_RECTF_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_RECTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_RECTF_(global::PDFiumCore.FS_RECTF_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_RECTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_RECTF_.__Internal*) __Instance) = *((global::PDFiumCore.FS_RECTF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Left
        {
            get
            {
                return ((__Internal*)__Instance)->left;
            }

            set
            {
                ((__Internal*)__Instance)->left = value;
            }
        }

        public float Top
        {
            get
            {
                return ((__Internal*)__Instance)->top;
            }

            set
            {
                ((__Internal*)__Instance)->top = value;
            }
        }

        public float Right
        {
            get
            {
                return ((__Internal*)__Instance)->right;
            }

            set
            {
                ((__Internal*)__Instance)->right = value;
            }
        }

        public float Bottom
        {
            get
            {
                return ((__Internal*)__Instance)->bottom;
            }

            set
            {
                ((__Internal*)__Instance)->bottom = value;
            }
        }
    }

    public unsafe partial class FS_SIZEF_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float width;
            internal float height;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FS_SIZEF_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_SIZEF_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_SIZEF_>();

        protected bool __ownsNativeInstance;

        internal static FS_SIZEF_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FS_SIZEF_(native.ToPointer(), skipVTables);
        }

        internal static FS_SIZEF_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FS_SIZEF_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FS_SIZEF_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_SIZEF_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_SIZEF_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_SIZEF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_SIZEF_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_SIZEF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_SIZEF_(global::PDFiumCore.FS_SIZEF_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_SIZEF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_SIZEF_.__Internal*) __Instance) = *((global::PDFiumCore.FS_SIZEF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public float Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }
    }

    public unsafe partial class FS_POINTF_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FS_POINTF_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_POINTF_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_POINTF_>();

        protected bool __ownsNativeInstance;

        internal static FS_POINTF_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FS_POINTF_(native.ToPointer(), skipVTables);
        }

        internal static FS_POINTF_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FS_POINTF_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FS_POINTF_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_POINTF_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_POINTF_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_POINTF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_POINTF_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_POINTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_POINTF_(global::PDFiumCore.FS_POINTF_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_POINTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_POINTF_.__Internal*) __Instance) = *((global::PDFiumCore.FS_POINTF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class FS_QUADPOINTSF : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal float x1;
            internal float y1;
            internal float x2;
            internal float y2;
            internal float x3;
            internal float y3;
            internal float x4;
            internal float y4;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FS_QUADPOINTSF@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_QUADPOINTSF> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_QUADPOINTSF>();

        protected bool __ownsNativeInstance;

        internal static FS_QUADPOINTSF __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FS_QUADPOINTSF(native.ToPointer(), skipVTables);
        }

        internal static FS_QUADPOINTSF __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FS_QUADPOINTSF)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FS_QUADPOINTSF __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_QUADPOINTSF(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_QUADPOINTSF(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_QUADPOINTSF(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_QUADPOINTSF()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_QUADPOINTSF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_QUADPOINTSF(global::PDFiumCore.FS_QUADPOINTSF _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_QUADPOINTSF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance) = *((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((__Internal*)__Instance)->y1;
            }

            set
            {
                ((__Internal*)__Instance)->y1 = value;
            }
        }

        public float X2
        {
            get
            {
                return ((__Internal*)__Instance)->x2;
            }

            set
            {
                ((__Internal*)__Instance)->x2 = value;
            }
        }

        public float Y2
        {
            get
            {
                return ((__Internal*)__Instance)->y2;
            }

            set
            {
                ((__Internal*)__Instance)->y2 = value;
            }
        }

        public float X3
        {
            get
            {
                return ((__Internal*)__Instance)->x3;
            }

            set
            {
                ((__Internal*)__Instance)->x3 = value;
            }
        }

        public float Y3
        {
            get
            {
                return ((__Internal*)__Instance)->y3;
            }

            set
            {
                ((__Internal*)__Instance)->y3 = value;
            }
        }

        public float X4
        {
            get
            {
                return ((__Internal*)__Instance)->x4;
            }

            set
            {
                ((__Internal*)__Instance)->x4 = value;
            }
        }

        public float Y4
        {
            get
            {
                return ((__Internal*)__Instance)->y4;
            }

            set
            {
                ((__Internal*)__Instance)->y4 = value;
            }
        }
    }

    public unsafe partial class FPDF_LIBRARY_CONFIG_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr m_pUserFontPaths;
            internal __IntPtr m_pIsolate;
            internal uint m_v8EmbedderSlot;
            internal __IntPtr m_pPlatform;
            internal global::PDFiumCore.FPDF_RENDERER_TYPE m_RendererType;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_LIBRARY_CONFIG_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_LIBRARY_CONFIG_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_LIBRARY_CONFIG_>();

        protected bool __ownsNativeInstance;

        internal static FPDF_LIBRARY_CONFIG_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_LIBRARY_CONFIG_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_LIBRARY_CONFIG_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_LIBRARY_CONFIG_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_LIBRARY_CONFIG_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_LIBRARY_CONFIG_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_LIBRARY_CONFIG_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_LIBRARY_CONFIG_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_LIBRARY_CONFIG_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_LIBRARY_CONFIG_(global::PDFiumCore.FPDF_LIBRARY_CONFIG_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public __IntPtr MPIsolate
        {
            get
            {
                return ((__Internal*)__Instance)->m_pIsolate;
            }

            set
            {
                ((__Internal*)__Instance)->m_pIsolate = (__IntPtr) value;
            }
        }

        public uint MV8EmbedderSlot
        {
            get
            {
                return ((__Internal*)__Instance)->m_v8EmbedderSlot;
            }

            set
            {
                ((__Internal*)__Instance)->m_v8EmbedderSlot = value;
            }
        }

        public __IntPtr MPPlatform
        {
            get
            {
                return ((__Internal*)__Instance)->m_pPlatform;
            }

            set
            {
                ((__Internal*)__Instance)->m_pPlatform = (__IntPtr) value;
            }
        }

        public global::PDFiumCore.FPDF_RENDERER_TYPE MRendererType
        {
            get
            {
                return ((__Internal*)__Instance)->m_RendererType;
            }

            set
            {
                ((__Internal*)__Instance)->m_RendererType = value;
            }
        }
    }

    public unsafe partial class FPDF_FILEACCESS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint m_FileLen;
            internal __IntPtr m_GetBlock;
            internal __IntPtr m_Param;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_FILEACCESS@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEACCESS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEACCESS>();

        protected bool __ownsNativeInstance;

        internal static FPDF_FILEACCESS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_FILEACCESS(native.ToPointer(), skipVTables);
        }

        internal static FPDF_FILEACCESS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_FILEACCESS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_FILEACCESS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_FILEACCESS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEACCESS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FILEACCESS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_FILEACCESS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEACCESS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_FILEACCESS(global::PDFiumCore.FPDF_FILEACCESS __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEACCESS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FILEACCESS.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FILEACCESS.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint MFileLen
        {
            get
            {
                return ((__Internal*)__Instance)->m_FileLen;
            }

            set
            {
                ((__Internal*)__Instance)->m_FileLen = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_uint_bytePtr_uint MGetBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->m_GetBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_uint_bytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_uint_bytePtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->m_GetBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr MParam
        {
            get
            {
                return ((__Internal*)__Instance)->m_Param;
            }

            set
            {
                ((__Internal*)__Instance)->m_Param = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FPDF_FILEHANDLER_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr clientData;
            internal __IntPtr Release;
            internal __IntPtr GetSize;
            internal __IntPtr ReadBlock;
            internal __IntPtr WriteBlock;
            internal __IntPtr Flush;
            internal __IntPtr Truncate;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_FILEHANDLER_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEHANDLER_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEHANDLER_>();

        protected bool __ownsNativeInstance;

        internal static FPDF_FILEHANDLER_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_FILEHANDLER_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_FILEHANDLER_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_FILEHANDLER_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_FILEHANDLER_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_FILEHANDLER_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEHANDLER_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FILEHANDLER_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_FILEHANDLER_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_FILEHANDLER_(global::PDFiumCore.FPDF_FILEHANDLER_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr ClientData
        {
            get
            {
                return ((__Internal*)__Instance)->clientData;
            }

            set
            {
                ((__Internal*)__Instance)->clientData = (__IntPtr) value;
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr Release
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Release;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Release = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_uint___IntPtr GetSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetSize;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_uint___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_uint___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->GetSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_uint___IntPtr_uint ReadBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_uint___IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_uint___IntPtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->ReadBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_uint___IntPtr_uint WriteBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->WriteBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_uint___IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_uint___IntPtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->WriteBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr Flush
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Flush;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Flush = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_uint Truncate
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Truncate;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->Truncate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FPDF_COLORSCHEME_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint path_fill_color;
            internal uint path_stroke_color;
            internal uint text_fill_color;
            internal uint text_stroke_color;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_COLORSCHEME_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_COLORSCHEME_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_COLORSCHEME_>();

        protected bool __ownsNativeInstance;

        internal static FPDF_COLORSCHEME_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_COLORSCHEME_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_COLORSCHEME_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_COLORSCHEME_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_COLORSCHEME_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_COLORSCHEME_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_COLORSCHEME_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_COLORSCHEME_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_COLORSCHEME_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_COLORSCHEME_(global::PDFiumCore.FPDF_COLORSCHEME_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint PathFillColor
        {
            get
            {
                return ((__Internal*)__Instance)->path_fill_color;
            }

            set
            {
                ((__Internal*)__Instance)->path_fill_color = value;
            }
        }

        public uint PathStrokeColor
        {
            get
            {
                return ((__Internal*)__Instance)->path_stroke_color;
            }

            set
            {
                ((__Internal*)__Instance)->path_stroke_color = value;
            }
        }

        public uint TextFillColor
        {
            get
            {
                return ((__Internal*)__Instance)->text_fill_color;
            }

            set
            {
                ((__Internal*)__Instance)->text_fill_color = value;
            }
        }

        public uint TextStrokeColor
        {
            get
            {
                return ((__Internal*)__Instance)->text_stroke_color;
            }

            set
            {
                ((__Internal*)__Instance)->text_stroke_color = value;
            }
        }
    }

    public unsafe partial class fpdfview
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_InitLibraryWithConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_InitLibraryWithConfig(__IntPtr config);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_InitLibrary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_InitLibrary();

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_DestroyLibrary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_DestroyLibrary();

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_SetSandBoxPolicy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_SetSandBoxPolicy(uint policy, int enable);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_LoadDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadDocument([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file_path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string password);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_LoadMemDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadMemDocument(__IntPtr data_buf, int size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string password);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_LoadMemDocument64", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadMemDocument64(__IntPtr data_buf, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string password);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_LoadCustomDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadCustomDocument(__IntPtr pFileAccess, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string password);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetFileVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetFileVersion(__IntPtr doc, int* fileVersion);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetLastError", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetLastError();

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_DocumentHasValidCrossReferenceTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_DocumentHasValidCrossReferenceTable(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetTrailerEnds", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetTrailerEnds(__IntPtr document, uint* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetDocPermissions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetDocPermissions(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetDocUserPermissions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetDocUserPermissions(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetSecurityHandlerRevision", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetSecurityHandlerRevision(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetPageCount(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_LoadPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadPage(__IntPtr document, int page_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageWidthF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float FPDF_GetPageWidthF(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double FPDF_GetPageWidth(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageHeightF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float FPDF_GetPageHeightF(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageHeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double FPDF_GetPageHeight(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageBoundingBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetPageBoundingBox(__IntPtr page, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageSizeByIndexF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetPageSizeByIndexF(__IntPtr document, int page_index, __IntPtr size);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageSizeByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetPageSizeByIndex(__IntPtr document, int page_index, double* width, double* height);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_RenderPageBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_RenderPageBitmap(__IntPtr bitmap, __IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_RenderPageBitmapWithMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_RenderPageBitmapWithMatrix(__IntPtr bitmap, __IntPtr page, __IntPtr matrix, __IntPtr clipping, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_ClosePage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_ClosePage(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_CloseDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_CloseDocument(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_DeviceToPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_DeviceToPage(__IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int device_x, int device_y, double* page_x, double* page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_PageToDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_PageToDevice(__IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, double page_x, double page_y, int* device_x, int* device_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_Create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBitmapCreate(int width, int height, int alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_CreateEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBitmapCreateEx(int width, int height, int format, __IntPtr first_scan, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_GetFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmapGetFormat(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_FillRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFBitmapFillRect(__IntPtr bitmap, int left, int top, int width, int height, uint color);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_GetBuffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBitmapGetBuffer(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_GetWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmapGetWidth(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_GetHeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmapGetHeight(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_GetStride", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmapGetStride(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBitmap_Destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFBitmapDestroy(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintScaling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_VIEWERREF_GetPrintScaling(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetNumCopies", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_VIEWERREF_GetNumCopies(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintPageRange", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_VIEWERREF_GetPrintPageRange(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintPageRangeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong FPDF_VIEWERREF_GetPrintPageRangeCount(__IntPtr pagerange);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintPageRangeElement", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_VIEWERREF_GetPrintPageRangeElement(__IntPtr pagerange, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetDuplex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PDFiumCore.FPDF_DUPLEXTYPE_ FPDF_VIEWERREF_GetDuplex(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_VIEWERREF_GetName(__IntPtr document, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_CountNamedDests", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_CountNamedDests(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetNamedDestByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetNamedDestByName(__IntPtr document, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetNamedDest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetNamedDest(__IntPtr document, int index, __IntPtr buffer, int* buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetXFAPacketCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetXFAPacketCount(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetXFAPacketName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetXFAPacketName(__IntPtr document, int index, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetXFAPacketContent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetXFAPacketContent(__IntPtr document, int index, __IntPtr buffer, uint buflen, uint* out_buflen);
        }

        /// <summary>
        /// <para>Function: FPDF_InitLibraryWithConfig</para>
        /// <para>Initialize the PDFium library and allocate global resources for it.</para>
        /// <para>Parameters:</para>
        /// <para>config - configuration information as above.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: You have to call this function before you can call any PDF processing functions.</para>
        /// </summary>
        public static void FPDF_InitLibraryWithConfig(global::PDFiumCore.FPDF_LIBRARY_CONFIG_ config)
        {
            var __arg0 = config is null ? __IntPtr.Zero : config.__Instance;
            __Internal.FPDF_InitLibraryWithConfig(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_InitLibrary</para>
        /// <para>Initialize the PDFium library (alternative form).</para>
        /// <para>Parameters:</para>
        /// <para>None</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: Convenience function to call FPDF_InitLibraryWithConfig() with a default configuration for backwards compatibility purposes. New code should call FPDF_InitLibraryWithConfig() instead. This will be deprecated in the future.</para>
        /// </summary>
        public static void FPDF_InitLibrary()
        {
            __Internal.FPDF_InitLibrary();
        }

        /// <summary>
        /// <para>Function: FPDF_DestroyLibrary</para>
        /// <para>Release global resources allocated to the PDFium library by</para>
        /// <para>FPDF_InitLibrary() or FPDF_InitLibraryWithConfig().</para>
        /// <para>Parameters:</para>
        /// <para>None.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: After this function is called, you must not call any PDF processing functions.</para>
        /// <para>Calling this function does not automatically close other objects. It is recommended to close other objects before closing the library with this function.</para>
        /// </summary>
        public static void FPDF_DestroyLibrary()
        {
            __Internal.FPDF_DestroyLibrary();
        }

        /// <summary>
        /// <para>Function: FPDF_SetSandBoxPolicy</para>
        /// <para>Set the policy for the sandbox environment.</para>
        /// <para>Parameters:</para>
        /// <para>policy -   The specified policy for setting, for example: FPDF_POLICY_MACHINETIME_ACCESS.</para>
        /// <para>enable -   True to enable, false to disable the policy.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_SetSandBoxPolicy(uint policy, int enable)
        {
            __Internal.FPDF_SetSandBoxPolicy(policy, enable);
        }

        /// <summary>
        /// <para>Function: FPDF_LoadDocument</para>
        /// <para>Open and load a PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>file_path -  Path to the PDF file (including extension).</para>
        /// <para>password  -  A string used as the password for the PDF file. If no password is needed, empty or NULL can be used. See comments below regarding the encoding.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: Loaded document can be closed by FPDF_CloseDocument(). If this function fails, you can use FPDF_GetLastError() to retrieve the reason why it failed.</para>
        /// <para>The encoding for |file_path| is UTF-8.</para>
        /// <para>The encoding for |password| can be either UTF-8 or Latin-1. PDFs, depending on the security handler revision, will only accept one or the other encoding. If |password|'s encoding and the PDF's expected encoding do not match, FPDF_LoadDocument() will automatically convert |password| to the other encoding.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadDocument(string file_path, string password)
        {
            var __ret = __Internal.FPDF_LoadDocument(file_path, password);
            var __result0 = global::PDFiumCore.FpdfDocumentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadMemDocument</para>
        /// <para>Open and load a PDF document from memory.</para>
        /// <para>Parameters:</para>
        /// <para>data_buf    -   Pointer to a buffer containing the PDF document.</para>
        /// <para>size        -   Number of bytes in the PDF document.</para>
        /// <para>password    -   A string used as the password for the PDF file. If no password is needed, empty or NULL can be used.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: The memory buffer must remain valid when the document is open. The loaded document can be closed by FPDF_CloseDocument. If this function fails, you can use FPDF_GetLastError() to retrieve the reason why it failed.</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for |password|.</para>
        /// <para>Notes: If PDFium is built with the XFA module, the application should call FPDF_LoadXFA() function after the PDF document loaded to support XFA fields defined in the fpdfformfill.h file.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadMemDocument(__IntPtr data_buf, int size, string password)
        {
            var __ret = __Internal.FPDF_LoadMemDocument(data_buf, size, password);
            var __result0 = global::PDFiumCore.FpdfDocumentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadMemDocument64</para>
        /// <para>Open and load a PDF document from memory.</para>
        /// <para>Parameters:</para>
        /// <para>data_buf    -   Pointer to a buffer containing the PDF document.</para>
        /// <para>size        -   Number of bytes in the PDF document.</para>
        /// <para>password    -   A string used as the password for the PDF file. If no password is needed, empty or NULL can be used.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: The memory buffer must remain valid when the document is open. The loaded document can be closed by FPDF_CloseDocument. If this function fails, you can use FPDF_GetLastError() to retrieve the reason why it failed.</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for |password|.</para>
        /// <para>Notes: If PDFium is built with the XFA module, the application should call FPDF_LoadXFA() function after the PDF document loaded to support XFA fields defined in the fpdfformfill.h file.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadMemDocument64(__IntPtr data_buf, ulong size, string password)
        {
            var __ret = __Internal.FPDF_LoadMemDocument64(data_buf, size, password);
            var __result0 = global::PDFiumCore.FpdfDocumentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadCustomDocument</para>
        /// <para>Load PDF document from a custom access descriptor.</para>
        /// <para>Parameters:</para>
        /// <para>pFileAccess -   A structure for accessing the file.</para>
        /// <para>password    -   Optional password for decrypting the PDF file.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: The application must keep the file resources |pFileAccess| points to valid until the returned FPDF_DOCUMENT is closed. |pFileAccess| itself does not need to outlive the FPDF_DOCUMENT.</para>
        /// <para>The loaded document can be closed with FPDF_CloseDocument().</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for |password|.</para>
        /// <para>Notes: If PDFium is built with the XFA module, the application should call FPDF_LoadXFA() function after the PDF document loaded to support XFA fields defined in the fpdfformfill.h file.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadCustomDocument(global::PDFiumCore.FPDF_FILEACCESS pFileAccess, string password)
        {
            var __arg0 = pFileAccess is null ? __IntPtr.Zero : pFileAccess.__Instance;
            var __ret = __Internal.FPDF_LoadCustomDocument(__arg0, password);
            var __result0 = global::PDFiumCore.FpdfDocumentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_GetFileVersion</para>
        /// <para>Get the file version of the given PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>doc         -   Handle to a document.</para>
        /// <para>fileVersion -   The PDF file version. File version: 14 for 1.4, 15 for 1.5, ...</para>
        /// <para>Return value:</para>
        /// <para>True if succeeds, false otherwise.</para>
        /// <para>Comments: If the document was created by FPDF_CreateNewDocument, then this function will always fail.</para>
        /// </summary>
        public static int FPDF_GetFileVersion(global::PDFiumCore.FpdfDocumentT doc, ref int fileVersion)
        {
            var __arg0 = doc is null ? __IntPtr.Zero : doc.__Instance;
            fixed (int* __fileVersion1 = &fileVersion)
            {
                var __arg1 = __fileVersion1;
                var __ret = __Internal.FPDF_GetFileVersion(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_GetLastError</para>
        /// <para>Get last error code when a function fails.</para>
        /// <para>Parameters:</para>
        /// <para>None.</para>
        /// <para>Return value:</para>
        /// <para>A 32-bit integer indicating error code as defined above.</para>
        /// <para>Comments: If the previous SDK call succeeded, the return value of this function is not defined. This function only works in conjunction with APIs that mention FPDF_GetLastError() in their documentation.</para>
        /// </summary>
        public static uint FPDF_GetLastError()
        {
            var __ret = __Internal.FPDF_GetLastError();
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_DocumentHasValidCrossReferenceTable</para>
        /// <para>Whether the document's cross reference table is valid or not.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>True if the PDF parser did not encounter problems parsing the cross</para>
        /// <para>reference table. False if the parser could not parse the cross</para>
        /// <para>reference table and the table had to be rebuild from other data</para>
        /// <para>within the document.</para>
        /// <para>Comments: The return value can change over time as the PDF parser evolves.</para>
        /// </summary>
        public static int FPDF_DocumentHasValidCrossReferenceTable(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_DocumentHasValidCrossReferenceTable(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetTrailerEnds</para>
        /// <para>Get the byte offsets of trailer ends.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>buffer      -   The address of a buffer that receives the byte offsets.</para>
        /// <para>length      -   The size, in ints, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of ints in the buffer on success, 0 on error.</para>
        /// <para>|buffer| is an array of integers that describes the exact byte offsets of the</para>
        /// <para>trailer ends in the document. If |length| is less than the returned length,</para>
        /// <para>or |document| or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_GetTrailerEnds(global::PDFiumCore.FpdfDocumentT document, ref uint buffer, uint length)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (uint* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDF_GetTrailerEnds(__arg0, __arg1, length);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_GetDocPermissions</para>
        /// <para>Get file permission flags of the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>A 32-bit integer indicating permission flags. Please refer to the</para>
        /// <para>PDF Reference for detailed descriptions. If the document is not</para>
        /// <para>protected or was unlocked by the owner, 0xffffffff will be returned.</para>
        /// </summary>
        public static uint FPDF_GetDocPermissions(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetDocPermissions(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetDocUserPermissions</para>
        /// <para>Get user file permission flags of the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>A 32-bit integer indicating permission flags. Please refer to the</para>
        /// <para>PDF Reference for detailed descriptions. If the document is not</para>
        /// <para>protected, 0xffffffff will be returned. Always returns user</para>
        /// <para>permissions, even if the document was unlocked by the owner.</para>
        /// </summary>
        public static uint FPDF_GetDocUserPermissions(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetDocUserPermissions(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetSecurityHandlerRevision</para>
        /// <para>Get the revision for the security handler.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>The security handler revision number. Please refer to the PDF</para>
        /// <para>Reference for a detailed description. If the document is not</para>
        /// <para>protected, -1 will be returned.</para>
        /// </summary>
        public static int FPDF_GetSecurityHandlerRevision(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetSecurityHandlerRevision(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageCount</para>
        /// <para>Get total number of pages in the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>Total number of pages in the document.</para>
        /// </summary>
        public static int FPDF_GetPageCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetPageCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadPage</para>
        /// <para>Load a page inside the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument</para>
        /// <para>page_index  -   Index number of the page. 0 for the first page.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded page, or NULL if page load fails.</para>
        /// <para>Comments: The loaded page can be rendered to devices using FPDF_RenderPage. The loaded page can be closed using FPDF_ClosePage.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageT FPDF_LoadPage(global::PDFiumCore.FpdfDocumentT document, int page_index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_LoadPage(__arg0, page_index);
            var __result0 = global::PDFiumCore.FpdfPageT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageWidthF</para>
        /// <para>Get page width.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>Page width (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm).</para>
        /// </summary>
        public static float FPDF_GetPageWidthF(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageWidthF(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageWidth</para>
        /// <para>Get page width.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>Return value:</para>
        /// <para>Page width (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm).</para>
        /// <para>Note:</para>
        /// <para>Prefer FPDF_GetPageWidthF() above. This will be deprecated in the</para>
        /// <para>future.</para>
        /// </summary>
        public static double FPDF_GetPageWidth(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageWidth(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageHeightF</para>
        /// <para>Get page height.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>Page height (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm)</para>
        /// </summary>
        public static float FPDF_GetPageHeightF(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageHeightF(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageHeight</para>
        /// <para>Get page height.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>Return value:</para>
        /// <para>Page height (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm)</para>
        /// <para>Note:</para>
        /// <para>Prefer FPDF_GetPageHeightF() above. This will be deprecated in the</para>
        /// <para>future.</para>
        /// </summary>
        public static double FPDF_GetPageHeight(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageHeight(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageBoundingBox</para>
        /// <para>Get the bounding box of the page. This is the intersection between</para>
        /// <para>its media box and its crop box.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>rect        -   Pointer to a rect to receive the page bounding box. On an error, |rect| won't be filled.</para>
        /// <para>Return value:</para>
        /// <para>True for success.</para>
        /// </summary>
        public static int FPDF_GetPageBoundingBox(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDF_GetPageBoundingBox(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageSizeByIndexF</para>
        /// <para>Get the size of the page at the given index.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>page_index  -   Page index, zero for the first page.</para>
        /// <para>size        -   Pointer to a FS_SIZEF to receive the page size. (in points).</para>
        /// <para>Return value:</para>
        /// <para>Non-zero for success. 0 for error (document or page not found).</para>
        /// </summary>
        public static int FPDF_GetPageSizeByIndexF(global::PDFiumCore.FpdfDocumentT document, int page_index, global::PDFiumCore.FS_SIZEF_ size)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg2 = size is null ? __IntPtr.Zero : size.__Instance;
            var __ret = __Internal.FPDF_GetPageSizeByIndexF(__arg0, page_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageSizeByIndex</para>
        /// <para>Get the size of the page at the given index.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument.</para>
        /// <para>page_index  -   Page index, zero for the first page.</para>
        /// <para>width       -   Pointer to a double to receive the page width (in points).</para>
        /// <para>height      -   Pointer to a double to receive the page height (in points).</para>
        /// <para>Return value:</para>
        /// <para>Non-zero for success. 0 for error (document or page not found).</para>
        /// <para>Note:</para>
        /// <para>Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in</para>
        /// <para>the future.</para>
        /// </summary>
        public static int FPDF_GetPageSizeByIndex(global::PDFiumCore.FpdfDocumentT document, int page_index, ref double width, ref double height)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (double* __width2 = &width)
            {
                var __arg2 = __width2;
                fixed (double* __height3 = &height)
                {
                    var __arg3 = __height3;
                    var __ret = __Internal.FPDF_GetPageSizeByIndex(__arg0, page_index, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmap</para>
        /// <para>Render contents of a page to a device independent bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the device independent bitmap (as the output buffer). The bitmap handle can be created by FPDFBitmap_Create or retrieved from an image object by FPDFImageObj_GetBitmap.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage</para>
        /// <para>start_x     -   Left pixel position of the display area in bitmap coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in bitmap coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal) 1 (rotated 90 degrees clockwise) 2 (rotated 180 degrees) 3 (rotated 90 degrees counter-clockwise)</para>
        /// <para>flags       -   0 for normal display, or combination of the Page Rendering flags defined above. With the FPDF_ANNOT flag, it renders all annotations that do not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_RenderPageBitmap(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDF_RenderPageBitmap(__arg0, __arg1, start_x, start_y, size_x, size_y, rotate, flags);
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmapWithMatrix</para>
        /// <para>Render contents of a page to a device independent bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the device independent bitmap (as the output buffer). The bitmap handle can be created by FPDFBitmap_Create or retrieved by FPDFImageObj_GetBitmap.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>matrix      -   The transform matrix, which must be invertible. See PDF Reference 1.7, 4.2.2 Common Transformations.</para>
        /// <para>clipping    -   The rect to clip to in device coords.</para>
        /// <para>flags       -   0 for normal display, or combination of the Page Rendering flags defined above. With the FPDF_ANNOT flag, it renders all annotations that do not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>Return value:</para>
        /// <para>None. Note that behavior is undefined if det of |matrix| is 0.</para>
        /// </summary>
        public static void FPDF_RenderPageBitmapWithMatrix(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_MATRIX_ matrix, global::PDFiumCore.FS_RECTF_ clipping, int flags)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg2 = matrix is null ? __IntPtr.Zero : matrix.__Instance;
            var __arg3 = clipping is null ? __IntPtr.Zero : clipping.__Instance;
            __Internal.FPDF_RenderPageBitmapWithMatrix(__arg0, __arg1, __arg2, __arg3, flags);
        }

        /// <summary>
        /// <para>Function: FPDF_ClosePage</para>
        /// <para>Close a loaded PDF page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the loaded page.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_ClosePage(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDF_ClosePage(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_CloseDocument</para>
        /// <para>Close a loaded PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_CloseDocument(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            __Internal.FPDF_CloseDocument(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_DeviceToPage</para>
        /// <para>Convert the screen coordinates of a point to page coordinates.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>start_x     -   Left pixel position of the display area in device coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in device coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal) 1 (rotated 90 degrees clockwise) 2 (rotated 180 degrees) 3 (rotated 90 degrees counter-clockwise)</para>
        /// <para>device_x    -   X value in device coordinates to be converted.</para>
        /// <para>device_y    -   Y value in device coordinates to be converted.</para>
        /// <para>page_x      -   A pointer to a double receiving the converted X value in page coordinates.</para>
        /// <para>page_y      -   A pointer to a double receiving the converted Y value in page coordinates.</para>
        /// <para>Return value:</para>
        /// <para>Returns true if the conversion succeeds, and |page_x| and |page_y|</para>
        /// <para>successfully receives the converted coordinates.</para>
        /// <para>Comments: The page coordinate system has its origin at the left-bottom corner of the page, with the X-axis on the bottom going to the right, and the Y-axis on the left side going up.</para>
        /// <para>NOTE: this coordinate system can be altered when you zoom, scroll, or rotate a page, however, a point on the page should always have the same coordinate values in the page coordinate system.</para>
        /// <para>The device coordinate system is device dependent. For screen device, its origin is at the left-top corner of the window. However this origin can be altered by the Windows coordinate transformation utilities.</para>
        /// <para>You must make sure the start_x, start_y, size_x, size_y and rotate parameters have exactly same values as you used in the FPDF_RenderPage() function call.</para>
        /// </summary>
        public static int FPDF_DeviceToPage(global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int device_x, int device_y, ref double page_x, ref double page_y)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (double* __page_x8 = &page_x)
            {
                var __arg8 = __page_x8;
                fixed (double* __page_y9 = &page_y)
                {
                    var __arg9 = __page_y9;
                    var __ret = __Internal.FPDF_DeviceToPage(__arg0, start_x, start_y, size_x, size_y, rotate, device_x, device_y, __arg8, __arg9);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDF_PageToDevice</para>
        /// <para>Convert the page coordinates of a point to screen coordinates.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>start_x     -   Left pixel position of the display area in device coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in device coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal) 1 (rotated 90 degrees clockwise) 2 (rotated 180 degrees) 3 (rotated 90 degrees counter-clockwise)</para>
        /// <para>page_x      -   X value in page coordinates.</para>
        /// <para>page_y      -   Y value in page coordinate.</para>
        /// <para>device_x    -   A pointer to an integer receiving the result X value in device coordinates.</para>
        /// <para>device_y    -   A pointer to an integer receiving the result Y value in device coordinates.</para>
        /// <para>Return value:</para>
        /// <para>Returns true if the conversion succeeds, and |device_x| and</para>
        /// <para>|device_y| successfully receives the converted coordinates.</para>
        /// <para>Comments: See comments for FPDF_DeviceToPage().</para>
        /// </summary>
        public static int FPDF_PageToDevice(global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, double page_x, double page_y, ref int device_x, ref int device_y)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (int* __device_x8 = &device_x)
            {
                var __arg8 = __device_x8;
                fixed (int* __device_y9 = &device_y)
                {
                    var __arg9 = __device_y9;
                    var __ret = __Internal.FPDF_PageToDevice(__arg0, start_x, start_y, size_x, size_y, rotate, page_x, page_y, __arg8, __arg9);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_Create</para>
        /// <para>Create a device independent bitmap (FXDIB).</para>
        /// <para>Parameters:</para>
        /// <para>width       -   The number of pixels in width for the bitmap. Must be greater than 0.</para>
        /// <para>height      -   The number of pixels in height for the bitmap. Must be greater than 0.</para>
        /// <para>alpha       -   A flag indicating whether the alpha channel is used. Non-zero for using alpha, zero for not using.</para>
        /// <para>Return value:</para>
        /// <para>The created bitmap handle, or NULL if a parameter error or out of</para>
        /// <para>memory.</para>
        /// <para>Comments: The bitmap always uses 4 bytes per pixel. The first byte is always double word aligned.</para>
        /// <para>The byte order is BGRx (the last byte unused if no alpha channel) or BGRA.</para>
        /// <para>The pixels in a horizontal line are stored side by side, with the left most pixel stored first (with lower memory address). Each line uses width * 4 bytes.</para>
        /// <para>Lines are stored one after another, with the top most line stored first. There is no gap between adjacent lines.</para>
        /// <para>This function allocates enough memory for holding all pixels in the bitmap, but it doesn't initialize the buffer. Applications can use FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS allows it, this function can allocate up to 4 GB of memory.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFBitmapCreate(int width, int height, int alpha)
        {
            var __ret = __Internal.FPDFBitmapCreate(width, height, alpha);
            var __result0 = global::PDFiumCore.FpdfBitmapT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_CreateEx</para>
        /// <para>Create a device independent bitmap (FXDIB)</para>
        /// <para>Parameters:</para>
        /// <para>width       -   The number of pixels in width for the bitmap. Must be greater than 0.</para>
        /// <para>height      -   The number of pixels in height for the bitmap. Must be greater than 0.</para>
        /// <para>format      -   A number indicating for bitmap format, as defined above.</para>
        /// <para>first_scan  -   A pointer to the first byte of the first line if using an external buffer. If this parameter is NULL, then a new buffer will be created.</para>
        /// <para>stride      -   Number of bytes for each scan line. The value must be 0 or greater. When the value is 0, FPDFBitmap_CreateEx() will automatically calculate the appropriate value using |width| and |format|. When using an external buffer, it is recommended for the caller to pass in the value. When not using an external buffer, it is recommended for the caller to pass in 0.</para>
        /// <para>Return value:</para>
        /// <para>The bitmap handle, or NULL if parameter error or out of memory.</para>
        /// <para>Comments: Similar to FPDFBitmap_Create function, but allows for more formats and an external buffer is supported. The bitmap created by this function can be used in any place that a FPDF_BITMAP handle is required.</para>
        /// <para>If an external buffer is used, then the caller should destroy the buffer. FPDFBitmap_Destroy() will not destroy the buffer.</para>
        /// <para>It is recommended to use FPDFBitmap_GetStride() to get the stride value.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFBitmapCreateEx(int width, int height, int format, __IntPtr first_scan, int stride)
        {
            var __ret = __Internal.FPDFBitmapCreateEx(width, height, format, first_scan, stride);
            var __result0 = global::PDFiumCore.FpdfBitmapT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetFormat</para>
        /// <para>Get the format of the bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The format of the bitmap.</para>
        /// <para>Comments: Only formats supported by FPDFBitmap_CreateEx are supported by this function; see the list of such formats above.</para>
        /// </summary>
        public static int FPDFBitmapGetFormat(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetFormat(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_FillRect</para>
        /// <para>Fill a rectangle in a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   The handle to the bitmap. Returned by FPDFBitmap_Create.</para>
        /// <para>left        -   The left position. Starting from 0 at the left-most pixel.</para>
        /// <para>top         -   The top position. Starting from 0 at the top-most line.</para>
        /// <para>width       -   Width in pixels to be filled.</para>
        /// <para>height      -   Height in pixels to be filled.</para>
        /// <para>color       -   A 32-bit value specifing the color, in 8888 ARGB format.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function sets the color and (optionally) alpha value in the specified region of the bitmap.</para>
        /// <para>NOTE: If the alpha channel is used, this function does NOT composite the background with the source color, instead the background will be replaced by the source color and the alpha.</para>
        /// <para>If the alpha channel is not used, the alpha parameter is ignored.</para>
        /// </summary>
        public static void FPDFBitmapFillRect(global::PDFiumCore.FpdfBitmapT bitmap, int left, int top, int width, int height, uint color)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            __Internal.FPDFBitmapFillRect(__arg0, left, top, width, height, color);
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetBuffer</para>
        /// <para>Get data buffer of a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The pointer to the first byte of the bitmap buffer.</para>
        /// <para>Comments: The stride may be more than width * number of bytes per pixel</para>
        /// <para>Applications can use this function to get the bitmap buffer pointer, then manipulate any color and/or alpha values for any pixels in the bitmap.</para>
        /// <para>Use FPDFBitmap_GetFormat() to find out the format of the data.</para>
        /// </summary>
        public static __IntPtr FPDFBitmapGetBuffer(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetBuffer(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetWidth</para>
        /// <para>Get width of a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The width of the bitmap in pixels.</para>
        /// </summary>
        public static int FPDFBitmapGetWidth(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetWidth(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetHeight</para>
        /// <para>Get height of a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The height of the bitmap in pixels.</para>
        /// </summary>
        public static int FPDFBitmapGetHeight(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetHeight(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetStride</para>
        /// <para>Get number of bytes for each line in the bitmap buffer.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes for each line in the bitmap buffer.</para>
        /// <para>Comments: The stride may be more than width * number of bytes per pixel.</para>
        /// </summary>
        public static int FPDFBitmapGetStride(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetStride(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_Destroy</para>
        /// <para>Destroy a bitmap and release all related buffers.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function will not destroy any external buffers provided when the bitmap was created.</para>
        /// </summary>
        public static void FPDFBitmapDestroy(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            __Internal.FPDFBitmapDestroy(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintScaling</para>
        /// <para>Whether the PDF document prefers to be scaled or not.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static int FPDF_VIEWERREF_GetPrintScaling(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintScaling(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetNumCopies</para>
        /// <para>Returns the number of copies to be printed.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>The number of copies to be printed.</para>
        /// </summary>
        public static int FPDF_VIEWERREF_GetNumCopies(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetNumCopies(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintPageRange</para>
        /// <para>Page numbers to initialize print dialog box when file is printed.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>The print page range to be used for printing.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPagerangeT FPDF_VIEWERREF_GetPrintPageRange(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintPageRange(__arg0);
            var __result0 = global::PDFiumCore.FpdfPagerangeT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintPageRangeCount</para>
        /// <para>Returns the number of elements in a FPDF_PAGERANGE.</para>
        /// <para>Parameters:</para>
        /// <para>pagerange   -   Handle to the page range.</para>
        /// <para>Return value:</para>
        /// <para>The number of elements in the page range. Returns 0 on error.</para>
        /// </summary>
        public static ulong FPDF_VIEWERREF_GetPrintPageRangeCount(global::PDFiumCore.FpdfPagerangeT pagerange)
        {
            var __arg0 = pagerange is null ? __IntPtr.Zero : pagerange.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintPageRangeCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintPageRangeElement</para>
        /// <para>Returns an element from a FPDF_PAGERANGE.</para>
        /// <para>Parameters:</para>
        /// <para>pagerange   -   Handle to the page range.</para>
        /// <para>index       -   Index of the element.</para>
        /// <para>Return value:</para>
        /// <para>The value of the element in the page range at a given index.</para>
        /// <para>Returns -1 on error.</para>
        /// </summary>
        public static int FPDF_VIEWERREF_GetPrintPageRangeElement(global::PDFiumCore.FpdfPagerangeT pagerange, ulong index)
        {
            var __arg0 = pagerange is null ? __IntPtr.Zero : pagerange.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintPageRangeElement(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetDuplex</para>
        /// <para>Returns the paper handling option to be used when printing from</para>
        /// <para>the print dialog.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>The paper handling option to be used when printing.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_DUPLEXTYPE_ FPDF_VIEWERREF_GetDuplex(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetDuplex(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetName</para>
        /// <para>Gets the contents for a viewer ref, with a given key. The value must</para>
        /// <para>be of type &quot;name&quot;.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>key         -   Name of the key in the viewer pref dictionary, encoded in UTF-8.</para>
        /// <para>buffer      -   A string to write the contents of the key to.</para>
        /// <para>length      -   Length of the buffer.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the contents, including the NULL terminator.</para>
        /// <para>Thus if the return value is 0, then that indicates an error, such</para>
        /// <para>as when |document| is invalid or |buffer| is NULL. If |length| is</para>
        /// <para>less than the returned length, or |buffer| is NULL, |buffer| will</para>
        /// <para>not be modified.</para>
        /// </summary>
        public static uint FPDF_VIEWERREF_GetName(global::PDFiumCore.FpdfDocumentT document, string key, sbyte* buffer, uint length)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetName(__arg0, key, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_CountNamedDests</para>
        /// <para>Get the count of named destinations in the PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document</para>
        /// <para>Return value:</para>
        /// <para>The count of named destinations.</para>
        /// </summary>
        public static uint FPDF_CountNamedDests(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_CountNamedDests(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetNamedDestByName</para>
        /// <para>Get a the destination handle for the given name.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>name        -   The name of a destination.</para>
        /// <para>Return value:</para>
        /// <para>The handle to the destination.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDF_GetNamedDestByName(global::PDFiumCore.FpdfDocumentT document, string name)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetNamedDestByName(__arg0, name);
            var __result0 = global::PDFiumCore.FpdfDestT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_GetNamedDest</para>
        /// <para>Get the named destination by index.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to a document</para>
        /// <para>index           -   The index of a named destination.</para>
        /// <para>buffer          -   The buffer to store the destination name, used as wchar_t*.</para>
        /// <para>buflen [in/out] -   Size of the buffer in bytes on input, length of the result in bytes on output or -1 if the buffer is too small.</para>
        /// <para>Return value:</para>
        /// <para>The destination handle for a given index, or NULL if there is no</para>
        /// <para>named destination corresponding to |index|.</para>
        /// <para>Comments: Call this function twice to get the name of the named destination: 1) First time pass in |buffer| as NULL and get buflen. 2) Second time pass in allocated |buffer| and buflen to retrieve |buffer|, which should be used as wchar_t*.</para>
        /// <para>If buflen is not sufficiently large, it will be set to -1 upon return.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDF_GetNamedDest(global::PDFiumCore.FpdfDocumentT document, int index, __IntPtr buffer, ref int buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (int* __buflen3 = &buflen)
            {
                var __arg3 = __buflen3;
                var __ret = __Internal.FPDF_GetNamedDest(__arg0, index, buffer, __arg3);
                var __result0 = global::PDFiumCore.FpdfDestT.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_GetXFAPacketCount</para>
        /// <para>Get the number of valid packets in the XFA entry.</para>
        /// <para>Parameters:</para>
        /// <para>document - Handle to the document.</para>
        /// <para>Return value:</para>
        /// <para>The number of valid packets, or -1 on error.</para>
        /// </summary>
        public static int FPDF_GetXFAPacketCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetXFAPacketCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetXFAPacketName</para>
        /// <para>Get the name of a packet in the XFA array.</para>
        /// <para>Parameters:</para>
        /// <para>document - Handle to the document.</para>
        /// <para>index    - Index number of the packet. 0 for the first packet.</para>
        /// <para>buffer   - Buffer for holding the name of the XFA packet.</para>
        /// <para>buflen   - Length of |buffer| in bytes.</para>
        /// <para>Return value:</para>
        /// <para>The length of the packet name in bytes, or 0 on error.</para>
        /// <para>|document| must be valid and |index| must be in the range [0, N), where N is</para>
        /// <para>the value returned by FPDF_GetXFAPacketCount().</para>
        /// <para>|buffer| is only modified if it is non-NULL and |buflen| is greater than or</para>
        /// <para>equal to the length of the packet name. The packet name includes a</para>
        /// <para>terminating NUL character. |buffer| is unmodified on error.</para>
        /// </summary>
        public static uint FPDF_GetXFAPacketName(global::PDFiumCore.FpdfDocumentT document, int index, __IntPtr buffer, uint buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetXFAPacketName(__arg0, index, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetXFAPacketContent</para>
        /// <para>Get the content of a packet in the XFA array.</para>
        /// <para>Parameters:</para>
        /// <para>document   - Handle to the document.</para>
        /// <para>index      - Index number of the packet. 0 for the first packet.</para>
        /// <para>buffer     - Buffer for holding the content of the XFA packet.</para>
        /// <para>buflen     - Length of |buffer| in bytes.</para>
        /// <para>out_buflen - Pointer to the variable that will receive the minimum buffer size needed to contain the content of the XFA packet.</para>
        /// <para>Return value:</para>
        /// <para>Whether the operation succeeded or not.</para>
        /// <para>|document| must be valid and |index| must be in the range [0, N), where N is</para>
        /// <para>the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be</para>
        /// <para>NULL. When the aforementioned arguments are valid, the operation succeeds,</para>
        /// <para>and |out_buflen| receives the content size. |buffer| is only modified if</para>
        /// <para>|buffer| is non-null and long enough to contain the content. Callers must</para>
        /// <para>check both the return value and the input |buflen| is no less than the</para>
        /// <para>returned |out_buflen| before using the data in |buffer|.</para>
        /// </summary>
        public static int FPDF_GetXFAPacketContent(global::PDFiumCore.FpdfDocumentT document, int index, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDF_GetXFAPacketContent(__arg0, index, buffer, buflen, __arg4);
                return __ret;
            }
        }
    }

    namespace Std
    {
    }

    public enum FPDFANNOT_COLORTYPE
    {
        FPDFANNOT_COLORTYPE_Color = 0,
        FPDFANNOT_COLORTYPE_InteriorColor = 1
    }

    public unsafe partial class fpdf_annot
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_IsSupportedSubtype", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotIsSupportedSubtype(int subtype);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_CreateAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageCreateAnnot(__IntPtr page, int subtype);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetAnnotCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetAnnotCount(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageGetAnnot(__IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetAnnotIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetAnnotIndex(__IntPtr page, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_CloseAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageCloseAnnot(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_RemoveAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageRemoveAnnot(__IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetSubtype", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetSubtype(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_IsObjectSupportedSubtype", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotIsObjectSupportedSubtype(int subtype);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_UpdateObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotUpdateObject(__IntPtr annot, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_AddInkStroke", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotAddInkStroke(__IntPtr annot, __IntPtr points, ulong point_count);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_RemoveInkList", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotRemoveInkList(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_AppendObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotAppendObject(__IntPtr annot, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetObjectCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetObjectCount(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFAnnotGetObject(__IntPtr annot, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_RemoveObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotRemoveObject(__IntPtr annot, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetColor(__IntPtr annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, uint R, uint G, uint B, uint A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetColor(__IntPtr annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_HasAttachmentPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotHasAttachmentPoints(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetAttachmentPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetAttachmentPoints(__IntPtr annot, ulong quad_index, __IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_AppendAttachmentPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotAppendAttachmentPoints(__IntPtr annot, __IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_CountAttachmentPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong FPDFAnnotCountAttachmentPoints(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetAttachmentPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetAttachmentPoints(__IntPtr annot, ulong quad_index, __IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetRect(__IntPtr annot, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetRect(__IntPtr annot, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetVertices", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetVertices(__IntPtr annot, __IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetInkListCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetInkListCount(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetInkListPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetInkListPath(__IntPtr annot, uint path_index, __IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetLine", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetLine(__IntPtr annot, __IntPtr start, __IntPtr end);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetBorder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetBorder(__IntPtr annot, float horizontal_radius, float vertical_radius, float border_width);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetBorder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetBorder(__IntPtr annot, float* horizontal_radius, float* vertical_radius, float* border_width);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormAdditionalActionJavaScript", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetFormAdditionalActionJavaScript(__IntPtr hHandle, __IntPtr annot, int @event, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_HasKey", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotHasKey(__IntPtr annot, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetValueType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetValueType(__IntPtr annot, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetStringValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetStringValue(__IntPtr annot, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, ushort* value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetStringValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetStringValue(__IntPtr annot, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetNumberValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetNumberValue(__IntPtr annot, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, float* value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetAP", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetAP(__IntPtr annot, int appearanceMode, ushort* value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetAP", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetAP(__IntPtr annot, int appearanceMode, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetLinkedAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFAnnotGetLinkedAnnot(__IntPtr annot, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFlags(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetFlags(__IntPtr annot, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormFieldFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFormFieldFlags(__IntPtr handle, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormFieldAtPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFAnnotGetFormFieldAtPoint(__IntPtr hHandle, __IntPtr page, __IntPtr point);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormFieldName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetFormFieldName(__IntPtr hHandle, __IntPtr annot, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormFieldAlternateName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetFormFieldAlternateName(__IntPtr hHandle, __IntPtr annot, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormFieldType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFormFieldType(__IntPtr hHandle, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormFieldValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetFormFieldValue(__IntPtr hHandle, __IntPtr annot, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetOptionCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetOptionCount(__IntPtr hHandle, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetOptionLabel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetOptionLabel(__IntPtr hHandle, __IntPtr annot, int index, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_IsOptionSelected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotIsOptionSelected(__IntPtr handle, __IntPtr annot, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFontSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFontSize(__IntPtr hHandle, __IntPtr annot, float* value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_IsChecked", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotIsChecked(__IntPtr hHandle, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetFocusableSubtypes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetFocusableSubtypes(__IntPtr hHandle, int* subtypes, ulong count);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFocusableSubtypesCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFocusableSubtypesCount(__IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFocusableSubtypes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFocusableSubtypes(__IntPtr hHandle, int* subtypes, ulong count);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetLink", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFAnnotGetLink(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormControlCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFormControlCount(__IntPtr hHandle, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormControlIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotGetFormControlIndex(__IntPtr hHandle, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_GetFormFieldExportValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAnnotGetFormFieldExportValue(__IntPtr hHandle, __IntPtr annot, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAnnot_SetURI", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAnnotSetURI(__IntPtr annot, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string uri);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if an annotation subtype is currently supported for creation.</para>
        /// <para>Currently supported subtypes:</para>
        /// <para>- circle</para>
        /// <para>- freetext</para>
        /// <para>- highlight</para>
        /// <para>- ink</para>
        /// <para>- link</para>
        /// <para>- popup</para>
        /// <para>- square,</para>
        /// <para>- squiggly</para>
        /// <para>- stamp</para>
        /// <para>- strikeout</para>
        /// <para>- text</para>
        /// <para>- underline</para>
        /// <para>subtype   - the subtype to be checked.</para>
        /// <para>Returns true if this subtype supported.</para>
        /// </summary>
        public static int FPDFAnnotIsSupportedSubtype(int subtype)
        {
            var __ret = __Internal.FPDFAnnotIsSupportedSubtype(subtype);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Create an annotation in |page| of the subtype |subtype|. If the specified</para>
        /// <para>subtype is illegal or unsupported, then a new annotation will not be created.</para>
        /// <para>Must call FPDFPage_CloseAnnot() when the annotation returned by this</para>
        /// <para>function is no longer needed.</para>
        /// <para>page      - handle to a page.</para>
        /// <para>subtype   - the subtype of the new annotation.</para>
        /// <para>Returns a handle to the new annotation object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFPageCreateAnnot(global::PDFiumCore.FpdfPageT page, int subtype)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageCreateAnnot(__arg0, subtype);
            var __result0 = global::PDFiumCore.FpdfAnnotationT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of annotations in |page|.</para>
        /// <para>page   - handle to a page.</para>
        /// <para>Returns the number of annotations in |page|.</para>
        /// </summary>
        public static int FPDFPageGetAnnotCount(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetAnnotCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get annotation in |page| at |index|. Must call FPDFPage_CloseAnnot() when the</para>
        /// <para>annotation returned by this function is no longer needed.</para>
        /// <para>page  - handle to a page.</para>
        /// <para>index - the index of the annotation.</para>
        /// <para>Returns a handle to the annotation object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFPageGetAnnot(global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetAnnot(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfAnnotationT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the index of |annot| in |page|. This is the opposite of</para>
        /// <para>FPDFPage_GetAnnot().</para>
        /// <para>page  - handle to the page that the annotation is on.</para>
        /// <para>annot - handle to an annotation.</para>
        /// <para>Returns the index of |annot|, or -1 on failure.</para>
        /// </summary>
        public static int FPDFPageGetAnnotIndex(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFPageGetAnnotIndex(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Close an annotation. Must be called when the annotation returned by</para>
        /// <para>FPDFPage_CreateAnnot() or FPDFPage_GetAnnot() is no longer needed. This</para>
        /// <para>function does not remove the annotation from the document.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// </summary>
        public static void FPDFPageCloseAnnot(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            __Internal.FPDFPageCloseAnnot(__arg0);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Remove the annotation in |page| at |index|.</para>
        /// <para>page  - handle to a page.</para>
        /// <para>index - the index of the annotation.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFPageRemoveAnnot(global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageRemoveAnnot(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the subtype of an annotation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns the annotation subtype.</para>
        /// </summary>
        public static int FPDFAnnotGetSubtype(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetSubtype(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if an annotation subtype is currently supported for object extraction,</para>
        /// <para>update, and removal.</para>
        /// <para>Currently supported subtypes: ink and stamp.</para>
        /// <para>subtype   - the subtype to be checked.</para>
        /// <para>Returns true if this subtype supported.</para>
        /// </summary>
        public static int FPDFAnnotIsObjectSupportedSubtype(int subtype)
        {
            var __ret = __Internal.FPDFAnnotIsObjectSupportedSubtype(subtype);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Update |obj| in |annot|. |obj| must be in |annot| already and must have</para>
        /// <para>been retrieved by FPDFAnnot_GetObject(). Currently, only ink and stamp</para>
        /// <para>annotations are supported by this API. Also note that only path, image, and</para>
        /// <para>text objects have APIs for modification; see FPDFPath_*(), FPDFText_*(), and</para>
        /// <para>FPDFImageObj_*().</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>obj    - handle to the object that |annot| needs to update.</para>
        /// <para>Return true if successful.</para>
        /// </summary>
        public static int FPDFAnnotUpdateObject(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FpdfPageobjectT obj)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __ret = __Internal.FPDFAnnotUpdateObject(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add a new InkStroke, represented by an array of points, to the InkList of</para>
        /// <para>|annot|. The API creates an InkList if one doesn't already exist in |annot|.</para>
        /// <para>This API works only for ink annotations. Please refer to ISO 32000-1:2008</para>
        /// <para>spec, section 12.5.6.13.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>points      - pointer to a FS_POINTF array representing input points.</para>
        /// <para>point_count - number of elements in |points| array. This should not exceed</para>
        /// <para>the maximum value that can be represented by an int32_t).</para>
        /// <para>Returns the 0-based index at which the new InkStroke is added in the InkList</para>
        /// <para>of the |annot|. Returns -1 on failure.</para>
        /// </summary>
        public static int FPDFAnnotAddInkStroke(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_POINTF_ points, ulong point_count)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            var __ret = __Internal.FPDFAnnotAddInkStroke(__arg0, __arg1, point_count);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Removes an InkList in |annot|.</para>
        /// <para>This API works only for ink annotations.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Return true on successful removal of /InkList entry from context of the</para>
        /// <para>non-null ink |annot|. Returns false on failure.</para>
        /// </summary>
        public static int FPDFAnnotRemoveInkList(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotRemoveInkList(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add |obj| to |annot|. |obj| must have been created by</para>
        /// <para>FPDFPageObj_CreateNew{Path|Rect}() or FPDFPageObj_New{Text|Image}Obj(), and</para>
        /// <para>will be owned by |annot|. Note that an |obj| cannot belong to more than one</para>
        /// <para>|annot|. Currently, only ink and stamp annotations are supported by this API.</para>
        /// <para>Also note that only path, image, and text objects have APIs for creation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>obj    - handle to the object that is to be added to |annot|.</para>
        /// <para>Return true if successful.</para>
        /// </summary>
        public static int FPDFAnnotAppendObject(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FpdfPageobjectT obj)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __ret = __Internal.FPDFAnnotAppendObject(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the total number of objects in |annot|, including path objects, text</para>
        /// <para>objects, external objects, image objects, and shading objects.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns the number of objects in |annot|.</para>
        /// </summary>
        public static int FPDFAnnotGetObjectCount(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetObjectCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the object in |annot| at |index|.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>index  - the index of the object.</para>
        /// <para>Return a handle to the object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFAnnotGetObject(global::PDFiumCore.FpdfAnnotationT annot, int index)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetObject(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Remove the object in |annot| at |index|.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>index  - the index of the object to be removed.</para>
        /// <para>Return true if successful.</para>
        /// </summary>
        public static int FPDFAnnotRemoveObject(global::PDFiumCore.FpdfAnnotationT annot, int index)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotRemoveObject(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the color of an annotation. Fails when called on annotations with</para>
        /// <para>appearance streams already defined; instead use</para>
        /// <para>FPDFPath_Set{Stroke|Fill}Color().</para>
        /// <para>annot    - handle to an annotation.</para>
        /// <para>type     - type of the color to be set.</para>
        /// <para>R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.</para>
        /// <para>A        - buffer to hold the opacity. Ranges from 0 to 255.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetColor(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, uint R, uint G, uint B, uint A)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotSetColor(__arg0, type, R, G, B, A);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the color of an annotation. If no color is specified, default to yellow</para>
        /// <para>for highlight annotation, black for all else. Fails when called on</para>
        /// <para>annotations with appearance streams already defined; instead use</para>
        /// <para>FPDFPath_Get{Stroke|Fill}Color().</para>
        /// <para>annot    - handle to an annotation.</para>
        /// <para>type     - type of the color requested.</para>
        /// <para>R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.</para>
        /// <para>A        - buffer to hold the opacity. Ranges from 0 to 255.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotGetColor(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var __ret = __Internal.FPDFAnnotGetColor(__arg0, type, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if the annotation is of a type that has attachment points</para>
        /// <para>(i.e. quadpoints). Quadpoints are the vertices of the rectangle that</para>
        /// <para>encompasses the texts affected by the annotation. They provide the</para>
        /// <para>coordinates in the page where the annotation is attached. Only text markup</para>
        /// <para>annotations (i.e. highlight, strikeout, squiggly, and underline) and link</para>
        /// <para>annotations have quadpoints.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns true if the annotation is of a type that has quadpoints, false</para>
        /// <para>otherwise.</para>
        /// </summary>
        public static int FPDFAnnotHasAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotHasAttachmentPoints(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Replace the attachment points (i.e. quadpoints) set of an annotation at</para>
        /// <para>|quad_index|. This index needs to be within the result of</para>
        /// <para>FPDFAnnot_CountAttachmentPoints().</para>
        /// <para>If the annotation's appearance stream is defined and this annotation is of a</para>
        /// <para>type with quadpoints, then update the bounding box too if the new quadpoints</para>
        /// <para>define a bigger one.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>quad_index  - index of the set of quadpoints.</para>
        /// <para>quad_points - the quadpoints to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot, ulong quad_index, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg2 = quad_points is null ? __IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFAnnotSetAttachmentPoints(__arg0, quad_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Append to the list of attachment points (i.e. quadpoints) of an annotation.</para>
        /// <para>If the annotation's appearance stream is defined and this annotation is of a</para>
        /// <para>type with quadpoints, then update the bounding box too if the new quadpoints</para>
        /// <para>define a bigger one.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>quad_points - the quadpoints to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotAppendAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = quad_points is null ? __IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFAnnotAppendAttachmentPoints(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of sets of quadpoints of an annotation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns the number of sets of quadpoints, or 0 on failure.</para>
        /// </summary>
        public static ulong FPDFAnnotCountAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotCountAttachmentPoints(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the attachment points (i.e. quadpoints) of an annotation.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>quad_index  - index of the set of quadpoints.</para>
        /// <para>quad_points - receives the quadpoints; must not be NULL.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotGetAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot, ulong quad_index, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg2 = quad_points is null ? __IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFAnnotGetAttachmentPoints(__arg0, quad_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the annotation rectangle defining the location of the annotation. If the</para>
        /// <para>annotation's appearance stream is defined and this annotation is of a type</para>
        /// <para>without quadpoints, then update the bounding box too if the new rectangle</para>
        /// <para>defines a bigger one.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>rect   - the annotation rectangle to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetRect(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFAnnotSetRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation rectangle defining the location of the annotation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>rect   - receives the rectangle; must not be NULL.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotGetRect(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFAnnotGetRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the vertices of a polygon or polyline annotation. |buffer| is an array of</para>
        /// <para>points of the annotation. If |length| is less than the returned length, or</para>
        /// <para>|annot| or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>buffer - buffer for holding the points.</para>
        /// <para>length - length of the buffer in points.</para>
        /// <para>Returns the number of points if the annotation is of type polygon or</para>
        /// <para>polyline, 0 otherwise.</para>
        /// </summary>
        public static uint FPDFAnnotGetVertices(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_POINTF_ buffer, uint length)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = buffer is null ? __IntPtr.Zero : buffer.__Instance;
            var __ret = __Internal.FPDFAnnotGetVertices(__arg0, __arg1, length);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of paths in the ink list of an ink annotation.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>Returns the number of paths in the ink list if the annotation is of type ink,</para>
        /// <para>0 otherwise.</para>
        /// </summary>
        public static uint FPDFAnnotGetInkListCount(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetInkListCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get a path in the ink list of an ink annotation. |buffer| is an array of</para>
        /// <para>points of the path. If |length| is less than the returned length, or |annot|</para>
        /// <para>or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>path_index - index of the path</para>
        /// <para>buffer - buffer for holding the points.</para>
        /// <para>length - length of the buffer in points.</para>
        /// <para>Returns the number of points of the path if the annotation is of type ink, 0</para>
        /// <para>otherwise.</para>
        /// </summary>
        public static uint FPDFAnnotGetInkListPath(global::PDFiumCore.FpdfAnnotationT annot, uint path_index, global::PDFiumCore.FS_POINTF_ buffer, uint length)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg2 = buffer is null ? __IntPtr.Zero : buffer.__Instance;
            var __ret = __Internal.FPDFAnnotGetInkListPath(__arg0, path_index, __arg2, length);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the starting and ending coordinates of a line annotation.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>start - starting point</para>
        /// <para>end - ending point</para>
        /// <para>Returns true if the annotation is of type line, |start| and |end| are not</para>
        /// <para>NULL, false otherwise.</para>
        /// </summary>
        public static int FPDFAnnotGetLine(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_POINTF_ start, global::PDFiumCore.FS_POINTF_ end)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __arg1 = start is null ? __IntPtr.Zero : start.__Instance;
            var __arg2 = end is null ? __IntPtr.Zero : end.__Instance;
            var __ret = __Internal.FPDFAnnotGetLine(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the characteristics of the annotation's border (rounded rectangle).</para>
        /// <para>annot              - handle to an annotation</para>
        /// <para>horizontal_radius  - horizontal corner radius, in default user space units</para>
        /// <para>vertical_radius    - vertical corner radius, in default user space units</para>
        /// <para>border_width       - border width, in default user space units</para>
        /// <para>Returns true if setting the border for |annot| succeeds, false otherwise.</para>
        /// <para>If |annot| contains an appearance stream that overrides the border values,</para>
        /// <para>then the appearance stream will be removed on success.</para>
        /// </summary>
        public static int FPDFAnnotSetBorder(global::PDFiumCore.FpdfAnnotationT annot, float horizontal_radius, float vertical_radius, float border_width)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotSetBorder(__arg0, horizontal_radius, vertical_radius, border_width);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the characteristics of the annotation's border (rounded rectangle).</para>
        /// <para>annot              - handle to an annotation</para>
        /// <para>horizontal_radius  - horizontal corner radius, in default user space units</para>
        /// <para>vertical_radius    - vertical corner radius, in default user space units</para>
        /// <para>border_width       - border width, in default user space units</para>
        /// <para>Returns true if |horizontal_radius|, |vertical_radius| and |border_width| are</para>
        /// <para>not NULL, false otherwise.</para>
        /// </summary>
        public static int FPDFAnnotGetBorder(global::PDFiumCore.FpdfAnnotationT annot, ref float horizontal_radius, ref float vertical_radius, ref float border_width)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (float* __horizontal_radius1 = &horizontal_radius)
            {
                var __arg1 = __horizontal_radius1;
                fixed (float* __vertical_radius2 = &vertical_radius)
                {
                    var __arg2 = __vertical_radius2;
                    fixed (float* __border_width3 = &border_width)
                    {
                        var __arg3 = __border_width3;
                        var __ret = __Internal.FPDFAnnotGetBorder(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the JavaScript of an event of the annotation's additional actions.</para>
        /// <para>|buffer| is only modified if |buflen| is large enough to hold the whole</para>
        /// <para>JavaScript string. If |buflen| is smaller, the total size of the JavaScript</para>
        /// <para>is still returned, but nothing is copied.  If there is no JavaScript for</para>
        /// <para>|event| in |annot|, an empty string is written to |buf| and 2 is returned,</para>
        /// <para>denoting the size of the null terminator in the buffer.  On other errors,</para>
        /// <para>nothing is written to |buffer| and 0 is returned.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>event       -   event type, one of the FPDF_ANNOT_AACTION_* values.</para>
        /// <para>buffer      -   buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes, including the 2-byte</para>
        /// <para>null terminator.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormAdditionalActionJavaScript(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, int @event, ref ushort buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer3 = &buffer)
            {
                var __arg3 = __buffer3;
                var __ret = __Internal.FPDFAnnotGetFormAdditionalActionJavaScript(__arg0, __arg1, @event, __arg3, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if |annot|'s dictionary has |key| as a key.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns true if |key| exists.</para>
        /// </summary>
        public static int FPDFAnnotHasKey(global::PDFiumCore.FpdfAnnotationT annot, string key)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotHasKey(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the type of the value corresponding to |key| in |annot|'s dictionary.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns the type of the dictionary value.</para>
        /// </summary>
        public static int FPDFAnnotGetValueType(global::PDFiumCore.FpdfAnnotationT annot, string key)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetValueType(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the string value corresponding to |key| in |annot|'s dictionary,</para>
        /// <para>overwriting the existing value if any. The value type would be</para>
        /// <para>FPDF_OBJECT_STRING after this function call succeeds.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the dictionary entry to be set, encoded in UTF-8.</para>
        /// <para>value  - the string value to be set, encoded in UTF-16LE.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetStringValue(global::PDFiumCore.FpdfAnnotationT annot, string key, ref ushort value)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotSetStringValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the string value corresponding to |key| in |annot|'s dictionary. |buffer|</para>
        /// <para>is only modified if |buflen| is longer than the length of contents. Note that</para>
        /// <para>if |key| does not exist in the dictionary or if |key|'s corresponding value</para>
        /// <para>in the dictionary is not a string (i.e. the value is not of type</para>
        /// <para>FPDF_OBJECT_STRING or FPDF_OBJECT_NAME), then an empty string would be copied</para>
        /// <para>to |buffer| and the return value would be 2. On other errors, nothing would</para>
        /// <para>be added to |buffer| and the return value would be 0.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the requested dictionary entry, encoded in UTF-8.</para>
        /// <para>buffer - buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen - length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetStringValue(global::PDFiumCore.FpdfAnnotationT annot, string key, ref ushort buffer, uint buflen)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetStringValue(__arg0, key, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the float value corresponding to |key| in |annot|'s dictionary. Writes</para>
        /// <para>value to |value| and returns True if |key| exists in the dictionary and</para>
        /// <para>|key|'s corresponding value is a number (FPDF_OBJECT_NUMBER), False</para>
        /// <para>otherwise.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the requested dictionary entry, encoded in UTF-8.</para>
        /// <para>value  - receives the value, must not be NULL.</para>
        /// <para>Returns True if value found, False otherwise.</para>
        /// </summary>
        public static int FPDFAnnotGetNumberValue(global::PDFiumCore.FpdfAnnotationT annot, string key, ref float value)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (float* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotGetNumberValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the AP (appearance string) in |annot|'s dictionary for a given</para>
        /// <para>|appearanceMode|.</para>
        /// <para>annot          - handle to an annotation.</para>
        /// <para>appearanceMode - the appearance mode (normal, rollover or down) for which</para>
        /// <para>to get the AP.</para>
        /// <para>value          - the string value to be set, encoded in UTF-16LE. If</para>
        /// <para>nullptr is passed, the AP is cleared for that mode. If the</para>
        /// <para>mode is Normal, APs for all modes are cleared.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetAP(global::PDFiumCore.FpdfAnnotationT annot, int appearanceMode, ref ushort value)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotSetAP(__arg0, appearanceMode, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the AP (appearance string) from |annot|'s dictionary for a given</para>
        /// <para>|appearanceMode|.</para>
        /// <para>|buffer| is only modified if |buflen| is large enough to hold the whole AP</para>
        /// <para>string. If |buflen| is smaller, the total size of the AP is still returned,</para>
        /// <para>but nothing is copied.</para>
        /// <para>If there is no appearance stream for |annot| in |appearanceMode|, an empty</para>
        /// <para>string is written to |buf| and 2 is returned.</para>
        /// <para>On other errors, nothing is written to |buffer| and 0 is returned.</para>
        /// <para>annot          - handle to an annotation.</para>
        /// <para>appearanceMode - the appearance mode (normal, rollover or down) for which</para>
        /// <para>to get the AP.</para>
        /// <para>buffer         - buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen         - length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetAP(global::PDFiumCore.FpdfAnnotationT annot, int appearanceMode, ref ushort buffer, uint buflen)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetAP(__arg0, appearanceMode, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation corresponding to |key| in |annot|'s dictionary. Common</para>
        /// <para>keys for linking annotations include &quot;IRT&quot; and &quot;Popup&quot;. Must call</para>
        /// <para>FPDFPage_CloseAnnot() when the annotation returned by this function is no</para>
        /// <para>longer needed.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the requested dictionary entry, encoded in UTF-8.</para>
        /// <para>Returns a handle to the linked annotation object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFAnnotGetLinkedAnnot(global::PDFiumCore.FpdfAnnotationT annot, string key)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetLinkedAnnot(__arg0, key);
            var __result0 = global::PDFiumCore.FpdfAnnotationT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation flags of |annot|.</para>
        /// <para>annot    - handle to an annotation.</para>
        /// <para>Returns the annotation flags.</para>
        /// </summary>
        public static int FPDFAnnotGetFlags(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFlags(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the |annot|'s flags to be of the value |flags|.</para>
        /// <para>annot      - handle to an annotation.</para>
        /// <para>flags      - the flag values to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetFlags(global::PDFiumCore.FpdfAnnotationT annot, int flags)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotSetFlags(__arg0, flags);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation flags of |annot|.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>Returns the annotation flags specific to interactive forms.</para>
        /// </summary>
        public static int FPDFAnnotGetFormFieldFlags(global::PDFiumCore.FpdfFormHandleT handle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormFieldFlags(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Retrieves an interactive form annotation whose rectangle contains a given</para>
        /// <para>point on a page. Must call FPDFPage_CloseAnnot() when the annotation returned</para>
        /// <para>is no longer needed.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   handle to the page, returned by FPDF_LoadPage function.</para>
        /// <para>point       -   position in PDF &quot;user space&quot;.</para>
        /// <para>Returns the interactive form annotation whose rectangle contains the given</para>
        /// <para>coordinates on the page. If there is no such annotation, return NULL.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFAnnotGetFormFieldAtPoint(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_POINTF_ point)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg2 = point is null ? __IntPtr.Zero : point.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormFieldAtPoint(__arg0, __arg1, __arg2);
            var __result0 = global::PDFiumCore.FpdfAnnotationT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the name of |annot|, which is an interactive form annotation.</para>
        /// <para>|buffer| is only modified if |buflen| is longer than the length of contents.</para>
        /// <para>In case of error, nothing will be added to |buffer| and the return value will</para>
        /// <para>be 0. Note that return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>buffer      -   buffer for holding the name string, encoded in UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormFieldName(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref ushort buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetFormFieldName(__arg0, __arg1, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the alternate name of |annot|, which is an interactive form annotation.</para>
        /// <para>|buffer| is only modified if |buflen| is longer than the length of contents.</para>
        /// <para>In case of error, nothing will be added to |buffer| and the return value will</para>
        /// <para>be 0. Note that return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>buffer      -   buffer for holding the alternate name string, encoded in</para>
        /// <para>UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormFieldAlternateName(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref ushort buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetFormFieldAlternateName(__arg0, __arg1, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the form field type of |annot|, which is an interactive form annotation.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>Returns the type of the form field (one of the FPDF_FORMFIELD_* values) on</para>
        /// <para>success. Returns -1 on error.</para>
        /// <para>See field types in fpdf_formfill.h.</para>
        /// </summary>
        public static int FPDFAnnotGetFormFieldType(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormFieldType(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the value of |annot|, which is an interactive form annotation.</para>
        /// <para>|buffer| is only modified if |buflen| is longer than the length of contents.</para>
        /// <para>In case of error, nothing will be added to |buffer| and the return value will</para>
        /// <para>be 0. Note that return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>buffer      -   buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormFieldValue(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref ushort buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetFormFieldValue(__arg0, __arg1, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of options in the |annot|'s &quot;Opt&quot; dictionary. Intended for</para>
        /// <para>use with listbox and combobox widget annotations.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns the number of options in &quot;Opt&quot; dictionary on success. Return value</para>
        /// <para>will be -1 if annotation does not have an &quot;Opt&quot; dictionary or other error.</para>
        /// </summary>
        public static int FPDFAnnotGetOptionCount(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetOptionCount(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the string value for the label of the option at |index| in |annot|'s</para>
        /// <para>&quot;Opt&quot; dictionary. Intended for use with listbox and combobox widget</para>
        /// <para>annotations. |buffer| is only modified if |buflen| is longer than the length</para>
        /// <para>of contents. If index is out of range or in case of other error, nothing</para>
        /// <para>will be added to |buffer| and the return value will be 0. Note that</para>
        /// <para>return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>index   - numeric index of the option in the &quot;Opt&quot; array</para>
        /// <para>buffer  - buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen  - length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// <para>If |annot| does not have an &quot;Opt&quot; array, |index| is out of range or if any</para>
        /// <para>other error occurs, returns 0.</para>
        /// </summary>
        public static uint FPDFAnnotGetOptionLabel(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, int index, ref ushort buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer3 = &buffer)
            {
                var __arg3 = __buffer3;
                var __ret = __Internal.FPDFAnnotGetOptionLabel(__arg0, __arg1, index, __arg3, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Determine whether or not the option at |index| in |annot|'s &quot;Opt&quot; dictionary</para>
        /// <para>is selected. Intended for use with listbox and combobox widget annotations.</para>
        /// <para>handle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>index   - numeric index of the option in the &quot;Opt&quot; array.</para>
        /// <para>Returns true if the option at |index| in |annot|'s &quot;Opt&quot; dictionary is</para>
        /// <para>selected, false otherwise.</para>
        /// </summary>
        public static int FPDFAnnotIsOptionSelected(global::PDFiumCore.FpdfFormHandleT handle, global::PDFiumCore.FpdfAnnotationT annot, int index)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotIsOptionSelected(__arg0, __arg1, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the float value of the font size for an |annot| with variable text.</para>
        /// <para>If 0, the font is to be auto-sized: its size is computed as a function of</para>
        /// <para>the height of the annotation rectangle.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>value   - Required. Float which will be set to font size on success.</para>
        /// <para>Returns true if the font size was set in |value|, false on error or if</para>
        /// <para>|value| not provided.</para>
        /// </summary>
        public static int FPDFAnnotGetFontSize(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref float value)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (float* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotGetFontSize(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Determine if |annot| is a form widget that is checked. Intended for use with</para>
        /// <para>checkbox and radio button widgets.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns true if |annot| is a form widget and is checked, false otherwise.</para>
        /// </summary>
        public static int FPDFAnnotIsChecked(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotIsChecked(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the list of focusable annotation subtypes. Annotations of subtype</para>
        /// <para>FPDF_ANNOT_WIDGET are by default focusable. New subtypes set using this API</para>
        /// <para>will override the existing subtypes.</para>
        /// <para>hHandle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>subtypes - list of annotation subtype which can be tabbed over.</para>
        /// <para>count    - total number of annotation subtype in list.</para>
        /// <para>Returns true if list of annotation subtype is set successfully, false</para>
        /// <para>otherwise.</para>
        /// </summary>
        public static int FPDFAnnotSetFocusableSubtypes(global::PDFiumCore.FpdfFormHandleT hHandle, ref int subtypes, ulong count)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            fixed (int* __subtypes1 = &subtypes)
            {
                var __arg1 = __subtypes1;
                var __ret = __Internal.FPDFAnnotSetFocusableSubtypes(__arg0, __arg1, count);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the count of focusable annotation subtypes as set by host</para>
        /// <para>for a |hHandle|.</para>
        /// <para>hHandle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>Returns the count of focusable annotation subtypes or -1 on error.</para>
        /// <para>Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable.</para>
        /// </summary>
        public static int FPDFAnnotGetFocusableSubtypesCount(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __ret = __Internal.FPDFAnnotGetFocusableSubtypesCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the list of focusable annotation subtype as set by host.</para>
        /// <para>hHandle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>subtypes - receives the list of annotation subtype which can be tabbed</para>
        /// <para>over. Caller must have allocated |subtypes| more than or</para>
        /// <para>equal to the count obtained from</para>
        /// <para>FPDFAnnot_GetFocusableSubtypesCount() API.</para>
        /// <para>count    - size of |subtypes|.</para>
        /// <para>Returns true on success and set list of annotation subtype to |subtypes|,</para>
        /// <para>false otherwise.</para>
        /// <para>Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable.</para>
        /// </summary>
        public static int FPDFAnnotGetFocusableSubtypes(global::PDFiumCore.FpdfFormHandleT hHandle, ref int subtypes, ulong count)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            fixed (int* __subtypes1 = &subtypes)
            {
                var __arg1 = __subtypes1;
                var __ret = __Internal.FPDFAnnotGetFocusableSubtypes(__arg0, __arg1, count);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets FPDF_LINK object for |annot|. Intended to use for link annotations.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns FPDF_LINK from the FPDF_ANNOTATION and NULL on failure,</para>
        /// <para>if the input annot is NULL or input annot's subtype is not link.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfLinkT FPDFAnnotGetLink(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetLink(__arg0);
            var __result0 = global::PDFiumCore.FpdfLinkT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the count of annotations in the |annot|'s control group.</para>
        /// <para>A group of interactive form annotations is collectively called a form</para>
        /// <para>control group. Here, |annot|, an interactive form annotation, should be</para>
        /// <para>either a radio button or a checkbox.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns number of controls in its control group or -1 on error.</para>
        /// </summary>
        public static int FPDFAnnotGetFormControlCount(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormControlCount(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the index of |annot| in |annot|'s control group.</para>
        /// <para>A group of interactive form annotations is collectively called a form</para>
        /// <para>control group. Here, |annot|, an interactive form annotation, should be</para>
        /// <para>either a radio button or a checkbox.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns index of a given |annot| in its control group or -1 on error.</para>
        /// </summary>
        public static int FPDFAnnotGetFormControlIndex(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormControlIndex(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the export value of |annot| which is an interactive form annotation.</para>
        /// <para>Intended for use with radio button and checkbox widget annotations.</para>
        /// <para>|buffer| is only modified if |buflen| is longer than the length of contents.</para>
        /// <para>In case of error, nothing will be added to |buffer| and the return value</para>
        /// <para>will be 0. Note that return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>buffer      -   buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormFieldExportValue(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref ushort buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetFormFieldExportValue(__arg0, __arg1, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add a URI action to |annot|, overwriting the existing action, if any.</para>
        /// <para>annot  - handle to a link annotation.</para>
        /// <para>uri    - the URI to be set, encoded in 7-bit ASCII.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetURI(global::PDFiumCore.FpdfAnnotationT annot, string uri)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotSetURI(__arg0, uri);
            return __ret;
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void TimerCallback(int idEvent);

    public unsafe partial class IPDF_JsPlatform : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr app_alert;
            internal __IntPtr app_beep;
            internal __IntPtr app_response;
            internal __IntPtr Doc_getFilePath;
            internal __IntPtr Doc_mail;
            internal __IntPtr Doc_print;
            internal __IntPtr Doc_submitForm;
            internal __IntPtr Doc_gotoPage;
            internal __IntPtr Field_browse;
            internal __IntPtr m_pFormfillinfo;
            internal __IntPtr m_isolate;
            internal uint m_v8EmbedderSlot;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_IPDF_JsPlatform@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IPDF_JsPlatform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IPDF_JsPlatform>();

        protected bool __ownsNativeInstance;

        internal static IPDF_JsPlatform __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new IPDF_JsPlatform(native.ToPointer(), skipVTables);
        }

        internal static IPDF_JsPlatform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (IPDF_JsPlatform)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static IPDF_JsPlatform __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IPDF_JsPlatform(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IPDF_JsPlatform(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IPDF_JsPlatform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public IPDF_JsPlatform()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IPDF_JsPlatform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public IPDF_JsPlatform(global::PDFiumCore.IPDF_JsPlatform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IPDF_JsPlatform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance) = *((global::PDFiumCore.IPDF_JsPlatform.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_int_int AppAlert
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->app_alert;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_int_int));
            }

            set
            {
                ((__Internal*)__Instance)->app_alert = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_int AppBeep
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->app_beep;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->app_beep = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int___IntPtr_int AppResponse
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->app_response;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->app_response = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int Doc_getFilePath
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Doc_getFilePath;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->Doc_getFilePath = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr Doc_mail
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Doc_mail;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Doc_mail = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_int_int_int_int_int_int_int_int Doc_print
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Doc_print;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_int_int_int_int_int_int_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_int_int_int_int_int_int_int_int));
            }

            set
            {
                ((__Internal*)__Instance)->Doc_print = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_ushortPtr Doc_submitForm
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Doc_submitForm;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_ushortPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Doc_submitForm = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_int Doc_gotoPage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Doc_gotoPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->Doc_gotoPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int Field_browse
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Field_browse;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->Field_browse = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr MPFormfillinfo
        {
            get
            {
                return ((__Internal*)__Instance)->m_pFormfillinfo;
            }

            set
            {
                ((__Internal*)__Instance)->m_pFormfillinfo = (__IntPtr) value;
            }
        }

        public __IntPtr MIsolate
        {
            get
            {
                return ((__Internal*)__Instance)->m_isolate;
            }

            set
            {
                ((__Internal*)__Instance)->m_isolate = (__IntPtr) value;
            }
        }

        public uint MV8EmbedderSlot
        {
            get
            {
                return ((__Internal*)__Instance)->m_v8EmbedderSlot;
            }

            set
            {
                ((__Internal*)__Instance)->m_v8EmbedderSlot = value;
            }
        }
    }

    public unsafe partial class FPDF_SYSTEMTIME : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort wYear;
            internal ushort wMonth;
            internal ushort wDayOfWeek;
            internal ushort wDay;
            internal ushort wHour;
            internal ushort wMinute;
            internal ushort wSecond;
            internal ushort wMilliseconds;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FPDF_SYSTEMTIME@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSTEMTIME> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSTEMTIME>();

        protected bool __ownsNativeInstance;

        internal static FPDF_SYSTEMTIME __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_SYSTEMTIME(native.ToPointer(), skipVTables);
        }

        internal static FPDF_SYSTEMTIME __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_SYSTEMTIME)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_SYSTEMTIME __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_SYSTEMTIME(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_SYSTEMTIME(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_SYSTEMTIME(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_SYSTEMTIME()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_SYSTEMTIME(global::PDFiumCore.FPDF_SYSTEMTIME _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort WYear
        {
            get
            {
                return ((__Internal*)__Instance)->wYear;
            }

            set
            {
                ((__Internal*)__Instance)->wYear = value;
            }
        }

        public ushort WMonth
        {
            get
            {
                return ((__Internal*)__Instance)->wMonth;
            }

            set
            {
                ((__Internal*)__Instance)->wMonth = value;
            }
        }

        public ushort WDayOfWeek
        {
            get
            {
                return ((__Internal*)__Instance)->wDayOfWeek;
            }

            set
            {
                ((__Internal*)__Instance)->wDayOfWeek = value;
            }
        }

        public ushort WDay
        {
            get
            {
                return ((__Internal*)__Instance)->wDay;
            }

            set
            {
                ((__Internal*)__Instance)->wDay = value;
            }
        }

        public ushort WHour
        {
            get
            {
                return ((__Internal*)__Instance)->wHour;
            }

            set
            {
                ((__Internal*)__Instance)->wHour = value;
            }
        }

        public ushort WMinute
        {
            get
            {
                return ((__Internal*)__Instance)->wMinute;
            }

            set
            {
                ((__Internal*)__Instance)->wMinute = value;
            }
        }

        public ushort WSecond
        {
            get
            {
                return ((__Internal*)__Instance)->wSecond;
            }

            set
            {
                ((__Internal*)__Instance)->wSecond = value;
            }
        }

        public ushort WMilliseconds
        {
            get
            {
                return ((__Internal*)__Instance)->wMilliseconds;
            }

            set
            {
                ((__Internal*)__Instance)->wMilliseconds = value;
            }
        }
    }

    public unsafe partial class FPDF_FORMFILLINFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 280)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr Release;
            internal __IntPtr FFI_Invalidate;
            internal __IntPtr FFI_OutputSelectedRect;
            internal __IntPtr FFI_SetCursor;
            internal __IntPtr FFI_SetTimer;
            internal __IntPtr FFI_KillTimer;
            internal __IntPtr FFI_GetLocalTime;
            internal __IntPtr FFI_OnChange;
            internal __IntPtr FFI_GetPage;
            internal __IntPtr FFI_GetCurrentPage;
            internal __IntPtr FFI_GetRotation;
            internal __IntPtr FFI_ExecuteNamedAction;
            internal __IntPtr FFI_SetTextFieldFocus;
            internal __IntPtr FFI_DoURIAction;
            internal __IntPtr FFI_DoGoToAction;
            internal __IntPtr m_pJsPlatform;
            internal int xfa_disabled;
            internal __IntPtr FFI_DisplayCaret;
            internal __IntPtr FFI_GetCurrentPageIndex;
            internal __IntPtr FFI_SetCurrentPage;
            internal __IntPtr FFI_GotoURL;
            internal __IntPtr FFI_GetPageViewRect;
            internal __IntPtr FFI_PageEvent;
            internal __IntPtr FFI_PopupMenu;
            internal __IntPtr FFI_OpenFile;
            internal __IntPtr FFI_EmailTo;
            internal __IntPtr FFI_UploadTo;
            internal __IntPtr FFI_GetPlatform;
            internal __IntPtr FFI_GetLanguage;
            internal __IntPtr FFI_DownloadFromURL;
            internal __IntPtr FFI_PostRequestURL;
            internal __IntPtr FFI_PutRequestURL;
            internal __IntPtr FFI_OnFocusChange;
            internal __IntPtr FFI_DoURIActionWithKeyboardModifier;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FPDF_FORMFILLINFO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FORMFILLINFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FORMFILLINFO>();

        protected bool __ownsNativeInstance;

        internal static FPDF_FORMFILLINFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_FORMFILLINFO(native.ToPointer(), skipVTables);
        }

        internal static FPDF_FORMFILLINFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_FORMFILLINFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_FORMFILLINFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_FORMFILLINFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FORMFILLINFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FORMFILLINFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_FORMFILLINFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            global::System.Runtime.CompilerServices.Unsafe.InitBlock((void*)__Instance, 0, (uint)sizeof(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal));
        }

        public FPDF_FORMFILLINFO(global::PDFiumCore.FPDF_FORMFILLINFO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr Release
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Release;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Release = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_double_double_double_double FFI_Invalidate
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_Invalidate;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_double_double_double_double) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_double_double_double_double));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_Invalidate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_double_double_double_double FFI_OutputSelectedRect
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_OutputSelectedRect;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_double_double_double_double) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_double_double_double_double));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_OutputSelectedRect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_int FFI_SetCursor
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_SetCursor;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_SetCursor = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_int_PDFiumCore_TimerCallback FFI_SetTimer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_SetTimer;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_int_PDFiumCore_TimerCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_int_PDFiumCore_TimerCallback));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_SetTimer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_int FFI_KillTimer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_KillTimer;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_KillTimer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_PDFiumCore__FPDF_SYSTEMTIME___Internal___IntPtr FFI_GetLocalTime
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetLocalTime;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_PDFiumCore__FPDF_SYSTEMTIME___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_PDFiumCore__FPDF_SYSTEMTIME___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetLocalTime = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr FFI_OnChange
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_OnChange;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_OnChange = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func___IntPtr___IntPtr___IntPtr_int FFI_GetPage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func___IntPtr___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func___IntPtr___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func___IntPtr___IntPtr___IntPtr FFI_GetCurrentPage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetCurrentPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func___IntPtr___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetCurrentPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr FFI_GetRotation
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetRotation;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetRotation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_string8 FFI_ExecuteNamedAction
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_ExecuteNamedAction;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_ExecuteNamedAction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_ushortPtr_uint_int FFI_SetTextFieldFocus
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_SetTextFieldFocus;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_ushortPtr_uint_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_ushortPtr_uint_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_SetTextFieldFocus = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_string8 FFI_DoURIAction
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_DoURIAction;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_DoURIAction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_int_int_floatPtr_int FFI_DoGoToAction
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_DoGoToAction;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_int_int_floatPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_int_int_floatPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_DoGoToAction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.IPDF_JsPlatform MPJsPlatform
        {
            get
            {
                var __result0 = global::PDFiumCore.IPDF_JsPlatform.__GetOrCreateInstance(((__Internal*)__Instance)->m_pJsPlatform, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->m_pJsPlatform = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int XfaDisabled
        {
            get
            {
                return ((__Internal*)__Instance)->xfa_disabled;
            }

            set
            {
                ((__Internal*)__Instance)->xfa_disabled = value;
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_double_double_double_double FFI_DisplayCaret
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_DisplayCaret;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_double_double_double_double) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_double_double_double_double));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_DisplayCaret = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr FFI_GetCurrentPageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetCurrentPageIndex;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetCurrentPageIndex = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int FFI_SetCurrentPage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_SetCurrentPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_SetCurrentPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_ushortPtr FFI_GotoURL
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GotoURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_ushortPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GotoURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_doublePtr_doublePtr_doublePtr_doublePtr FFI_GetPageViewRect
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetPageViewRect;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_doublePtr_doublePtr_doublePtr_doublePtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_doublePtr_doublePtr_doublePtr_doublePtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetPageViewRect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_int_uint FFI_PageEvent
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_PageEvent;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_int_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_int_uint));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_PageEvent = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr___IntPtr_int_float_float FFI_PopupMenu
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_PopupMenu;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr___IntPtr_int_float_float) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr___IntPtr_int_float_float));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_PopupMenu = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_int_ushortPtr_string8 FFI_OpenFile
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_OpenFile;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_int_ushortPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_int_ushortPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_OpenFile = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr FFI_EmailTo
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_EmailTo;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_EmailTo = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_ushortPtr FFI_UploadTo
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_UploadTo;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int_ushortPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_UploadTo = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int FFI_GetPlatform
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetPlatform;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetPlatform = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int FFI_GetLanguage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_GetLanguage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_GetLanguage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_ushortPtr FFI_DownloadFromURL
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_DownloadFromURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_ushortPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_DownloadFromURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr___IntPtr FFI_PostRequestURL
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_PostRequestURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_PostRequestURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr FFI_PutRequestURL
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_PutRequestURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_PutRequestURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int FFI_OnFocusChange
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_OnFocusChange;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_OnFocusChange = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>Method: FFI_DoURIActionWithKeyboardModifier</para>
        /// <para>Ask the implementation to navigate to a uniform resource identifier</para>
        /// <para>with the specified modifiers.</para>
        /// <para>Interface Version:</para>
        /// <para>Ignored if |version|&lt;2.</para>
        /// <para>Implementation Required:</para>
        /// <para>No</para>
        /// <para>Parameters:</para>
        /// <para>param           -   Pointer to the interface structure itself.</para>
        /// <para>uri             -   A byte string which indicates the uniform</para>
        /// <para>resource identifier, terminated by 0.</para>
        /// <para>modifiers       -   Keyboard modifier that indicates which of</para>
        /// <para>the virtual keys are down, if any.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments:</para>
        /// <para>If the embedder who is version 2 and does not implement this API,</para>
        /// <para>then a call will be redirected to FFI_DoURIAction.</para>
        /// <para>See the URI actions description of&lt;Reference, version 1.7&gt;&gt;</para>
        /// <para>for more details.</para>
        /// </summary>
        public global::PDFiumCore.Delegates.Action___IntPtr_string8_int FFI_DoURIActionWithKeyboardModifier
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FFI_DoURIActionWithKeyboardModifier;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_string8_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_string8_int));
            }

            set
            {
                ((__Internal*)__Instance)->FFI_DoURIActionWithKeyboardModifier = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class fpdf_formfill
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDOC_InitFormFillEnvironment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFDOC_InitFormFillEnvironment(__IntPtr document, __IntPtr formInfo);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDOC_ExitFormFillEnvironment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFDOC_ExitFormFillEnvironment(__IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnAfterLoadPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_OnAfterLoadPage(__IntPtr page, __IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnBeforeClosePage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_OnBeforeClosePage(__IntPtr page, __IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_DoDocumentJSAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_DoDocumentJSAction(__IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_DoDocumentOpenAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_DoDocumentOpenAction(__IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_DoDocumentAAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_DoDocumentAAction(__IntPtr hHandle, int aaType);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_DoPageAAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_DoPageAAction(__IntPtr page, __IntPtr hHandle, int aaType);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnMouseMove", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnMouseMove(__IntPtr hHandle, __IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnMouseWheel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnMouseWheel(__IntPtr hHandle, __IntPtr page, int modifier, __IntPtr page_coord, int delta_x, int delta_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnFocus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnFocus(__IntPtr hHandle, __IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnLButtonDown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnLButtonDown(__IntPtr hHandle, __IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnRButtonDown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnRButtonDown(__IntPtr hHandle, __IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnLButtonUp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnLButtonUp(__IntPtr hHandle, __IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnRButtonUp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnRButtonUp(__IntPtr hHandle, __IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnLButtonDoubleClick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnLButtonDoubleClick(__IntPtr hHandle, __IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnKeyDown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnKeyDown(__IntPtr hHandle, __IntPtr page, int nKeyCode, int modifier);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnKeyUp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnKeyUp(__IntPtr hHandle, __IntPtr page, int nKeyCode, int modifier);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_OnChar", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_OnChar(__IntPtr hHandle, __IntPtr page, int nChar, int modifier);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_GetFocusedText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FORM_GetFocusedText(__IntPtr hHandle, __IntPtr page, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_GetSelectedText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FORM_GetSelectedText(__IntPtr hHandle, __IntPtr page, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_ReplaceAndKeepSelection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_ReplaceAndKeepSelection(__IntPtr hHandle, __IntPtr page, ushort* wsText);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_ReplaceSelection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FORM_ReplaceSelection(__IntPtr hHandle, __IntPtr page, ushort* wsText);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_SelectAllText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_SelectAllText(__IntPtr hHandle, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_CanUndo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_CanUndo(__IntPtr hHandle, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_CanRedo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_CanRedo(__IntPtr hHandle, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_Undo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_Undo(__IntPtr hHandle, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_Redo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_Redo(__IntPtr hHandle, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_ForceToKillFocus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_ForceToKillFocus(__IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_GetFocusedAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_GetFocusedAnnot(__IntPtr handle, int* page_index, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_SetFocusedAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_SetFocusedAnnot(__IntPtr handle, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_HasFormFieldAtPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageHasFormFieldAtPoint(__IntPtr hHandle, __IntPtr page, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_FormFieldZOrderAtPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageFormFieldZOrderAtPoint(__IntPtr hHandle, __IntPtr page, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_SetFormFieldHighlightColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_SetFormFieldHighlightColor(__IntPtr hHandle, int fieldType, uint color);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_SetFormFieldHighlightAlpha", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_SetFormFieldHighlightAlpha(__IntPtr hHandle, byte alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_RemoveFormFieldHighlight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_RemoveFormFieldHighlight(__IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_FFLDraw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_FFLDraw(__IntPtr hHandle, __IntPtr bitmap, __IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetFormType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetFormType(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_SetIndexSelected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_SetIndexSelected(__IntPtr hHandle, __IntPtr page, int index, int selected);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FORM_IsIndexSelected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FORM_IsIndexSelected(__IntPtr hHandle, __IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_LoadXFA", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_LoadXFA(__IntPtr document);
        }

        /// <summary>
        /// <para>Function: FPDFDOC_InitFormFillEnvironment</para>
        /// <para>Initialize form fill environment.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to document from FPDF_LoadDocument().</para>
        /// <para>formInfo        -   Pointer to a FPDF_FORMFILLINFO structure.</para>
        /// <para>Return Value:</para>
        /// <para>Handle to the form fill module, or NULL on failure.</para>
        /// <para>Comments: This function should be called before any form fill operation. The FPDF_FORMFILLINFO passed in via |formInfo| must remain valid until the returned FPDF_FORMHANDLE is closed.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfFormHandleT FPDFDOC_InitFormFillEnvironment(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FORMFILLINFO formInfo)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = formInfo is null ? __IntPtr.Zero : formInfo.__Instance;
            var __ret = __Internal.FPDFDOC_InitFormFillEnvironment(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfFormHandleT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFDOC_ExitFormFillEnvironment</para>
        /// <para>Take ownership of |hHandle| and exit form fill environment.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function is a no-op when |hHandle| is null.</para>
        /// </summary>
        public static void FPDFDOC_ExitFormFillEnvironment(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDFDOC_ExitFormFillEnvironment(__arg0);
        }

        /// <summary>
        /// <para>Function: FORM_OnAfterLoadPage</para>
        /// <para>This method is required for implementing all the form related</para>
        /// <para>functions. Should be invoked after user successfully loaded a</para>
        /// <para>PDF page, and FPDFDOC_InitFormFillEnvironment() has been invoked.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FORM_OnAfterLoadPage(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_OnAfterLoadPage(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Function: FORM_OnBeforeClosePage</para>
        /// <para>This method is required for implementing all the form related</para>
        /// <para>functions. Should be invoked before user closes the PDF page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FORM_OnBeforeClosePage(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_OnBeforeClosePage(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Function: FORM_DoDocumentJSAction</para>
        /// <para>This method is required for performing document-level JavaScript</para>
        /// <para>actions. It should be invoked after the PDF document has been loaded.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: If there is document-level JavaScript action embedded in the document, this method will execute the JavaScript action. Otherwise, the method will do nothing.</para>
        /// </summary>
        public static void FORM_DoDocumentJSAction(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoDocumentJSAction(__arg0);
        }

        /// <summary>
        /// <para>Function: FORM_DoDocumentOpenAction</para>
        /// <para>This method is required for performing open-action when the document</para>
        /// <para>is opened.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This method will do nothing if there are no open-actions embedded in the document.</para>
        /// </summary>
        public static void FORM_DoDocumentOpenAction(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoDocumentOpenAction(__arg0);
        }

        /// <summary>
        /// <para>Function: FORM_DoDocumentAAction</para>
        /// <para>This method is required for performing the document's</para>
        /// <para>additional-action.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>aaType      -   The type of the additional-actions which defined above.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This method will do nothing if there is no document additional-action corresponding to the specified |aaType|.</para>
        /// </summary>
        public static void FORM_DoDocumentAAction(global::PDFiumCore.FpdfFormHandleT hHandle, int aaType)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoDocumentAAction(__arg0, aaType);
        }

        /// <summary>
        /// <para>Function: FORM_DoPageAAction</para>
        /// <para>This method is required for performing the page object's</para>
        /// <para>additional-action when opened or closed.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>aaType      -   The type of the page object's additional-actions which defined above.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This method will do nothing if no additional-action corresponding to the specified |aaType| exists.</para>
        /// </summary>
        public static void FORM_DoPageAAction(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfFormHandleT hHandle, int aaType)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoPageAAction(__arg0, __arg1, aaType);
        }

        /// <summary>
        /// <para>Function: FORM_OnMouseMove</para>
        /// <para>Call this member function when the mouse cursor moves.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnMouseMove(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnMouseMove(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_OnMouseWheel</para>
        /// <para>Call this member function when the user scrolls the mouse wheel.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_coord  -   Specifies the coordinates of the cursor in PDF user space.</para>
        /// <para>delta_x     -   Specifies the amount of wheel movement on the x-axis, in units of platform-agnostic wheel deltas. Negative values mean left.</para>
        /// <para>delta_y     -   Specifies the amount of wheel movement on the y-axis, in units of platform-agnostic wheel deltas. Negative values mean down.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// <para>Comments: For |delta_x| and |delta_y|, the caller must normalize platform-specific wheel deltas. e.g. On Windows, a delta value of 240 for a WM_MOUSEWHEEL event normalizes to 2, since Windows defines WHEEL_DELTA as 120.</para>
        /// </summary>
        public static int FORM_OnMouseWheel(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, global::PDFiumCore.FS_POINTF_ page_coord, int delta_x, int delta_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg3 = page_coord is null ? __IntPtr.Zero : page_coord.__Instance;
            var __ret = __Internal.FORM_OnMouseWheel(__arg0, __arg1, modifier, __arg3, delta_x, delta_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnFocus</para>
        /// <para>This function focuses the form annotation at a given point. If the</para>
        /// <para>annotation at the point already has focus, nothing happens. If there</para>
        /// <para>is no annotation at the point, removes form focus.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True if there is an annotation at the given point and it has focus.</para>
        /// </summary>
        public static int FORM_OnFocus(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnFocus(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnLButtonDown</para>
        /// <para>Call this member function when the user presses the left</para>
        /// <para>mouse button.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnLButtonDown(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnLButtonDown(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnRButtonDown</para>
        /// <para>Same as above, execpt for the right mouse button.</para>
        /// <para>Comments: At the present time, has no effect except in XFA builds, but is included for the sake of symmetry.</para>
        /// </summary>
        public static int FORM_OnRButtonDown(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnRButtonDown(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnRButtonDown</para>
        /// <para>Same as above, execpt for the right mouse button.</para>
        /// <para>Comments: At the present time, has no effect except in XFA builds, but is included for the sake of symmetry.</para>
        /// <para></para>
        /// <para>FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FORM_OnRButtonDown(FPDF_FORMHANDLE hHandle, FPDF_PAGE page, int modifier, double page_x, double page_y);</para>
        /// <para></para>
        /// <para>Function: FORM_OnLButtonUp Call this member function when the user releases the left mouse button.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in device.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in device.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnLButtonUp(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnLButtonUp(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnRButtonUp</para>
        /// <para>Same as above, execpt for the right mouse button.</para>
        /// <para>Comments: At the present time, has no effect except in XFA builds, but is included for the sake of symmetry.</para>
        /// </summary>
        public static int FORM_OnRButtonUp(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnRButtonUp(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnLButtonDoubleClick</para>
        /// <para>Call this member function when the user double clicks the</para>
        /// <para>left mouse button.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnLButtonDoubleClick(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnLButtonDoubleClick(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnKeyDown</para>
        /// <para>Call this member function when a nonsystem key is pressed.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, aseturned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>nKeyCode    -   The virtual-key code of the given key (see fpdf_fwlevent.h for virtual key codes).</para>
        /// <para>modifier    -   Mask of key flags (see fpdf_fwlevent.h for key flag values).</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnKeyDown(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int nKeyCode, int modifier)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnKeyDown(__arg0, __arg1, nKeyCode, modifier);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnKeyUp</para>
        /// <para>Call this member function when a nonsystem key is released.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>nKeyCode    -   The virtual-key code of the given key (see fpdf_fwlevent.h for virtual key codes).</para>
        /// <para>modifier    -   Mask of key flags (see fpdf_fwlevent.h for key flag values).</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// <para>Comments: Currently unimplemented and always returns false. PDFium reserves this API and may implement it in the future on an as-needed basis.</para>
        /// </summary>
        public static int FORM_OnKeyUp(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int nKeyCode, int modifier)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnKeyUp(__arg0, __arg1, nKeyCode, modifier);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnChar</para>
        /// <para>Call this member function when a keystroke translates to a</para>
        /// <para>nonsystem character.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>nChar       -   The character code value itself.</para>
        /// <para>modifier    -   Mask of key flags (see fpdf_fwlevent.h for key flag values).</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnChar(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int nChar, int modifier)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnChar(__arg0, __arg1, nChar, modifier);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_GetFocusedText</para>
        /// <para>Call this function to obtain the text within the current focused</para>
        /// <para>field, if any.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>buffer      -   Buffer for holding the form text, encoded in UTF-16LE. If NULL, |buffer| is not modified.</para>
        /// <para>buflen      -   Length of |buffer| in bytes. If |buflen| is less than the length of the form text string, |buffer| is not modified.</para>
        /// <para>Return Value:</para>
        /// <para>Length in bytes for the text in the focused field.</para>
        /// </summary>
        public static uint FORM_GetFocusedText(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, __IntPtr buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_GetFocusedText(__arg0, __arg1, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_GetSelectedText</para>
        /// <para>Call this function to obtain selected text within a form text</para>
        /// <para>field or form combobox text field.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>buffer      -   Buffer for holding the selected text, encoded in UTF-16LE. If NULL, |buffer| is not modified.</para>
        /// <para>buflen      -   Length of |buffer| in bytes. If |buflen| is less than the length of the selected text string, |buffer| is not modified.</para>
        /// <para>Return Value:</para>
        /// <para>Length in bytes of selected text in form text field or form combobox</para>
        /// <para>text field.</para>
        /// </summary>
        public static uint FORM_GetSelectedText(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, __IntPtr buffer, uint buflen)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_GetSelectedText(__arg0, __arg1, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_ReplaceAndKeepSelection</para>
        /// <para>Call this function to replace the selected text in a form</para>
        /// <para>text field or user-editable form combobox text field with another</para>
        /// <para>text string (which can be empty or non-empty). If there is no</para>
        /// <para>selected text, this function will append the replacement text after</para>
        /// <para>the current caret position. After the insertion, the inserted text</para>
        /// <para>will be selected.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as Returned by FPDF_LoadPage().</para>
        /// <para>wsText      -   The text to be inserted, in UTF-16LE format.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FORM_ReplaceAndKeepSelection(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, ref ushort wsText)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (ushort* __wsText2 = &wsText)
            {
                var __arg2 = __wsText2;
                __Internal.FORM_ReplaceAndKeepSelection(__arg0, __arg1, __arg2);
            }
        }

        /// <summary>
        /// <para>Function: FORM_ReplaceSelection</para>
        /// <para>Call this function to replace the selected text in a form</para>
        /// <para>text field or user-editable form combobox text field with another</para>
        /// <para>text string (which can be empty or non-empty). If there is no</para>
        /// <para>selected text, this function will append the replacement text after</para>
        /// <para>the current caret position. After the insertion, the selection range</para>
        /// <para>will be set to empty.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as Returned by FPDF_LoadPage().</para>
        /// <para>wsText      -   The text to be inserted, in UTF-16LE format.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FORM_ReplaceSelection(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, ref ushort wsText)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (ushort* __wsText2 = &wsText)
            {
                var __arg2 = __wsText2;
                __Internal.FORM_ReplaceSelection(__arg0, __arg1, __arg2);
            }
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_SelectAllText</para>
        /// <para>Call this function to select all the text within the currently focused</para>
        /// <para>form text field or form combobox text field.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>Whether the operation succeeded or not.</para>
        /// </summary>
        public static int FORM_SelectAllText(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_SelectAllText(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_CanUndo</para>
        /// <para>Find out if it is possible for the current focused widget in a given</para>
        /// <para>form to perform an undo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if it is possible to undo.</para>
        /// </summary>
        public static int FORM_CanUndo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_CanUndo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_CanRedo</para>
        /// <para>Find out if it is possible for the current focused widget in a given</para>
        /// <para>form to perform a redo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if it is possible to redo.</para>
        /// </summary>
        public static int FORM_CanRedo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_CanRedo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_Undo</para>
        /// <para>Make the current focussed widget perform an undo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if the undo operation succeeded.</para>
        /// </summary>
        public static int FORM_Undo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_Undo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_Redo</para>
        /// <para>Make the current focussed widget perform a redo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if the redo operation succeeded.</para>
        /// </summary>
        public static int FORM_Redo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_Redo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_ForceToKillFocus.</para>
        /// <para>Call this member function to force to kill the focus of the form</para>
        /// <para>field which has focus. If it would kill the focus of a form field,</para>
        /// <para>save the value of form field if was changed by theuser.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_ForceToKillFocus(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __ret = __Internal.FORM_ForceToKillFocus(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Function: FORM_GetFocusedAnnot.</para>
        /// <para>Call this member function to get the currently focused annotation.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page_index  -   Buffer to hold the index number of the page which contains the focused annotation. 0 for the first page. Can't be NULL.</para>
        /// <para>annot       -   Buffer to hold the focused annotation. Can't be NULL.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// <para>Comments: Not currently supported for XFA forms - will report no focused annotation. Must call FPDFPage_CloseAnnot() when the annotation returned in |annot| by this function is no longer needed. This will return true and set |page_index| to -1 and |annot| to NULL, if there is no focused annotation.</para>
        /// </summary>
        public static int FORM_GetFocusedAnnot(global::PDFiumCore.FpdfFormHandleT handle, ref int page_index, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            fixed (int* __page_index1 = &page_index)
            {
                var __arg1 = __page_index1;
                var ____arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
                var __arg2 = new __IntPtr(&____arg2);
                var __ret = __Internal.FORM_GetFocusedAnnot(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Function: FORM_SetFocusedAnnot.</para>
        /// <para>Call this member function to set the currently focused annotation.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   Handle to an annotation.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// <para>Comments: |annot| can't be NULL. To kill focus, use FORM_ForceToKillFocus() instead.</para>
        /// </summary>
        public static int FORM_SetFocusedAnnot(global::PDFiumCore.FpdfFormHandleT handle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FORM_SetFocusedAnnot(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFPage_HasFormFieldAtPoint</para>
        /// <para>Get the form field type by point.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>page_x      -   X position in PDF &quot;user space&quot;.</para>
        /// <para>page_y      -   Y position in PDF &quot;user space&quot;.</para>
        /// <para>Return Value:</para>
        /// <para>Return the type of the form field; -1 indicates no field.</para>
        /// <para>See field types above.</para>
        /// </summary>
        public static int FPDFPageHasFormFieldAtPoint(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageHasFormFieldAtPoint(__arg0, __arg1, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFPage_FormFieldZOrderAtPoint</para>
        /// <para>Get the form field z-order by point.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>page_x      -   X position in PDF &quot;user space&quot;.</para>
        /// <para>page_y      -   Y position in PDF &quot;user space&quot;.</para>
        /// <para>Return Value:</para>
        /// <para>Return the z-order of the form field; -1 indicates no field.</para>
        /// <para>Higher numbers are closer to the front.</para>
        /// </summary>
        public static int FPDFPageFormFieldZOrderAtPoint(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, double page_x, double page_y)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageFormFieldZOrderAtPoint(__arg0, __arg1, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_SetFormFieldHighlightColor</para>
        /// <para>Set the highlight color of the specified (or all) form fields</para>
        /// <para>in the document.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>doc         -   Handle to the document, as returned by FPDF_LoadDocument().</para>
        /// <para>fieldType   -   A 32-bit integer indicating the type of a form field (defined above).</para>
        /// <para>color       -   The highlight color of the form field. Constructed by 0xxxrrggbb.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: When the parameter fieldType is set to FPDF_FORMFIELD_UNKNOWN, the highlight color will be applied to all the form fields in the document. Please refresh the client window to show the highlight immediately if necessary.</para>
        /// </summary>
        public static void FPDF_SetFormFieldHighlightColor(global::PDFiumCore.FpdfFormHandleT hHandle, int fieldType, uint color)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDF_SetFormFieldHighlightColor(__arg0, fieldType, color);
        }

        /// <summary>
        /// <para>Function: FPDF_SetFormFieldHighlightAlpha</para>
        /// <para>Set the transparency of the form field highlight color in the</para>
        /// <para>document.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>doc         -   Handle to the document, as returaned by FPDF_LoadDocument().</para>
        /// <para>alpha       -   The transparency of the form field highlight color, between 0-255.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_SetFormFieldHighlightAlpha(global::PDFiumCore.FpdfFormHandleT hHandle, byte alpha)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDF_SetFormFieldHighlightAlpha(__arg0, alpha);
        }

        /// <summary>
        /// <para>Function: FPDF_RemoveFormFieldHighlight</para>
        /// <para>Remove the form field highlight color in the document.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: Please refresh the client window to remove the highlight immediately if necessary.</para>
        /// </summary>
        public static void FPDF_RemoveFormFieldHighlight(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDF_RemoveFormFieldHighlight(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_FFLDraw</para>
        /// <para>Render FormFields and popup window on a page to a device independent</para>
        /// <para>bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle      -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>bitmap       -   Handle to the device independent bitmap (as the output buffer). Bitmap handles can be created by FPDFBitmap_Create().</para>
        /// <para>page         -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>start_x      -   Left pixel position of the display area in the device coordinates.</para>
        /// <para>start_y      -   Top pixel position of the display area in the device coordinates.</para>
        /// <para>size_x       -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y       -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate       -   Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</para>
        /// <para>flags        -   0 for normal display, or combination of flags defined above.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function is designed to render annotations that are user-interactive, which are widget annotations (for FormFields) and popup annotations. With the FPDF_ANNOT flag, this function will render a popup annotation when users mouse-hover on a non-widget annotation. Regardless of FPDF_ANNOT flag, this function will always render widget annotations for FormFields. In order to implement the FormFill functions, implementation should call this function after rendering functions, such as FPDF_RenderPageBitmap() or FPDF_RenderPageBitmap_Start(), have finished rendering the page contents.</para>
        /// </summary>
        public static void FPDF_FFLDraw(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __arg2 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDF_FFLDraw(__arg0, __arg1, __arg2, start_x, start_y, size_x, size_y, rotate, flags);
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FPDF_GetFormType</para>
        /// <para>Returns the type of form contained in the PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>document - Handle to document.</para>
        /// <para>Return Value:</para>
        /// <para>Integer value representing one of the FORMTYPE_ values.</para>
        /// <para>Comments: If |document| is NULL, then the return value is FORMTYPE_NONE.</para>
        /// </summary>
        public static int FPDF_GetFormType(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetFormType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_SetIndexSelected</para>
        /// <para>Selects/deselects the value at the given |index| of the focused</para>
        /// <para>annotation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage</para>
        /// <para>index       -   0-based index of value to be set as selected/unselected</para>
        /// <para>selected    -   true to select, false to deselect</para>
        /// <para>Return Value:</para>
        /// <para>TRUE if the operation succeeded.</para>
        /// <para>FALSE if the operation failed or widget is not a supported type.</para>
        /// <para>Comments: Intended for use with listbox/combobox widget types. Comboboxes have at most a single value selected at a time which cannot be deselected. Deselect on a combobox is a no-op that returns false. Default implementation is a no-op that will return false for other types. Not currently supported for XFA forms - will return false.</para>
        /// </summary>
        public static int FORM_SetIndexSelected(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int index, int selected)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_SetIndexSelected(__arg0, __arg1, index, selected);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_IsIndexSelected</para>
        /// <para>Returns whether or not the value at |index| of the focused</para>
        /// <para>annotation is currently selected.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage</para>
        /// <para>index       -   0-based Index of value to check</para>
        /// <para>Return Value:</para>
        /// <para>TRUE if value at |index| is currently selected.</para>
        /// <para>FALSE if value at |index| is not selected or widget is not a</para>
        /// <para>supported type.</para>
        /// <para>Comments: Intended for use with listbox/combobox widget types. Default implementation is a no-op that will return false for other types. Not currently supported for XFA forms - will return false.</para>
        /// </summary>
        public static int FORM_IsIndexSelected(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = hHandle is null ? __IntPtr.Zero : hHandle.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_IsIndexSelected(__arg0, __arg1, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadXFA</para>
        /// <para>If the document consists of XFA fields, call this method to</para>
        /// <para>attempt to load XFA fields.</para>
        /// <para>Parameters:</para>
        /// <para>document     -   Handle to document from FPDF_LoadDocument().</para>
        /// <para>Return Value:</para>
        /// <para>TRUE upon success, otherwise FALSE. If XFA support is not built</para>
        /// <para>into PDFium, performs no action and always returns FALSE.</para>
        /// </summary>
        public static int FPDF_LoadXFA(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_LoadXFA(__arg0);
            return __ret;
        }
    }

    public unsafe partial class fpdf_attachment
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDoc_GetAttachmentCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFDocGetAttachmentCount(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDoc_AddAttachment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFDocAddAttachment(__IntPtr document, ushort* name);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDoc_GetAttachment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFDocGetAttachment(__IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDoc_DeleteAttachment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFDocDeleteAttachment(__IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAttachment_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAttachmentGetName(__IntPtr attachment, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAttachment_HasKey", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAttachmentHasKey(__IntPtr attachment, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAttachment_GetValueType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAttachmentGetValueType(__IntPtr attachment, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAttachment_SetStringValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAttachmentSetStringValue(__IntPtr attachment, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, ushort* value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAttachment_GetStringValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFAttachmentGetStringValue(__IntPtr attachment, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAttachment_SetFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAttachmentSetFile(__IntPtr attachment, __IntPtr document, __IntPtr contents, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAttachment_GetFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAttachmentGetFile(__IntPtr attachment, __IntPtr buffer, uint buflen, uint* out_buflen);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of embedded files in |document|.</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns the number of embedded files in |document|.</para>
        /// </summary>
        public static int FPDFDocGetAttachmentCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetAttachmentCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add an embedded file with |name| in |document|. If |name| is empty, or if</para>
        /// <para>|name| is the name of a existing embedded file in |document|, or if</para>
        /// <para>|document|'s embedded file name tree is too deep (i.e. |document| has too</para>
        /// <para>many embedded files already), then a new attachment will not be added.</para>
        /// <para>document - handle to a document.</para>
        /// <para>name     - name of the new attachment.</para>
        /// <para>Returns a handle to the new attachment object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAttachmentT FPDFDocAddAttachment(global::PDFiumCore.FpdfDocumentT document, ref ushort name)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (ushort* __name1 = &name)
            {
                var __arg1 = __name1;
                var __ret = __Internal.FPDFDocAddAttachment(__arg0, __arg1);
                var __result0 = global::PDFiumCore.FpdfAttachmentT.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the embedded attachment at |index| in |document|. Note that the returned</para>
        /// <para>attachment handle is only valid while |document| is open.</para>
        /// <para>document - handle to a document.</para>
        /// <para>index    - the index of the requested embedded file.</para>
        /// <para>Returns the handle to the attachment object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAttachmentT FPDFDocGetAttachment(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetAttachment(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfAttachmentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Delete the embedded attachment at |index| in |document|. Note that this does</para>
        /// <para>not remove the attachment data from the PDF file; it simply removes the</para>
        /// <para>file's entry in the embedded files name tree so that it does not appear in</para>
        /// <para>the attachment list. This behavior may change in the future.</para>
        /// <para>document - handle to a document.</para>
        /// <para>index    - the index of the embedded file to be deleted.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFDocDeleteAttachment(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocDeleteAttachment(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the name of the |attachment| file. |buffer| is only modified if |buflen|</para>
        /// <para>is longer than the length of the file name. On errors, |buffer| is unmodified</para>
        /// <para>and the returned length is 0.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>buffer     - buffer for holding the file name, encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the file name in bytes.</para>
        /// </summary>
        public static uint FPDFAttachmentGetName(global::PDFiumCore.FpdfAttachmentT attachment, ref ushort buffer, uint buflen)
        {
            var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
            fixed (ushort* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFAttachmentGetName(__arg0, __arg1, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if the params dictionary of |attachment| has |key| as a key.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns true if |key| exists.</para>
        /// </summary>
        public static int FPDFAttachmentHasKey(global::PDFiumCore.FpdfAttachmentT attachment, string key)
        {
            var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
            var __ret = __Internal.FPDFAttachmentHasKey(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the type of the value corresponding to |key| in the params dictionary of</para>
        /// <para>the embedded |attachment|.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns the type of the dictionary value.</para>
        /// </summary>
        public static int FPDFAttachmentGetValueType(global::PDFiumCore.FpdfAttachmentT attachment, string key)
        {
            var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
            var __ret = __Internal.FPDFAttachmentGetValueType(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the string value corresponding to |key| in the params dictionary of the</para>
        /// <para>embedded file |attachment|, overwriting the existing value if any. The value</para>
        /// <para>type should be FPDF_OBJECT_STRING after this function call succeeds.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to the dictionary entry, encoded in UTF-8.</para>
        /// <para>value      - the string value to be set, encoded in UTF-16LE.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAttachmentSetStringValue(global::PDFiumCore.FpdfAttachmentT attachment, string key, ref ushort value)
        {
            var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
            fixed (ushort* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAttachmentSetStringValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the string value corresponding to |key| in the params dictionary of the</para>
        /// <para>embedded file |attachment|. |buffer| is only modified if |buflen| is longer</para>
        /// <para>than the length of the string value. Note that if |key| does not exist in the</para>
        /// <para>dictionary or if |key|'s corresponding value in the dictionary is not a</para>
        /// <para>string (i.e. the value is not of type FPDF_OBJECT_STRING or</para>
        /// <para>FPDF_OBJECT_NAME), then an empty string would be copied to |buffer| and the</para>
        /// <para>return value would be 2. On other errors, nothing would be added to |buffer|</para>
        /// <para>and the return value would be 0.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to the requested string value, encoded in UTF-8.</para>
        /// <para>buffer     - buffer for holding the string value encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the dictionary value string in bytes.</para>
        /// </summary>
        public static uint FPDFAttachmentGetStringValue(global::PDFiumCore.FpdfAttachmentT attachment, string key, ref ushort buffer, uint buflen)
        {
            var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAttachmentGetStringValue(__arg0, key, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the file data of |attachment|, overwriting the existing file data if any.</para>
        /// <para>The creation date and checksum will be updated, while all other dictionary</para>
        /// <para>entries will be deleted. Note that only contents with |len| smaller than</para>
        /// <para>INT_MAX is supported.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>contents   - buffer holding the file data to write to |attachment|.</para>
        /// <para>len        - length of file data in bytes.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAttachmentSetFile(global::PDFiumCore.FpdfAttachmentT attachment, global::PDFiumCore.FpdfDocumentT document, __IntPtr contents, uint len)
        {
            var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
            var __arg1 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFAttachmentSetFile(__arg0, __arg1, contents, len);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the file data of |attachment|.</para>
        /// <para>When the attachment file data is readable, true is returned, and |out_buflen|</para>
        /// <para>is updated to indicate the file data size. |buffer| is only modified if</para>
        /// <para>|buflen| is non-null and long enough to contain the entire file data. Callers</para>
        /// <para>must check both the return value and the input |buflen| is no less than the</para>
        /// <para>returned |out_buflen| before using the data.</para>
        /// <para>Otherwise, when the attachment file data is unreadable or when |out_buflen|</para>
        /// <para>is null, false is returned and |buffer| and |out_buflen| remain unmodified.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>buffer     - buffer for holding the file data from |attachment|.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>out_buflen - pointer to the variable that will receive the minimum buffer</para>
        /// <para>size to contain the file data of |attachment|.</para>
        /// <para>Returns true on success, false otherwise.</para>
        /// </summary>
        public static int FPDFAttachmentGetFile(global::PDFiumCore.FpdfAttachmentT attachment, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = attachment is null ? __IntPtr.Zero : attachment.__Instance;
            fixed (uint* __out_buflen3 = &out_buflen)
            {
                var __arg3 = __out_buflen3;
                var __ret = __Internal.FPDFAttachmentGetFile(__arg0, buffer, buflen, __arg3);
                return __ret;
            }
        }
    }

    public unsafe partial class fpdf_catalog
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFCatalog_IsTagged", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFCatalogIsTagged(__IntPtr document);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Experimental API.</para>
        /// <para>Determine if |document| represents a tagged PDF.</para>
        /// <para>For the definition of tagged PDF, See (see 10.7 &quot;Tagged PDF&quot; in PDF</para>
        /// <para>Reference 1.7).</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns |true| iff |document| is a tagged PDF.</para>
        /// </summary>
        public static int FPDFCatalogIsTagged(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFCatalogIsTagged(__arg0);
            return __ret;
        }
    }

    public unsafe partial class FX_FILEAVAIL : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr IsDataAvail;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FX_FILEAVAIL@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_FILEAVAIL> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_FILEAVAIL>();

        protected bool __ownsNativeInstance;

        internal static FX_FILEAVAIL __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FX_FILEAVAIL(native.ToPointer(), skipVTables);
        }

        internal static FX_FILEAVAIL __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FX_FILEAVAIL)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FX_FILEAVAIL __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FX_FILEAVAIL(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FX_FILEAVAIL(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FX_FILEAVAIL(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FX_FILEAVAIL()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_FILEAVAIL.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FX_FILEAVAIL(global::PDFiumCore.FX_FILEAVAIL _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_FILEAVAIL.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FX_FILEAVAIL.__Internal*) __Instance) = *((global::PDFiumCore.FX_FILEAVAIL.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr_ulong_ulong IsDataAvail
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->IsDataAvail;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr_ulong_ulong) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr_ulong_ulong));
            }

            set
            {
                ((__Internal*)__Instance)->IsDataAvail = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FX_DOWNLOADHINTS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr AddSegment;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FX_DOWNLOADHINTS@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_DOWNLOADHINTS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_DOWNLOADHINTS>();

        protected bool __ownsNativeInstance;

        internal static FX_DOWNLOADHINTS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FX_DOWNLOADHINTS(native.ToPointer(), skipVTables);
        }

        internal static FX_DOWNLOADHINTS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FX_DOWNLOADHINTS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FX_DOWNLOADHINTS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FX_DOWNLOADHINTS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FX_DOWNLOADHINTS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FX_DOWNLOADHINTS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FX_DOWNLOADHINTS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FX_DOWNLOADHINTS(global::PDFiumCore.FX_DOWNLOADHINTS _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*) __Instance) = *((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr_ulong_ulong AddSegment
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->AddSegment;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr_ulong_ulong) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr_ulong_ulong));
            }

            set
            {
                ((__Internal*)__Instance)->AddSegment = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class fpdf_dataavail
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_Create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFAvailCreate(__IntPtr file_avail, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_Destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFAvailDestroy(__IntPtr avail);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_IsDocAvail", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAvailIsDocAvail(__IntPtr avail, __IntPtr hints);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_GetDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFAvailGetDocument(__IntPtr avail, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string password);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_GetFirstPageNum", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAvailGetFirstPageNum(__IntPtr doc);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_IsPageAvail", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAvailIsPageAvail(__IntPtr avail, int page_index, __IntPtr hints);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_IsFormAvail", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAvailIsFormAvail(__IntPtr avail, __IntPtr hints);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAvail_IsLinearized", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFAvailIsLinearized(__IntPtr avail);
        }

        /// <summary>
        /// <para>Create a document availability provider.</para>
        /// <para>file_avail - pointer to file availability interface.</para>
        /// <para>file       - pointer to a file access interface.</para>
        /// <para>Returns a handle to the document availability provider, or NULL on error.</para>
        /// <para>FPDFAvail_Destroy() must be called when done with the availability provider.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAvailT FPDFAvailCreate(global::PDFiumCore.FX_FILEAVAIL file_avail, global::PDFiumCore.FPDF_FILEACCESS file)
        {
            var __arg0 = file_avail is null ? __IntPtr.Zero : file_avail.__Instance;
            var __arg1 = file is null ? __IntPtr.Zero : file.__Instance;
            var __ret = __Internal.FPDFAvailCreate(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfAvailT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Destroy the |avail| document availability provider.</para>
        /// <para>avail - handle to document availability provider to be destroyed.</para>
        /// </summary>
        public static void FPDFAvailDestroy(global::PDFiumCore.FpdfAvailT avail)
        {
            var __arg0 = avail is null ? __IntPtr.Zero : avail.__Instance;
            __Internal.FPDFAvailDestroy(__arg0);
        }

        /// <summary>
        /// <para>Checks if the document is ready for loading, if not, gets download hints.</para>
        /// <para>avail - handle to document availability provider.</para>
        /// <para>hints - pointer to a download hints interface.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_DATA_ERROR: A common error is returned. Data availability unknown.</para>
        /// <para>PDF_DATA_NOTAVAIL: Data not yet available.</para>
        /// <para>PDF_DATA_AVAIL: Data available.</para>
        /// <para>Applications should call this function whenever new data arrives, and process</para>
        /// <para>all the generated download hints, if any, until the function returns</para>
        /// <para>|PDF_DATA_ERROR| or |PDF_DATA_AVAIL|.</para>
        /// <para>if hints is nullptr, the function just check current document availability.</para>
        /// <para>Once all data is available, call FPDFAvail_GetDocument() to get a document</para>
        /// <para>handle.</para>
        /// </summary>
        public static int FPDFAvailIsDocAvail(global::PDFiumCore.FpdfAvailT avail, global::PDFiumCore.FX_DOWNLOADHINTS hints)
        {
            var __arg0 = avail is null ? __IntPtr.Zero : avail.__Instance;
            var __arg1 = hints is null ? __IntPtr.Zero : hints.__Instance;
            var __ret = __Internal.FPDFAvailIsDocAvail(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get document from the availability provider.</para>
        /// <para>avail    - handle to document availability provider.</para>
        /// <para>password - password for decrypting the PDF file. Optional.</para>
        /// <para>Returns a handle to the document.</para>
        /// <para>When FPDFAvail_IsDocAvail() returns TRUE, call FPDFAvail_GetDocument() to</para>
        /// <para>retrieve the document handle.</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for</para>
        /// <para>|password|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDFAvailGetDocument(global::PDFiumCore.FpdfAvailT avail, string password)
        {
            var __arg0 = avail is null ? __IntPtr.Zero : avail.__Instance;
            var __ret = __Internal.FPDFAvailGetDocument(__arg0, password);
            var __result0 = global::PDFiumCore.FpdfDocumentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the page number for the first available page in a linearized PDF.</para>
        /// <para>doc - document handle.</para>
        /// <para>Returns the zero-based index for the first available page.</para>
        /// <para>For most linearized PDFs, the first available page will be the first page,</para>
        /// <para>however, some PDFs might make another page the first available page.</para>
        /// <para>For non-linearized PDFs, this function will always return zero.</para>
        /// </summary>
        public static int FPDFAvailGetFirstPageNum(global::PDFiumCore.FpdfDocumentT doc)
        {
            var __arg0 = doc is null ? __IntPtr.Zero : doc.__Instance;
            var __ret = __Internal.FPDFAvailGetFirstPageNum(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Check if |page_index| is ready for loading, if not, get the</para>
        /// <para>|FX_DOWNLOADHINTS|.</para>
        /// <para>avail      - handle to document availability provider.</para>
        /// <para>page_index - index number of the page. Zero for the first page.</para>
        /// <para>hints      - pointer to a download hints interface. Populated if</para>
        /// <para>|page_index| is not available.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_DATA_ERROR: A common error is returned. Data availability unknown.</para>
        /// <para>PDF_DATA_NOTAVAIL: Data not yet available.</para>
        /// <para>PDF_DATA_AVAIL: Data available.</para>
        /// <para>This function can be called only after FPDFAvail_GetDocument() is called.</para>
        /// <para>Applications should call this function whenever new data arrives and process</para>
        /// <para>all the generated download |hints|, if any, until this function returns</para>
        /// <para>|PDF_DATA_ERROR| or |PDF_DATA_AVAIL|. Applications can then perform page</para>
        /// <para>loading.</para>
        /// <para>if hints is nullptr, the function just check current availability of</para>
        /// <para>specified page.</para>
        /// </summary>
        public static int FPDFAvailIsPageAvail(global::PDFiumCore.FpdfAvailT avail, int page_index, global::PDFiumCore.FX_DOWNLOADHINTS hints)
        {
            var __arg0 = avail is null ? __IntPtr.Zero : avail.__Instance;
            var __arg2 = hints is null ? __IntPtr.Zero : hints.__Instance;
            var __ret = __Internal.FPDFAvailIsPageAvail(__arg0, page_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Check if form data is ready for initialization, if not, get the</para>
        /// <para>|FX_DOWNLOADHINTS|.</para>
        /// <para>avail - handle to document availability provider.</para>
        /// <para>hints - pointer to a download hints interface. Populated if form is not</para>
        /// <para>ready for initialization.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_FORM_ERROR: A common eror, in general incorrect parameters.</para>
        /// <para>PDF_FORM_NOTAVAIL: Data not available.</para>
        /// <para>PDF_FORM_AVAIL: Data available.</para>
        /// <para>PDF_FORM_NOTEXIST: No form data.</para>
        /// <para>This function can be called only after FPDFAvail_GetDocument() is called.</para>
        /// <para>The application should call this function whenever new data arrives and</para>
        /// <para>process all the generated download |hints|, if any, until the function</para>
        /// <para>|PDF_FORM_ERROR|, |PDF_FORM_AVAIL| or |PDF_FORM_NOTEXIST|.</para>
        /// <para>if hints is nullptr, the function just check current form availability.</para>
        /// <para>Applications can then perform page loading. It is recommend to call</para>
        /// <para>FPDFDOC_InitFormFillEnvironment() when |PDF_FORM_AVAIL| is returned.</para>
        /// </summary>
        public static int FPDFAvailIsFormAvail(global::PDFiumCore.FpdfAvailT avail, global::PDFiumCore.FX_DOWNLOADHINTS hints)
        {
            var __arg0 = avail is null ? __IntPtr.Zero : avail.__Instance;
            var __arg1 = hints is null ? __IntPtr.Zero : hints.__Instance;
            var __ret = __Internal.FPDFAvailIsFormAvail(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Check whether a document is a linearized PDF.</para>
        /// <para>avail - handle to document availability provider.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_LINEARIZED</para>
        /// <para>PDF_NOT_LINEARIZED</para>
        /// <para>PDF_LINEARIZATION_UNKNOWN</para>
        /// <para>FPDFAvail_IsLinearized() will return |PDF_LINEARIZED| or |PDF_NOT_LINEARIZED|</para>
        /// <para>when we have 1k  of data. If the files size less than 1k, it returns</para>
        /// <para>|PDF_LINEARIZATION_UNKNOWN| as there is insufficient information to determine</para>
        /// <para>if the PDF is linearlized.</para>
        /// </summary>
        public static int FPDFAvailIsLinearized(global::PDFiumCore.FpdfAvailT avail)
        {
            var __arg0 = avail is null ? __IntPtr.Zero : avail.__Instance;
            var __ret = __Internal.FPDFAvailIsLinearized(__arg0);
            return __ret;
        }
    }

    public enum FPDF_FILEIDTYPE
    {
        FILEIDTYPE_PERMANENT = 0,
        FILEIDTYPE_CHANGING = 1
    }

    public unsafe partial class fpdf_doc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBookmark_GetFirstChild", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBookmarkGetFirstChild(__IntPtr document, __IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBookmark_GetNextSibling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBookmarkGetNextSibling(__IntPtr document, __IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBookmark_GetTitle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFBookmarkGetTitle(__IntPtr bookmark, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBookmark_GetCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBookmarkGetCount(__IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBookmark_Find", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBookmarkFind(__IntPtr document, ushort* title);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBookmark_GetDest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBookmarkGetDest(__IntPtr document, __IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFBookmark_GetAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBookmarkGetAction(__IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAction_GetType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFActionGetType(__IntPtr action);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAction_GetDest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFActionGetDest(__IntPtr document, __IntPtr action);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAction_GetFilePath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFActionGetFilePath(__IntPtr action, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFAction_GetURIPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFActionGetURIPath(__IntPtr document, __IntPtr action, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDest_GetDestPageIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFDestGetDestPageIndex(__IntPtr document, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDest_GetView", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFDestGetView(__IntPtr dest, uint* pNumParams, float* pParams);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDest_GetLocationInPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFDestGetLocationInPage(__IntPtr dest, int* hasXVal, int* hasYVal, int* hasZoomVal, float* x, float* y, float* zoom);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetLinkAtPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFLinkGetLinkAtPoint(__IntPtr page, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetLinkZOrderAtPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkGetLinkZOrderAtPoint(__IntPtr page, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetDest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFLinkGetDest(__IntPtr document, __IntPtr link);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFLinkGetAction(__IntPtr link);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_Enumerate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkEnumerate(__IntPtr page, int* start_pos, __IntPtr link_annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetAnnot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFLinkGetAnnot(__IntPtr page, __IntPtr link_annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetAnnotRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkGetAnnotRect(__IntPtr link_annot, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_CountQuadPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkCountQuadPoints(__IntPtr link_annot);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetQuadPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkGetQuadPoints(__IntPtr link_annot, int quad_index, __IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageAAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetPageAAction(__IntPtr page, int aa_type);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetFileIdentifier", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetFileIdentifier(__IntPtr document, global::PDFiumCore.FPDF_FILEIDTYPE id_type, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetMetaText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetMetaText(__IntPtr document, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string tag, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetPageLabel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetPageLabel(__IntPtr document, int page_index, __IntPtr buffer, uint buflen);
        }

        /// <summary>
        /// <para>Get the first child of |bookmark|, or the first top-level bookmark item.</para>
        /// <para>document - handle to the document.</para>
        /// <para>bookmark - handle to the current bookmark. Pass NULL for the first top</para>
        /// <para>level item.</para>
        /// <para>Returns a handle to the first child of |bookmark| or the first top-level</para>
        /// <para>bookmark item. NULL if no child or top-level bookmark found.</para>
        /// <para>Note that another name for the bookmarks is the document outline, as</para>
        /// <para>described in ISO 32000-1:2008, section 12.3.3.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBookmarkT FPDFBookmarkGetFirstChild(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = bookmark is null ? __IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetFirstChild(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfBookmarkT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the next sibling of |bookmark|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>bookmark - handle to the current bookmark.</para>
        /// <para>Returns a handle to the next sibling of |bookmark|, or NULL if this is the</para>
        /// <para>last bookmark at this level.</para>
        /// <para>Note that the caller is responsible for handling circular bookmark</para>
        /// <para>references, as may arise from malformed documents.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBookmarkT FPDFBookmarkGetNextSibling(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = bookmark is null ? __IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetNextSibling(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfBookmarkT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the title of |bookmark|.</para>
        /// <para>bookmark - handle to the bookmark.</para>
        /// <para>buffer   - buffer for the title. May be NULL.</para>
        /// <para>buflen   - the length of the buffer in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the title, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the |buffer| and</para>
        /// <para>|buflen| parameters.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The</para>
        /// <para>string is terminated by a UTF16 NUL character. If |buflen| is less than the</para>
        /// <para>required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFBookmarkGetTitle(global::PDFiumCore.FpdfBookmarkT bookmark, __IntPtr buffer, uint buflen)
        {
            var __arg0 = bookmark is null ? __IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetTitle(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of chlidren of |bookmark|.</para>
        /// <para>bookmark - handle to the bookmark.</para>
        /// <para>Returns a signed integer that represents the number of sub-items the given</para>
        /// <para>bookmark has. If the value is positive, child items shall be shown by default</para>
        /// <para>(open state). If the value is negative, child items shall be hidden by</para>
        /// <para>default (closed state). Please refer to PDF 32000-1:2008, Table 153.</para>
        /// <para>Returns 0 if the bookmark has no children or is invalid.</para>
        /// </summary>
        public static int FPDFBookmarkGetCount(global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = bookmark is null ? __IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Find the bookmark with |title| in |document|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>title    - the UTF-16LE encoded Unicode title for which to search.</para>
        /// <para>Returns the handle to the bookmark, or NULL if |title| can't be found.</para>
        /// <para>FPDFBookmark_Find() will always return the first bookmark found even if</para>
        /// <para>multiple bookmarks have the same |title|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBookmarkT FPDFBookmarkFind(global::PDFiumCore.FpdfDocumentT document, ref ushort title)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (ushort* __title1 = &title)
            {
                var __arg1 = __title1;
                var __ret = __Internal.FPDFBookmarkFind(__arg0, __arg1);
                var __result0 = global::PDFiumCore.FpdfBookmarkT.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Get the destination associated with |bookmark|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>bookmark - handle to the bookmark.</para>
        /// <para>Returns the handle to the destination data, or NULL if no destination is</para>
        /// <para>associated with |bookmark|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDFBookmarkGetDest(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = bookmark is null ? __IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetDest(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfDestT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the action associated with |bookmark|.</para>
        /// <para>bookmark - handle to the bookmark.</para>
        /// <para>Returns the handle to the action data, or NULL if no action is associated</para>
        /// <para>with |bookmark|.</para>
        /// <para>If this function returns a valid handle, it is valid as long as |bookmark| is</para>
        /// <para>valid.</para>
        /// <para>If this function returns NULL, FPDFBookmark_GetDest() should be called to get</para>
        /// <para>the |bookmark| destination data.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfActionT FPDFBookmarkGetAction(global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = bookmark is null ? __IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetAction(__arg0);
            var __result0 = global::PDFiumCore.FpdfActionT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the type of |action|.</para>
        /// <para>action - handle to the action.</para>
        /// <para>Returns one of:</para>
        /// <para>PDFACTION_UNSUPPORTED</para>
        /// <para>PDFACTION_GOTO</para>
        /// <para>PDFACTION_REMOTEGOTO</para>
        /// <para>PDFACTION_URI</para>
        /// <para>PDFACTION_LAUNCH</para>
        /// </summary>
        public static uint FPDFActionGetType(global::PDFiumCore.FpdfActionT action)
        {
            var __arg0 = action is null ? __IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get the destination of |action|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>action   - handle to the action. |action| must be a |PDFACTION_GOTO| or</para>
        /// <para>|PDFACTION_REMOTEGOTO|.</para>
        /// <para>Returns a handle to the destination data, or NULL on error, typically</para>
        /// <para>because the arguments were bad or the action was of the wrong type.</para>
        /// <para>In the case of |PDFACTION_REMOTEGOTO|, you must first call</para>
        /// <para>FPDFAction_GetFilePath(), then load the document at that path, then pass</para>
        /// <para>the document handle from that document as |document| to FPDFAction_GetDest().</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDFActionGetDest(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfActionT action)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = action is null ? __IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetDest(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfDestT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the file path of |action|.</para>
        /// <para>action - handle to the action. |action| must be a |PDFACTION_LAUNCH| or</para>
        /// <para>|PDFACTION_REMOTEGOTO|.</para>
        /// <para>buffer - a buffer for output the path string. May be NULL.</para>
        /// <para>buflen - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the file path, including the trailing NUL</para>
        /// <para>character, or 0 on error, typically because the arguments were bad or the</para>
        /// <para>action was of the wrong type.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-8 encoding.</para>
        /// <para>If |buflen| is less than the returned length, or |buffer| is NULL, |buffer|</para>
        /// <para>will not be modified.</para>
        /// </summary>
        public static uint FPDFActionGetFilePath(global::PDFiumCore.FpdfActionT action, __IntPtr buffer, uint buflen)
        {
            var __arg0 = action is null ? __IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetFilePath(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the URI path of |action|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>action   - handle to the action. Must be a |PDFACTION_URI|.</para>
        /// <para>buffer   - a buffer for the path string. May be NULL.</para>
        /// <para>buflen   - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the URI path, including the trailing NUL</para>
        /// <para>character, or 0 on error, typically because the arguments were bad or the</para>
        /// <para>action was of the wrong type.</para>
        /// <para>The |buffer| may contain badly encoded data. The caller should validate the</para>
        /// <para>output. e.g. Check to see if it is UTF-8.</para>
        /// <para>If |buflen| is less than the returned length, or |buffer| is NULL, |buffer|</para>
        /// <para>will not be modified.</para>
        /// <para>Historically, the documentation for this API claimed |buffer| is always</para>
        /// <para>encoded in 7-bit ASCII, but did not actually enforce it.</para>
        /// <para>https://pdfium.googlesource.com/pdfium.git/+/d609e84cee2e14a18333247485af91df48a40592</para>
        /// <para>added that enforcement, but that did not work well for real world PDFs that</para>
        /// <para>used UTF-8. As of this writing, this API reverted back to its original</para>
        /// <para>behavior prior to commit d609e84cee.</para>
        /// </summary>
        public static uint FPDFActionGetURIPath(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfActionT action, __IntPtr buffer, uint buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = action is null ? __IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetURIPath(__arg0, __arg1, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the page index of |dest|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>dest     - handle to the destination.</para>
        /// <para>Returns the 0-based page index containing |dest|. Returns -1 on error.</para>
        /// </summary>
        public static int FPDFDestGetDestPageIndex(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfDestT dest)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var __ret = __Internal.FPDFDestGetDestPageIndex(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the view (fit type) specified by |dest|.</para>
        /// <para>dest         - handle to the destination.</para>
        /// <para>pNumParams   - receives the number of view parameters, which is at most 4.</para>
        /// <para>pParams      - buffer to write the view parameters. Must be at least 4</para>
        /// <para>FS_FLOATs long.</para>
        /// <para>Returns one of the PDFDEST_VIEW_* constants, PDFDEST_VIEW_UNKNOWN_MODE if</para>
        /// <para>|dest| does not specify a view.</para>
        /// </summary>
        public static uint FPDFDestGetView(global::PDFiumCore.FpdfDestT dest, ref uint pNumParams, ref float pParams)
        {
            var __arg0 = dest is null ? __IntPtr.Zero : dest.__Instance;
            fixed (uint* __pNumParams1 = &pNumParams)
            {
                var __arg1 = __pNumParams1;
                fixed (float* __pParams2 = &pParams)
                {
                    var __arg2 = __pParams2;
                    var __ret = __Internal.FPDFDestGetView(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Get the (x, y, zoom) location of |dest| in the destination page, if the</para>
        /// <para>destination is in [page /XYZ x y zoom] syntax.</para>
        /// <para>dest       - handle to the destination.</para>
        /// <para>hasXVal    - out parameter; true if the x value is not null</para>
        /// <para>hasYVal    - out parameter; true if the y value is not null</para>
        /// <para>hasZoomVal - out parameter; true if the zoom value is not null</para>
        /// <para>x          - out parameter; the x coordinate, in page coordinates.</para>
        /// <para>y          - out parameter; the y coordinate, in page coordinates.</para>
        /// <para>zoom       - out parameter; the zoom value.</para>
        /// <para>Returns TRUE on successfully reading the /XYZ value.</para>
        /// <para>Note the [x, y, zoom] values are only set if the corresponding hasXVal,</para>
        /// <para>hasYVal or hasZoomVal flags are true.</para>
        /// </summary>
        public static int FPDFDestGetLocationInPage(global::PDFiumCore.FpdfDestT dest, ref int hasXVal, ref int hasYVal, ref int hasZoomVal, ref float x, ref float y, ref float zoom)
        {
            var __arg0 = dest is null ? __IntPtr.Zero : dest.__Instance;
            fixed (int* __hasXVal1 = &hasXVal)
            {
                var __arg1 = __hasXVal1;
                fixed (int* __hasYVal2 = &hasYVal)
                {
                    var __arg2 = __hasYVal2;
                    fixed (int* __hasZoomVal3 = &hasZoomVal)
                    {
                        var __arg3 = __hasZoomVal3;
                        fixed (float* __x4 = &x)
                        {
                            var __arg4 = __x4;
                            fixed (float* __y5 = &y)
                            {
                                var __arg5 = __y5;
                                fixed (float* __zoom6 = &zoom)
                                {
                                    var __arg6 = __zoom6;
                                    var __ret = __Internal.FPDFDestGetLocationInPage(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                                    return __ret;
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Find a link at point (|x|,|y|) on |page|.</para>
        /// <para>page - handle to the document page.</para>
        /// <para>x    - the x coordinate, in the page coordinate system.</para>
        /// <para>y    - the y coordinate, in the page coordinate system.</para>
        /// <para>Returns a handle to the link, or NULL if no link found at the given point.</para>
        /// <para>You can convert coordinates from screen coordinates to page coordinates using</para>
        /// <para>FPDF_DeviceToPage().</para>
        /// </summary>
        public static global::PDFiumCore.FpdfLinkT FPDFLinkGetLinkAtPoint(global::PDFiumCore.FpdfPageT page, double x, double y)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFLinkGetLinkAtPoint(__arg0, x, y);
            var __result0 = global::PDFiumCore.FpdfLinkT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Find the Z-order of link at point (|x|,|y|) on |page|.</para>
        /// <para>page - handle to the document page.</para>
        /// <para>x    - the x coordinate, in the page coordinate system.</para>
        /// <para>y    - the y coordinate, in the page coordinate system.</para>
        /// <para>Returns the Z-order of the link, or -1 if no link found at the given point.</para>
        /// <para>Larger Z-order numbers are closer to the front.</para>
        /// <para>You can convert coordinates from screen coordinates to page coordinates using</para>
        /// <para>FPDF_DeviceToPage().</para>
        /// </summary>
        public static int FPDFLinkGetLinkZOrderAtPoint(global::PDFiumCore.FpdfPageT page, double x, double y)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFLinkGetLinkZOrderAtPoint(__arg0, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>Get destination info for |link|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>link     - handle to the link.</para>
        /// <para>Returns a handle to the destination, or NULL if there is no destination</para>
        /// <para>associated with the link. In this case, you should call FPDFLink_GetAction()</para>
        /// <para>to retrieve the action associated with |link|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDFLinkGetDest(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfLinkT link)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = link is null ? __IntPtr.Zero : link.__Instance;
            var __ret = __Internal.FPDFLinkGetDest(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfDestT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get action info for |link|.</para>
        /// <para>link - handle to the link.</para>
        /// <para>Returns a handle to the action associated to |link|, or NULL if no action.</para>
        /// <para>If this function returns a valid handle, it is valid as long as |link| is</para>
        /// <para>valid.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfActionT FPDFLinkGetAction(global::PDFiumCore.FpdfLinkT link)
        {
            var __arg0 = link is null ? __IntPtr.Zero : link.__Instance;
            var __ret = __Internal.FPDFLinkGetAction(__arg0);
            var __result0 = global::PDFiumCore.FpdfActionT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Enumerates all the link annotations in |page|.</para>
        /// <para>page       - handle to the page.</para>
        /// <para>start_pos  - the start position, should initially be 0 and is updated with</para>
        /// <para>the next start position on return.</para>
        /// <para>link_annot - the link handle for |startPos|.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFLinkEnumerate(global::PDFiumCore.FpdfPageT page, ref int start_pos, global::PDFiumCore.FpdfLinkT link_annot)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (int* __start_pos1 = &start_pos)
            {
                var __arg1 = __start_pos1;
                var ____arg2 = link_annot is null ? __IntPtr.Zero : link_annot.__Instance;
                var __arg2 = new __IntPtr(&____arg2);
                var __ret = __Internal.FPDFLinkEnumerate(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets FPDF_ANNOTATION object for |link_annot|.</para>
        /// <para>page       - handle to the page in which FPDF_LINK object is present.</para>
        /// <para>link_annot - handle to link annotation.</para>
        /// <para>Returns FPDF_ANNOTATION from the FPDF_LINK and NULL on failure,</para>
        /// <para>if the input link annot or page is NULL.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFLinkGetAnnot(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfLinkT link_annot)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = link_annot is null ? __IntPtr.Zero : link_annot.__Instance;
            var __ret = __Internal.FPDFLinkGetAnnot(__arg0, __arg1);
            var __result0 = global::PDFiumCore.FpdfAnnotationT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the rectangle for |link_annot|.</para>
        /// <para>link_annot - handle to the link annotation.</para>
        /// <para>rect       - the annotation rectangle.</para>
        /// <para>Returns true on success.</para>
        /// </summary>
        public static int FPDFLinkGetAnnotRect(global::PDFiumCore.FpdfLinkT link_annot, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = link_annot is null ? __IntPtr.Zero : link_annot.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFLinkGetAnnotRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get the count of quadrilateral points to the |link_annot|.</para>
        /// <para>link_annot - handle to the link annotation.</para>
        /// <para>Returns the count of quadrilateral points.</para>
        /// </summary>
        public static int FPDFLinkCountQuadPoints(global::PDFiumCore.FpdfLinkT link_annot)
        {
            var __arg0 = link_annot is null ? __IntPtr.Zero : link_annot.__Instance;
            var __ret = __Internal.FPDFLinkCountQuadPoints(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get the quadrilateral points for the specified |quad_index| in |link_annot|.</para>
        /// <para>link_annot  - handle to the link annotation.</para>
        /// <para>quad_index  - the specified quad point index.</para>
        /// <para>quad_points - receives the quadrilateral points.</para>
        /// <para>Returns true on success.</para>
        /// </summary>
        public static int FPDFLinkGetQuadPoints(global::PDFiumCore.FpdfLinkT link_annot, int quad_index, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = link_annot is null ? __IntPtr.Zero : link_annot.__Instance;
            var __arg2 = quad_points is null ? __IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFLinkGetQuadPoints(__arg0, quad_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Gets an additional-action from |page|.</para>
        /// <para>page      - handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>aa_type   - the type of the page object's addtional-action, defined</para>
        /// <para>in public/fpdf_formfill.h</para>
        /// <para>Returns the handle to the action data, or NULL if there is no</para>
        /// <para>additional-action of type |aa_type|.</para>
        /// <para>If this function returns a valid handle, it is valid as long as |page| is</para>
        /// <para>valid.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfActionT FPDF_GetPageAAction(global::PDFiumCore.FpdfPageT page, int aa_type)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageAAction(__arg0, aa_type);
            var __result0 = global::PDFiumCore.FpdfActionT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the file identifer defined in the trailer of |document|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>id_type  - the file identifier type to retrieve.</para>
        /// <para>buffer   - a buffer for the file identifier. May be NULL.</para>
        /// <para>buflen   - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the file identifier, including the NUL</para>
        /// <para>terminator.</para>
        /// <para>The |buffer| is always a byte string. The |buffer| is followed by a NUL</para>
        /// <para>terminator.  If |buflen| is less than the returned length, or |buffer| is</para>
        /// <para>NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_GetFileIdentifier(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FILEIDTYPE id_type, __IntPtr buffer, uint buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetFileIdentifier(__arg0, id_type, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get meta-data |tag| content from |document|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>tag      - the tag to retrieve. The tag can be one of:</para>
        /// <para>Title, Author, Subject, Keywords, Creator, Producer,</para>
        /// <para>CreationDate, or ModDate.</para>
        /// <para>For detailed explanations of these tags and their respective</para>
        /// <para>values, please refer to PDF Reference 1.6, section 10.2.1,</para>
        /// <para>'Document Information Dictionary'.</para>
        /// <para>buffer   - a buffer for the tag. May be NULL.</para>
        /// <para>buflen   - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the tag, including trailing zeros.</para>
        /// <para>The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two</para>
        /// <para>bytes of zeros indicating the end of the string.  If |buflen| is less than</para>
        /// <para>the returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>For linearized files, FPDFAvail_IsFormAvail must be called before this, and</para>
        /// <para>it must have returned PDF_FORM_AVAIL or PDF_FORM_NOTEXIST. Before that, there</para>
        /// <para>is no guarantee the metadata has been loaded.</para>
        /// </summary>
        public static uint FPDF_GetMetaText(global::PDFiumCore.FpdfDocumentT document, string tag, __IntPtr buffer, uint buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetMetaText(__arg0, tag, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the page label for |page_index| from |document|.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_index  - the 0-based index of the page.</para>
        /// <para>buffer      - a buffer for the page label. May be NULL.</para>
        /// <para>buflen      - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the page label, including trailing zeros.</para>
        /// <para>The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two</para>
        /// <para>bytes of zeros indicating the end of the string.  If |buflen| is less than</para>
        /// <para>the returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_GetPageLabel(global::PDFiumCore.FpdfDocumentT document, int page_index, __IntPtr buffer, uint buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetPageLabel(__arg0, page_index, buffer, buflen);
            return __ret;
        }
    }

    public unsafe partial class FPDF_IMAGEOBJ_METADATA : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal uint width;
            internal uint height;
            internal float horizontal_dpi;
            internal float vertical_dpi;
            internal uint bits_per_pixel;
            internal int colorspace;
            internal int marked_content_id;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_IMAGEOBJ_METADATA@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_IMAGEOBJ_METADATA> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_IMAGEOBJ_METADATA>();

        protected bool __ownsNativeInstance;

        internal static FPDF_IMAGEOBJ_METADATA __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_IMAGEOBJ_METADATA(native.ToPointer(), skipVTables);
        }

        internal static FPDF_IMAGEOBJ_METADATA __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_IMAGEOBJ_METADATA)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_IMAGEOBJ_METADATA __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_IMAGEOBJ_METADATA(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_IMAGEOBJ_METADATA(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_IMAGEOBJ_METADATA(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_IMAGEOBJ_METADATA()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_IMAGEOBJ_METADATA(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public float HorizontalDpi
        {
            get
            {
                return ((__Internal*)__Instance)->horizontal_dpi;
            }

            set
            {
                ((__Internal*)__Instance)->horizontal_dpi = value;
            }
        }

        public float VerticalDpi
        {
            get
            {
                return ((__Internal*)__Instance)->vertical_dpi;
            }

            set
            {
                ((__Internal*)__Instance)->vertical_dpi = value;
            }
        }

        public uint BitsPerPixel
        {
            get
            {
                return ((__Internal*)__Instance)->bits_per_pixel;
            }

            set
            {
                ((__Internal*)__Instance)->bits_per_pixel = value;
            }
        }

        public int Colorspace
        {
            get
            {
                return ((__Internal*)__Instance)->colorspace;
            }

            set
            {
                ((__Internal*)__Instance)->colorspace = value;
            }
        }

        public int MarkedContentId
        {
            get
            {
                return ((__Internal*)__Instance)->marked_content_id;
            }

            set
            {
                ((__Internal*)__Instance)->marked_content_id = value;
            }
        }
    }

    public unsafe partial class fpdf_edit
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_CreateNewDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_CreateNewDocument();

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_New", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageNew(__IntPtr document, int page_index, double width, double height);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_Delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageDelete(__IntPtr document, int page_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_MovePages", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_MovePages(__IntPtr document, int* page_indices, uint page_indices_len, int dest_page_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetRotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetRotation(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_SetRotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageSetRotation(__IntPtr page, int rotate);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_InsertObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageInsertObject(__IntPtr page, __IntPtr page_obj);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_RemoveObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageRemoveObject(__IntPtr page, __IntPtr page_obj);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_CountObjects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageCountObjects(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageGetObject(__IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_HasTransparency", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageHasTransparency(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GenerateContent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGenerateContent(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_Destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageObjDestroy(__IntPtr page_obj);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_HasTransparency", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjHasTransparency(__IntPtr page_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetType(__IntPtr page_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_Transform", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageObjTransform(__IntPtr page_object, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetMatrix(__IntPtr page_object, __IntPtr matrix);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetMatrix(__IntPtr path, __IntPtr matrix);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_TransformAnnots", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageTransformAnnots(__IntPtr page, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_NewImageObj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjNewImageObj(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_CountMarks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjCountMarks(__IntPtr page_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetMark", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjGetMark(__IntPtr page_object, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_AddMark", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjAddMark(__IntPtr page_object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_RemoveMark", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjRemoveMark(__IntPtr page_object, __IntPtr mark);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkGetName(__IntPtr mark, __IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_CountParams", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkCountParams(__IntPtr mark);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_GetParamKey", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkGetParamKey(__IntPtr mark, uint index, __IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_GetParamValueType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkGetParamValueType(__IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_GetParamIntValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkGetParamIntValue(__IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, int* out_value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_GetParamStringValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkGetParamStringValue(__IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, __IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_GetParamBlobValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkGetParamBlobValue(__IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, __IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_SetIntParam", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkSetIntParam(__IntPtr document, __IntPtr page_object, __IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_SetStringParam", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkSetStringParam(__IntPtr document, __IntPtr page_object, __IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_SetBlobParam", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkSetBlobParam(__IntPtr document, __IntPtr page_object, __IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, __IntPtr value, uint value_len);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObjMark_RemoveParam", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjMarkRemoveParam(__IntPtr page_object, __IntPtr mark, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_LoadJpegFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFImageObjLoadJpegFile(__IntPtr pages, int count, __IntPtr image_object, __IntPtr file_access);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_LoadJpegFileInline", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFImageObjLoadJpegFileInline(__IntPtr pages, int count, __IntPtr image_object, __IntPtr file_access);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_SetMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFImageObjSetMatrix(__IntPtr image_object, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_SetBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFImageObjSetBitmap(__IntPtr pages, int count, __IntPtr image_object, __IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFImageObjGetBitmap(__IntPtr image_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetRenderedBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFImageObjGetRenderedBitmap(__IntPtr document, __IntPtr page, __IntPtr image_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetImageDataDecoded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFImageObjGetImageDataDecoded(__IntPtr image_object, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetImageDataRaw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFImageObjGetImageDataRaw(__IntPtr image_object, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetImageFilterCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFImageObjGetImageFilterCount(__IntPtr image_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetImageFilter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFImageObjGetImageFilter(__IntPtr image_object, int index, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetImageMetadata", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFImageObjGetImageMetadata(__IntPtr image_object, __IntPtr page, __IntPtr metadata);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFImageObj_GetImagePixelSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFImageObjGetImagePixelSize(__IntPtr image_object, uint* width, uint* height);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_CreateNewPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjCreateNewPath(float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_CreateNewRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjCreateNewRect(float x, float y, float w, float h);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetBounds", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetBounds(__IntPtr page_object, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetRotatedBounds", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetRotatedBounds(__IntPtr page_object, __IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetBlendMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageObjSetBlendMode(__IntPtr page_object, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string blend_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetStrokeColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetStrokeColor(__IntPtr page_object, uint R, uint G, uint B, uint A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetStrokeColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetStrokeColor(__IntPtr page_object, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetStrokeWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetStrokeWidth(__IntPtr page_object, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetStrokeWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetStrokeWidth(__IntPtr page_object, float* width);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetLineJoin", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetLineJoin(__IntPtr page_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetLineJoin", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetLineJoin(__IntPtr page_object, int line_join);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetLineCap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetLineCap(__IntPtr page_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetLineCap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetLineCap(__IntPtr page_object, int line_cap);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetFillColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetFillColor(__IntPtr page_object, uint R, uint G, uint B, uint A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetFillColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetFillColor(__IntPtr page_object, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetDashPhase", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetDashPhase(__IntPtr page_object, float* phase);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetDashPhase", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetDashPhase(__IntPtr page_object, float phase);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetDashCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetDashCount(__IntPtr page_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetDashArray", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjGetDashArray(__IntPtr page_object, float* dash_array, ulong dash_count);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_SetDashArray", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageObjSetDashArray(__IntPtr page_object, float* dash_array, ulong dash_count, float phase);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_CountSegments", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathCountSegments(__IntPtr path);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_GetPathSegment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPathGetPathSegment(__IntPtr path, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPathSegment_GetPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathSegmentGetPoint(__IntPtr segment, float* x, float* y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPathSegment_GetType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathSegmentGetType(__IntPtr segment);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPathSegment_GetClose", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathSegmentGetClose(__IntPtr segment);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_MoveTo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathMoveTo(__IntPtr path, float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_LineTo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathLineTo(__IntPtr path, float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_BezierTo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathBezierTo(__IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_Close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathClose(__IntPtr path);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_SetDrawMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathSetDrawMode(__IntPtr path, int fillmode, int stroke);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPath_GetDrawMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPathGetDrawMode(__IntPtr path, int* fillmode, int* stroke);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_NewTextObj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjNewTextObj(__IntPtr document, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string font, float font_size);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_SetText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextSetText(__IntPtr text_object, ushort* text);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_SetCharcodes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextSetCharcodes(__IntPtr text_object, uint* charcodes, ulong count);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_LoadFont", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFTextLoadFont(__IntPtr document, byte* data, uint size, int font_type, int cid);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_LoadStandardFont", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFTextLoadStandardFont(__IntPtr document, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string font);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFTextObj_GetFontSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextObjGetFontSize(__IntPtr text, float* size);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_Close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFFontClose(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_CreateTextObj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjCreateTextObj(__IntPtr document, __IntPtr font, float font_size);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFTextObj_GetTextRenderMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextObjGetTextRenderMode(__IntPtr text);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFTextObj_SetTextRenderMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextObjSetTextRenderMode(__IntPtr text, global::PDFiumCore.FPDF_TEXT_RENDERMODE render_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFTextObj_GetText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFTextObjGetText(__IntPtr text_object, __IntPtr text_page, ushort* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFTextObj_GetRenderedBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFTextObjGetRenderedBitmap(__IntPtr document, __IntPtr page, __IntPtr text_object, float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFTextObj_GetFont", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFTextObjGetFont(__IntPtr text);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetFontName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFFontGetFontName(__IntPtr font, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetFontData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetFontData(__IntPtr font, byte* buffer, ulong buflen, ulong* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetIsEmbedded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetIsEmbedded(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetFlags(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetWeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetWeight(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetItalicAngle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetItalicAngle(__IntPtr font, int* angle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetAscent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetAscent(__IntPtr font, float font_size, float* ascent);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetDescent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetDescent(__IntPtr font, float font_size, float* descent);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetGlyphWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFontGetGlyphWidth(__IntPtr font, uint glyph, float font_size, float* width);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFont_GetGlyphPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFFontGetGlyphPath(__IntPtr font, uint glyph, float font_size);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFGlyphPath_CountGlyphSegments", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFGlyphPathCountGlyphSegments(__IntPtr glyphpath);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFGlyphPath_GetGlyphPathSegment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFGlyphPathGetGlyphPathSegment(__IntPtr glyphpath, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFormObj_CountObjects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFFormObjCountObjects(__IntPtr form_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFFormObj_GetObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFFormObjGetObject(__IntPtr form_object, uint index);
        }

        /// <summary>
        /// <para>Create a new PDF document.</para>
        /// <para>Returns a handle to a new document, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_CreateNewDocument()
        {
            var __ret = __Internal.FPDF_CreateNewDocument();
            var __result0 = global::PDFiumCore.FpdfDocumentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Create a new PDF page.</para>
        /// <para>document   - handle to document.</para>
        /// <para>page_index - suggested 0-based index of the page to create. If it is larger</para>
        /// <para>than document's current last index(L), the created page index</para>
        /// <para>is the next available index -- L+1.</para>
        /// <para>width      - the page width in points.</para>
        /// <para>height     - the page height in points.</para>
        /// <para>Returns the handle to the new page or NULL on failure.</para>
        /// <para>The page should be closed with FPDF_ClosePage() when finished as</para>
        /// <para>with any other page in the document.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageT FPDFPageNew(global::PDFiumCore.FpdfDocumentT document, int page_index, double width, double height)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFPageNew(__arg0, page_index, width, height);
            var __result0 = global::PDFiumCore.FpdfPageT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Delete the page at |page_index|.</para>
        /// <para>document   - handle to document.</para>
        /// <para>page_index - the index of the page to delete.</para>
        /// </summary>
        public static void FPDFPageDelete(global::PDFiumCore.FpdfDocumentT document, int page_index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            __Internal.FPDFPageDelete(__arg0, page_index);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Move the given pages to a new index position.</para>
        /// <para>page_indices     - the ordered list of pages to move. No duplicates allowed.</para>
        /// <para>page_indices_len - the number of elements in |page_indices|</para>
        /// <para>dest_page_index  - the new index position to which the pages in</para>
        /// <para>|page_indices| are moved.</para>
        /// <para>Returns TRUE on success. If it returns FALSE, the document may be left in an</para>
        /// <para>indeterminate state.</para>
        /// <para>Example: The PDF document starts out with pages [A, B, C, D], with indices</para>
        /// <para>[0, 1, 2, 3].</para>
        /// <para>Move(doc, [3, 2], 2, 1); // returns true</para>
        /// <para>// The document has pages [A, D, C, B].</para>
        /// <para></para>
        /// <para>Move(doc, [0, 4, 3], 3, 1); // returns false</para>
        /// <para>// Returned false because index 4 is out of range.</para>
        /// <para></para>
        /// <para>Move(doc, [0, 3, 1], 3, 2); // returns false</para>
        /// <para>// Returned false because index 2 is out of range for 3 page indices.</para>
        /// <para></para>
        /// <para>Move(doc, [2, 2], 2, 0); // returns false</para>
        /// <para>// Returned false because [2, 2] contains duplicates.</para>
        /// </summary>
        public static int FPDF_MovePages(global::PDFiumCore.FpdfDocumentT document, ref int page_indices, uint page_indices_len, int dest_page_index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (int* __page_indices1 = &page_indices)
            {
                var __arg1 = __page_indices1;
                var __ret = __Internal.FPDF_MovePages(__arg0, __arg1, page_indices_len, dest_page_index);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the rotation of |page|.</para>
        /// <para>page - handle to a page</para>
        /// <para>Returns one of the following indicating the page rotation:</para>
        /// <para>0 - No rotation.</para>
        /// <para>1 - Rotated 90 degrees clockwise.</para>
        /// <para>2 - Rotated 180 degrees clockwise.</para>
        /// <para>3 - Rotated 270 degrees clockwise.</para>
        /// </summary>
        public static int FPDFPageGetRotation(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetRotation(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set rotation for |page|.</para>
        /// <para>page   - handle to a page.</para>
        /// <para>rotate - the rotation value, one of:</para>
        /// <para>0 - No rotation.</para>
        /// <para>1 - Rotated 90 degrees clockwise.</para>
        /// <para>2 - Rotated 180 degrees clockwise.</para>
        /// <para>3 - Rotated 270 degrees clockwise.</para>
        /// </summary>
        public static void FPDFPageSetRotation(global::PDFiumCore.FpdfPageT page, int rotate)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetRotation(__arg0, rotate);
        }

        /// <summary>
        /// <para>Insert |page_obj| into |page|.</para>
        /// <para>page     - handle to a page</para>
        /// <para>page_obj - handle to a page object. The |page_obj| will be automatically</para>
        /// <para>freed.</para>
        /// </summary>
        public static void FPDFPageInsertObject(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfPageobjectT page_obj)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = page_obj is null ? __IntPtr.Zero : page_obj.__Instance;
            __Internal.FPDFPageInsertObject(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Remove |page_obj| from |page|.</para>
        /// <para>page     - handle to a page</para>
        /// <para>page_obj - handle to a page object to be removed.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>Ownership is transferred to the caller. Call FPDFPageObj_Destroy() to free</para>
        /// <para>it.</para>
        /// </summary>
        public static int FPDFPageRemoveObject(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfPageobjectT page_obj)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = page_obj is null ? __IntPtr.Zero : page_obj.__Instance;
            var __ret = __Internal.FPDFPageRemoveObject(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get number of page objects inside |page|.</para>
        /// <para>page - handle to a page.</para>
        /// <para>Returns the number of objects in |page|.</para>
        /// </summary>
        public static int FPDFPageCountObjects(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageCountObjects(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get object in |page| at |index|.</para>
        /// <para>page  - handle to a page.</para>
        /// <para>index - the index of a page object.</para>
        /// <para>Returns the handle to the page object, or NULL on failed.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageGetObject(global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetObject(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Checks if |page| contains transparency.</para>
        /// <para>page - handle to a page.</para>
        /// <para>Returns TRUE if |page| contains transparency.</para>
        /// </summary>
        public static int FPDFPageHasTransparency(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageHasTransparency(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Generate the content of |page|.</para>
        /// <para>page - handle to a page.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>Before you save the page to a file, or reload the page, you must call</para>
        /// <para>|FPDFPage_GenerateContent| or any changes to |page| will be lost.</para>
        /// </summary>
        public static int FPDFPageGenerateContent(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGenerateContent(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Destroy |page_obj| by releasing its resources. |page_obj| must have been</para>
        /// <para>created by FPDFPageObj_CreateNew{Path|Rect}() or</para>
        /// <para>FPDFPageObj_New{Text|Image}Obj(). This function must be called on</para>
        /// <para>newly-created objects if they are not added to a page through</para>
        /// <para>FPDFPage_InsertObject() or to an annotation through FPDFAnnot_AppendObject().</para>
        /// <para>page_obj - handle to a page object.</para>
        /// </summary>
        public static void FPDFPageObjDestroy(global::PDFiumCore.FpdfPageobjectT page_obj)
        {
            var __arg0 = page_obj is null ? __IntPtr.Zero : page_obj.__Instance;
            __Internal.FPDFPageObjDestroy(__arg0);
        }

        /// <summary>
        /// <para>Checks if |page_object| contains transparency.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns TRUE if |page_object| contains transparency.</para>
        /// </summary>
        public static int FPDFPageObjHasTransparency(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjHasTransparency(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get type of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns one of the FPDF_PAGEOBJ_* values on success, FPDF_PAGEOBJ_UNKNOWN on</para>
        /// <para>error.</para>
        /// </summary>
        public static int FPDFPageObjGetType(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Transform |page_object| by the given matrix.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>a           - matrix value.</para>
        /// <para>b           - matrix value.</para>
        /// <para>c           - matrix value.</para>
        /// <para>d           - matrix value.</para>
        /// <para>e           - matrix value.</para>
        /// <para>f           - matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the |page_object|.</para>
        /// </summary>
        public static void FPDFPageObjTransform(global::PDFiumCore.FpdfPageobjectT page_object, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            __Internal.FPDFPageObjTransform(__arg0, a, b, c, d, e, f);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the transform matrix of a page object.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>matrix      - pointer to struct to receive the matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and used to scale, rotate, shear and translate the page object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetMatrix(global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __arg1 = matrix is null ? __IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFPageObjGetMatrix(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the transform matrix of a page object.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>matrix      - pointer to struct with the matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the page object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjSetMatrix(global::PDFiumCore.FpdfPageobjectT path, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __arg1 = matrix is null ? __IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFPageObjSetMatrix(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Transform all annotations in |page|.</para>
        /// <para>page - handle to a page.</para>
        /// <para>a    - matrix value.</para>
        /// <para>b    - matrix value.</para>
        /// <para>c    - matrix value.</para>
        /// <para>d    - matrix value.</para>
        /// <para>e    - matrix value.</para>
        /// <para>f    - matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the |page| annotations.</para>
        /// </summary>
        public static void FPDFPageTransformAnnots(global::PDFiumCore.FpdfPageT page, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageTransformAnnots(__arg0, a, b, c, d, e, f);
        }

        /// <summary>
        /// <para>Create a new image object.</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns a handle to a new image object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjNewImageObj(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFPageObjNewImageObj(__arg0);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of content marks in |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns the number of content marks in |page_object|, or -1 in case of</para>
        /// <para>failure.</para>
        /// </summary>
        public static int FPDFPageObjCountMarks(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjCountMarks(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get content mark in |page_object| at |index|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>index       - the index of a page object.</para>
        /// <para>Returns the handle to the content mark, or NULL on failure. The handle is</para>
        /// <para>still owned by the library, and it should not be freed directly. It becomes</para>
        /// <para>invalid if the page object is destroyed, either directly or indirectly by</para>
        /// <para>unloading the page.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectmarkT FPDFPageObjGetMark(global::PDFiumCore.FpdfPageobjectT page_object, uint index)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetMark(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfPageobjectmarkT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add a new content mark to a |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>name        - the name (tag) of the mark.</para>
        /// <para>Returns the handle to the content mark, or NULL on failure. The handle is</para>
        /// <para>still owned by the library, and it should not be freed directly. It becomes</para>
        /// <para>invalid if the page object is destroyed, either directly or indirectly by</para>
        /// <para>unloading the page.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectmarkT FPDFPageObjAddMark(global::PDFiumCore.FpdfPageobjectT page_object, string name)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjAddMark(__arg0, name);
            var __result0 = global::PDFiumCore.FpdfPageobjectmarkT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Removes a content |mark| from a |page_object|.</para>
        /// <para>The mark handle will be invalid after the removal.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>mark        - handle to a content mark in that object to remove.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE if it failed.</para>
        /// </summary>
        public static int FPDFPageObjRemoveMark(global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __arg1 = mark is null ? __IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjRemoveMark(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the name of a content mark.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>buffer     - buffer for holding the returned name in UTF-16LE. This is only</para>
        /// <para>modified if |buflen| is longer than the length of the name.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the name. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE if it failed.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetName(global::PDFiumCore.FpdfPageobjectmarkT mark, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = mark is null ? __IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen3 = &out_buflen)
            {
                var __arg3 = __out_buflen3;
                var __ret = __Internal.FPDFPageObjMarkGetName(__arg0, buffer, buflen, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of key/value pair parameters in |mark|.</para>
        /// <para>mark   - handle to a content mark.</para>
        /// <para>Returns the number of key/value pair parameters |mark|, or -1 in case of</para>
        /// <para>failure.</para>
        /// </summary>
        public static int FPDFPageObjMarkCountParams(global::PDFiumCore.FpdfPageobjectmarkT mark)
        {
            var __arg0 = mark is null ? __IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkCountParams(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the key of a property in a content mark.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>index      - index of the property.</para>
        /// <para>buffer     - buffer for holding the returned key in UTF-16LE. This is only</para>
        /// <para>modified if |buflen| is longer than the length of the key.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the key. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the operation was successful, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamKey(global::PDFiumCore.FpdfPageobjectmarkT mark, uint index, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = mark is null ? __IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDFPageObjMarkGetParamKey(__arg0, index, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the type of the value of a property in a content mark by key.</para>
        /// <para>mark   - handle to a content mark.</para>
        /// <para>key    - string key of the property.</para>
        /// <para>Returns the type of the value, or FPDF_OBJECT_UNKNOWN in case of failure.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamValueType(global::PDFiumCore.FpdfPageobjectmarkT mark, string key)
        {
            var __arg0 = mark is null ? __IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkGetParamValueType(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the value of a number property in a content mark by key as int.</para>
        /// <para>FPDFPageObjMark_GetParamValueType() should have returned FPDF_OBJECT_NUMBER</para>
        /// <para>for this property.</para>
        /// <para>mark      - handle to a content mark.</para>
        /// <para>key       - string key of the property.</para>
        /// <para>out_value - pointer to variable that will receive the value. Not filled if</para>
        /// <para>false is returned.</para>
        /// <para>Returns TRUE if the key maps to a number value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamIntValue(global::PDFiumCore.FpdfPageobjectmarkT mark, string key, ref int out_value)
        {
            var __arg0 = mark is null ? __IntPtr.Zero : mark.__Instance;
            fixed (int* __out_value2 = &out_value)
            {
                var __arg2 = __out_value2;
                var __ret = __Internal.FPDFPageObjMarkGetParamIntValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the value of a string property in a content mark by key.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>key        - string key of the property.</para>
        /// <para>buffer     - buffer for holding the returned value in UTF-16LE. This is</para>
        /// <para>only modified if |buflen| is longer than the length of the</para>
        /// <para>value.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the value. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the key maps to a string/blob value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamStringValue(global::PDFiumCore.FpdfPageobjectmarkT mark, string key, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = mark is null ? __IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDFPageObjMarkGetParamStringValue(__arg0, key, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the value of a blob property in a content mark by key.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>key        - string key of the property.</para>
        /// <para>buffer     - buffer for holding the returned value. This is only modified</para>
        /// <para>if |buflen| is at least as long as the length of the value.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the value. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the key maps to a string/blob value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamBlobValue(global::PDFiumCore.FpdfPageobjectmarkT mark, string key, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = mark is null ? __IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDFPageObjMarkGetParamBlobValue(__arg0, key, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the value of an int property in a content mark by key. If a parameter</para>
        /// <para>with key |key| exists, its value is set to |value|. Otherwise, it is added as</para>
        /// <para>a new parameter.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>value       - int value to set.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkSetIntParam(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key, int value)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __arg2 = mark is null ? __IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkSetIntParam(__arg0, __arg1, __arg2, key, value);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the value of a string property in a content mark by key. If a parameter</para>
        /// <para>with key |key| exists, its value is set to |value|. Otherwise, it is added as</para>
        /// <para>a new parameter.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>value       - string value to set.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkSetStringParam(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key, string value)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __arg2 = mark is null ? __IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkSetStringParam(__arg0, __arg1, __arg2, key, value);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the value of a blob property in a content mark by key. If a parameter</para>
        /// <para>with key |key| exists, its value is set to |value|. Otherwise, it is added as</para>
        /// <para>a new parameter.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>value       - pointer to blob value to set.</para>
        /// <para>value_len   - size in bytes of |value|.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkSetBlobParam(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key, __IntPtr value, uint value_len)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __arg2 = mark is null ? __IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkSetBlobParam(__arg0, __arg1, __arg2, key, value, value_len);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Removes a property from a content mark by key.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkRemoveParam(global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __arg1 = mark is null ? __IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkRemoveParam(__arg0, __arg1, key);
            return __ret;
        }

        /// <summary>
        /// <para>Load an image from a JPEG image file and then set it into |image_object|.</para>
        /// <para>pages        - pointer to the start of all loaded pages, may be NULL.</para>
        /// <para>count        - number of |pages|, may be 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>file_access  - file access handler which specifies the JPEG image file.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>The image object might already have an associated image, which is shared and</para>
        /// <para>cached by the loaded pages. In that case, we need to clear the cached image</para>
        /// <para>for all the loaded pages. Pass |pages| and page count (|count|) to this API</para>
        /// <para>to clear the image cache. If the image is not previously shared, or NULL is a</para>
        /// <para>valid |pages| value.</para>
        /// </summary>
        public static int FPDFImageObjLoadJpegFile(global::PDFiumCore.FpdfPageT pages, int count, global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FPDF_FILEACCESS file_access)
        {
            var ____arg0 = pages is null ? __IntPtr.Zero : pages.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg2 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __arg3 = file_access is null ? __IntPtr.Zero : file_access.__Instance;
            var __ret = __Internal.FPDFImageObjLoadJpegFile(__arg0, count, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
        /// <para>Load an image from a JPEG image file and then set it into |image_object|.</para>
        /// <para>pages        - pointer to the start of all loaded pages, may be NULL.</para>
        /// <para>count        - number of |pages|, may be 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>file_access  - file access handler which specifies the JPEG image file.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>The image object might already have an associated image, which is shared and</para>
        /// <para>cached by the loaded pages. In that case, we need to clear the cached image</para>
        /// <para>for all the loaded pages. Pass |pages| and page count (|count|) to this API</para>
        /// <para>to clear the image cache. If the image is not previously shared, or NULL is a</para>
        /// <para>valid |pages| value. This function loads the JPEG image inline, so the image</para>
        /// <para>content is copied to the file. This allows |file_access| and its associated</para>
        /// <para>data to be deleted after this function returns.</para>
        /// </summary>
        public static int FPDFImageObjLoadJpegFileInline(global::PDFiumCore.FpdfPageT pages, int count, global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FPDF_FILEACCESS file_access)
        {
            var ____arg0 = pages is null ? __IntPtr.Zero : pages.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg2 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __arg3 = file_access is null ? __IntPtr.Zero : file_access.__Instance;
            var __ret = __Internal.FPDFImageObjLoadJpegFileInline(__arg0, count, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
        /// <para>TODO(thestig): Start deprecating this once FPDFPageObj_SetMatrix() is stable.</para>
        /// <para>Set the transform matrix of |image_object|.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>a            - matrix value.</para>
        /// <para>b            - matrix value.</para>
        /// <para>c            - matrix value.</para>
        /// <para>d            - matrix value.</para>
        /// <para>e            - matrix value.</para>
        /// <para>f            - matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the |image_object|.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFImageObjSetMatrix(global::PDFiumCore.FpdfPageobjectT image_object, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjSetMatrix(__arg0, a, b, c, d, e, f);
            return __ret;
        }

        /// <summary>
        /// <para>Set |bitmap| to |image_object|.</para>
        /// <para>pages        - pointer to the start of all loaded pages, may be NULL.</para>
        /// <para>count        - number of |pages|, may be 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>bitmap       - handle of the bitmap.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFImageObjSetBitmap(global::PDFiumCore.FpdfPageT pages, int count, global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var ____arg0 = pages is null ? __IntPtr.Zero : pages.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg2 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __arg3 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFImageObjSetBitmap(__arg0, count, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
        /// <para>Get a bitmap rasterization of |image_object|. FPDFImageObj_GetBitmap() only</para>
        /// <para>operates on |image_object| and does not take the associated image mask into</para>
        /// <para>account. It also ignores the matrix for |image_object|.</para>
        /// <para>The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()</para>
        /// <para>must be called on the returned bitmap when it is no longer needed.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>Returns the bitmap.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFImageObjGetBitmap(global::PDFiumCore.FpdfPageobjectT image_object)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetBitmap(__arg0);
            var __result0 = global::PDFiumCore.FpdfBitmapT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get a bitmap rasterization of |image_object| that takes the image mask and</para>
        /// <para>image matrix into account. To render correctly, the caller must provide the</para>
        /// <para>|document| associated with |image_object|. If there is a |page| associated</para>
        /// <para>with |image_object|, the caller should provide that as well.</para>
        /// <para>The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()</para>
        /// <para>must be called on the returned bitmap when it is no longer needed.</para>
        /// <para>document     - handle to a document associated with |image_object|.</para>
        /// <para>page         - handle to an optional page associated with |image_object|.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>Returns the bitmap or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFImageObjGetRenderedBitmap(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfPageobjectT image_object)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg2 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetRenderedBitmap(__arg0, __arg1, __arg2);
            var __result0 = global::PDFiumCore.FpdfBitmapT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the decoded image data of |image_object|. The decoded data is the</para>
        /// <para>uncompressed image data, i.e. the raw image data after having all filters</para>
        /// <para>applied. |buffer| is only modified if |buflen| is longer than the length of</para>
        /// <para>the decoded image data.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>buffer       - buffer for holding the decoded image data.</para>
        /// <para>buflen       - length of the buffer in bytes.</para>
        /// <para>Returns the length of the decoded image data.</para>
        /// </summary>
        public static uint FPDFImageObjGetImageDataDecoded(global::PDFiumCore.FpdfPageobjectT image_object, __IntPtr buffer, uint buflen)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageDataDecoded(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the raw image data of |image_object|. The raw data is the image data as</para>
        /// <para>stored in the PDF without applying any filters. |buffer| is only modified if</para>
        /// <para>|buflen| is longer than the length of the raw image data.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>buffer       - buffer for holding the raw image data.</para>
        /// <para>buflen       - length of the buffer in bytes.</para>
        /// <para>Returns the length of the raw image data.</para>
        /// </summary>
        public static uint FPDFImageObjGetImageDataRaw(global::PDFiumCore.FpdfPageobjectT image_object, __IntPtr buffer, uint buflen)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageDataRaw(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the number of filters (i.e. decoders) of the image in |image_object|.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>Returns the number of |image_object|'s filters.</para>
        /// </summary>
        public static int FPDFImageObjGetImageFilterCount(global::PDFiumCore.FpdfPageobjectT image_object)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageFilterCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get the filter at |index| of |image_object|'s list of filters. Note that the</para>
        /// <para>filters need to be applied in order, i.e. the first filter should be applied</para>
        /// <para>first, then the second, etc. |buffer| is only modified if |buflen| is longer</para>
        /// <para>than the length of the filter string.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>index        - the index of the filter requested.</para>
        /// <para>buffer       - buffer for holding filter string, encoded in UTF-8.</para>
        /// <para>buflen       - length of the buffer.</para>
        /// <para>Returns the length of the filter string.</para>
        /// </summary>
        public static uint FPDFImageObjGetImageFilter(global::PDFiumCore.FpdfPageobjectT image_object, int index, __IntPtr buffer, uint buflen)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageFilter(__arg0, index, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the image metadata of |image_object|, including dimension, DPI, bits per</para>
        /// <para>pixel, and colorspace. If the |image_object| is not an image object or if it</para>
        /// <para>does not have an image, then the return value will be false. Otherwise,</para>
        /// <para>failure to retrieve any specific parameter would result in its value being 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>page         - handle to the page that |image_object| is on. Required for</para>
        /// <para>retrieving the image's bits per pixel and colorspace.</para>
        /// <para>metadata     - receives the image metadata; must not be NULL.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFImageObjGetImageMetadata(global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FPDF_IMAGEOBJ_METADATA metadata)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg2 = metadata is null ? __IntPtr.Zero : metadata.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageMetadata(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the image size in pixels. Faster method to get only image size.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>width        - receives the image width in pixels; must not be NULL.</para>
        /// <para>height       - receives the image height in pixels; must not be NULL.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFImageObjGetImagePixelSize(global::PDFiumCore.FpdfPageobjectT image_object, ref uint width, ref uint height)
        {
            var __arg0 = image_object is null ? __IntPtr.Zero : image_object.__Instance;
            fixed (uint* __width1 = &width)
            {
                var __arg1 = __width1;
                fixed (uint* __height2 = &height)
                {
                    var __arg2 = __height2;
                    var __ret = __Internal.FPDFImageObjGetImagePixelSize(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Create a new path object at an initial position.</para>
        /// <para>x - initial horizontal position.</para>
        /// <para>y - initial vertical position.</para>
        /// <para>Returns a handle to a new path object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjCreateNewPath(float x, float y)
        {
            var __ret = __Internal.FPDFPageObjCreateNewPath(x, y);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Create a closed path consisting of a rectangle.</para>
        /// <para>x - horizontal position for the left boundary of the rectangle.</para>
        /// <para>y - vertical position for the bottom boundary of the rectangle.</para>
        /// <para>w - width of the rectangle.</para>
        /// <para>h - height of the rectangle.</para>
        /// <para>Returns a handle to the new path object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjCreateNewRect(float x, float y, float w, float h)
        {
            var __ret = __Internal.FPDFPageObjCreateNewRect(x, y, w, h);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the bounding box of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>left         - pointer where the left coordinate will be stored</para>
        /// <para>bottom       - pointer where the bottom coordinate will be stored</para>
        /// <para>right        - pointer where the right coordinate will be stored</para>
        /// <para>top          - pointer where the top coordinate will be stored</para>
        /// <para>On success, returns TRUE and fills in the 4 coordinates.</para>
        /// </summary>
        public static int FPDFPageObjGetBounds(global::PDFiumCore.FpdfPageobjectT page_object, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageObjGetBounds(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the quad points that bounds |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>quad_points  - pointer where the quadrilateral points will be stored.</para>
        /// <para>On success, returns TRUE and fills in |quad_points|.</para>
        /// <para>Similar to FPDFPageObj_GetBounds(), this returns the bounds of a page</para>
        /// <para>object. When the object is rotated by a non-multiple of 90 degrees, this API</para>
        /// <para>returns a tighter bound that cannot be represented with just the 4 sides of</para>
        /// <para>a rectangle.</para>
        /// <para>Currently only works the following |page_object| types: FPDF_PAGEOBJ_TEXT and</para>
        /// <para>FPDF_PAGEOBJ_IMAGE.</para>
        /// </summary>
        public static int FPDFPageObjGetRotatedBounds(global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __arg1 = quad_points is null ? __IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFPageObjGetRotatedBounds(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Set the blend mode of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>blend_mode   - string containing the blend mode.</para>
        /// <para>Blend mode can be one of following: Color, ColorBurn, ColorDodge, Darken,</para>
        /// <para>Difference, Exclusion, HardLight, Hue, Lighten, Luminosity, Multiply, Normal,</para>
        /// <para>Overlay, Saturation, Screen, SoftLight</para>
        /// </summary>
        public static void FPDFPageObjSetBlendMode(global::PDFiumCore.FpdfPageobjectT page_object, string blend_mode)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            __Internal.FPDFPageObjSetBlendMode(__arg0, blend_mode);
        }

        /// <summary>
        /// <para>Set the stroke RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component for the object's stroke color.</para>
        /// <para>G            - the green component for the object's stroke color.</para>
        /// <para>B            - the blue component for the object's stroke color.</para>
        /// <para>A            - the stroke alpha for the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjSetStrokeColor(global::PDFiumCore.FpdfPageobjectT page_object, uint R, uint G, uint B, uint A)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetStrokeColor(__arg0, R, G, B, A);
            return __ret;
        }

        /// <summary>
        /// <para>Get the stroke RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component of the path stroke color.</para>
        /// <para>G            - the green component of the object's stroke color.</para>
        /// <para>B            - the blue component of the object's stroke color.</para>
        /// <para>A            - the stroke alpha of the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetStrokeColor(global::PDFiumCore.FpdfPageobjectT page_object, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            fixed (uint* __R1 = &R)
            {
                var __arg1 = __R1;
                fixed (uint* __G2 = &G)
                {
                    var __arg2 = __G2;
                    fixed (uint* __B3 = &B)
                    {
                        var __arg3 = __B3;
                        fixed (uint* __A4 = &A)
                        {
                            var __arg4 = __A4;
                            var __ret = __Internal.FPDFPageObjGetStrokeColor(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Set the stroke width of a page object.</para>
        /// <para>path   - the handle to the page object.</para>
        /// <para>width  - the width of the stroke.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPageObjSetStrokeWidth(global::PDFiumCore.FpdfPageobjectT page_object, float width)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetStrokeWidth(__arg0, width);
            return __ret;
        }

        /// <summary>
        /// <para>Get the stroke width of a page object.</para>
        /// <para>path   - the handle to the page object.</para>
        /// <para>width  - the width of the stroke.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPageObjGetStrokeWidth(global::PDFiumCore.FpdfPageobjectT page_object, ref float width)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            fixed (float* __width1 = &width)
            {
                var __arg1 = __width1;
                var __ret = __Internal.FPDFPageObjGetStrokeWidth(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the line join of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>Returns the line join, or -1 on failure.</para>
        /// <para>Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,</para>
        /// <para>FPDF_LINEJOIN_BEVEL</para>
        /// </summary>
        public static int FPDFPageObjGetLineJoin(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetLineJoin(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the line join of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>line_join    - line join</para>
        /// <para>Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,</para>
        /// <para>FPDF_LINEJOIN_BEVEL</para>
        /// </summary>
        public static int FPDFPageObjSetLineJoin(global::PDFiumCore.FpdfPageobjectT page_object, int line_join)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetLineJoin(__arg0, line_join);
            return __ret;
        }

        /// <summary>
        /// <para>Get the line cap of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns the line cap, or -1 on failure.</para>
        /// <para>Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,</para>
        /// <para>FPDF_LINECAP_PROJECTING_SQUARE</para>
        /// </summary>
        public static int FPDFPageObjGetLineCap(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetLineCap(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the line cap of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>line_cap    - line cap</para>
        /// <para>Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,</para>
        /// <para>FPDF_LINECAP_PROJECTING_SQUARE</para>
        /// </summary>
        public static int FPDFPageObjSetLineCap(global::PDFiumCore.FpdfPageobjectT page_object, int line_cap)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetLineCap(__arg0, line_cap);
            return __ret;
        }

        /// <summary>
        /// <para>Set the fill RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component for the object's fill color.</para>
        /// <para>G            - the green component for the object's fill color.</para>
        /// <para>B            - the blue component for the object's fill color.</para>
        /// <para>A            - the fill alpha for the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjSetFillColor(global::PDFiumCore.FpdfPageobjectT page_object, uint R, uint G, uint B, uint A)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetFillColor(__arg0, R, G, B, A);
            return __ret;
        }

        /// <summary>
        /// <para>Get the fill RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component of the object's fill color.</para>
        /// <para>G            - the green component of the object's fill color.</para>
        /// <para>B            - the blue component of the object's fill color.</para>
        /// <para>A            - the fill alpha of the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetFillColor(global::PDFiumCore.FpdfPageobjectT page_object, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            fixed (uint* __R1 = &R)
            {
                var __arg1 = __R1;
                fixed (uint* __G2 = &G)
                {
                    var __arg2 = __G2;
                    fixed (uint* __B3 = &B)
                    {
                        var __arg3 = __B3;
                        fixed (uint* __A4 = &A)
                        {
                            var __arg4 = __A4;
                            var __ret = __Internal.FPDFPageObjGetFillColor(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the line dash |phase| of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>phase - pointer where the dashing phase will be stored.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetDashPhase(global::PDFiumCore.FpdfPageobjectT page_object, ref float phase)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            fixed (float* __phase1 = &phase)
            {
                var __arg1 = __phase1;
                var __ret = __Internal.FPDFPageObjGetDashPhase(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the line dash phase of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>phase - line dash phase.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjSetDashPhase(global::PDFiumCore.FpdfPageobjectT page_object, float phase)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetDashPhase(__arg0, phase);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the line dash array of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns the line dash array size or -1 on failure.</para>
        /// </summary>
        public static int FPDFPageObjGetDashCount(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetDashCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the line dash array of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>dash_array - pointer where the dashing array will be stored.</para>
        /// <para>dash_count - number of elements in |dash_array|.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetDashArray(global::PDFiumCore.FpdfPageobjectT page_object, ref float dash_array, ulong dash_count)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            fixed (float* __dash_array1 = &dash_array)
            {
                var __arg1 = __dash_array1;
                var __ret = __Internal.FPDFPageObjGetDashArray(__arg0, __arg1, dash_count);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the line dash array of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>dash_array - the dash array.</para>
        /// <para>dash_count - number of elements in |dash_array|.</para>
        /// <para>phase - the line dash phase.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjSetDashArray(global::PDFiumCore.FpdfPageobjectT page_object, ref float dash_array, ulong dash_count, float phase)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            fixed (float* __dash_array1 = &dash_array)
            {
                var __arg1 = __dash_array1;
                var __ret = __Internal.FPDFPageObjSetDashArray(__arg0, __arg1, dash_count, phase);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get number of segments inside |path|.</para>
        /// <para>path - handle to a path.</para>
        /// <para>A segment is a command, created by e.g. FPDFPath_MoveTo(),</para>
        /// <para>FPDFPath_LineTo() or FPDFPath_BezierTo().</para>
        /// <para>Returns the number of objects in |path| or -1 on failure.</para>
        /// </summary>
        public static int FPDFPathCountSegments(global::PDFiumCore.FpdfPageobjectT path)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathCountSegments(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get segment in |path| at |index|.</para>
        /// <para>path  - handle to a path.</para>
        /// <para>index - the index of a segment.</para>
        /// <para>Returns the handle to the segment, or NULL on faiure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPathsegmentT FPDFPathGetPathSegment(global::PDFiumCore.FpdfPageobjectT path, int index)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathGetPathSegment(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfPathsegmentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get coordinates of |segment|.</para>
        /// <para>segment  - handle to a segment.</para>
        /// <para>x      - the horizontal position of the segment.</para>
        /// <para>y      - the vertical position of the segment.</para>
        /// <para>Returns TRUE on success, otherwise |x| and |y| is not set.</para>
        /// </summary>
        public static int FPDFPathSegmentGetPoint(global::PDFiumCore.FpdfPathsegmentT segment, ref float x, ref float y)
        {
            var __arg0 = segment is null ? __IntPtr.Zero : segment.__Instance;
            fixed (float* __x1 = &x)
            {
                var __arg1 = __x1;
                fixed (float* __y2 = &y)
                {
                    var __arg2 = __y2;
                    var __ret = __Internal.FPDFPathSegmentGetPoint(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Get type of |segment|.</para>
        /// <para>segment - handle to a segment.</para>
        /// <para>Returns one of the FPDF_SEGMENT_* values on success,</para>
        /// <para>FPDF_SEGMENT_UNKNOWN on error.</para>
        /// </summary>
        public static int FPDFPathSegmentGetType(global::PDFiumCore.FpdfPathsegmentT segment)
        {
            var __arg0 = segment is null ? __IntPtr.Zero : segment.__Instance;
            var __ret = __Internal.FPDFPathSegmentGetType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Gets if the |segment| closes the current subpath of a given path.</para>
        /// <para>segment - handle to a segment.</para>
        /// <para>Returns close flag for non-NULL segment, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPathSegmentGetClose(global::PDFiumCore.FpdfPathsegmentT segment)
        {
            var __arg0 = segment is null ? __IntPtr.Zero : segment.__Instance;
            var __ret = __Internal.FPDFPathSegmentGetClose(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Move a path's current point.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>x      - the horizontal position of the new current point.</para>
        /// <para>y      - the vertical position of the new current point.</para>
        /// <para>Note that no line will be created between the previous current point and the</para>
        /// <para>new one.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathMoveTo(global::PDFiumCore.FpdfPageobjectT path, float x, float y)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathMoveTo(__arg0, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>Add a line between the current point and a new point in the path.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>x      - the horizontal position of the new point.</para>
        /// <para>y      - the vertical position of the new point.</para>
        /// <para>The path's current point is changed to (x, y).</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathLineTo(global::PDFiumCore.FpdfPageobjectT path, float x, float y)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathLineTo(__arg0, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>Add a cubic Bezier curve to the given path, starting at the current point.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>x1     - the horizontal position of the first Bezier control point.</para>
        /// <para>y1     - the vertical position of the first Bezier control point.</para>
        /// <para>x2     - the horizontal position of the second Bezier control point.</para>
        /// <para>y2     - the vertical position of the second Bezier control point.</para>
        /// <para>x3     - the horizontal position of the ending point of the Bezier curve.</para>
        /// <para>y3     - the vertical position of the ending point of the Bezier curve.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathBezierTo(global::PDFiumCore.FpdfPageobjectT path, float x1, float y1, float x2, float y2, float x3, float y3)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathBezierTo(__arg0, x1, y1, x2, y2, x3, y3);
            return __ret;
        }

        /// <summary>
        /// <para>Close the current subpath of a given path.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>This will add a line between the current point and the initial point of the</para>
        /// <para>subpath, thus terminating the current subpath.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathClose(global::PDFiumCore.FpdfPageobjectT path)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathClose(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the drawing mode of a path.</para>
        /// <para>path     - the handle to the path object.</para>
        /// <para>fillmode - the filling mode to be set: one of the FPDF_FILLMODE_* flags.</para>
        /// <para>stroke   - a boolean specifying if the path should be stroked or not.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathSetDrawMode(global::PDFiumCore.FpdfPageobjectT path, int fillmode, int stroke)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathSetDrawMode(__arg0, fillmode, stroke);
            return __ret;
        }

        /// <summary>
        /// <para>Get the drawing mode of a path.</para>
        /// <para>path     - the handle to the path object.</para>
        /// <para>fillmode - the filling mode of the path: one of the FPDF_FILLMODE_* flags.</para>
        /// <para>stroke   - a boolean specifying if the path is stroked or not.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathGetDrawMode(global::PDFiumCore.FpdfPageobjectT path, ref int fillmode, ref int stroke)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            fixed (int* __fillmode1 = &fillmode)
            {
                var __arg1 = __fillmode1;
                fixed (int* __stroke2 = &stroke)
                {
                    var __arg2 = __stroke2;
                    var __ret = __Internal.FPDFPathGetDrawMode(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Create a new text object using one of the standard PDF fonts.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>font       - string containing the font name, without spaces.</para>
        /// <para>font_size  - the font size for the new text object.</para>
        /// <para>Returns a handle to a new text object, or NULL on failure</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjNewTextObj(global::PDFiumCore.FpdfDocumentT document, string font, float font_size)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFPageObjNewTextObj(__arg0, font, font_size);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Set the text for a text object. If it had text, it will be replaced.</para>
        /// <para>text_object  - handle to the text object.</para>
        /// <para>text         - the UTF-16LE encoded string containing the text to be added.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFTextSetText(global::PDFiumCore.FpdfPageobjectT text_object, ref ushort text)
        {
            var __arg0 = text_object is null ? __IntPtr.Zero : text_object.__Instance;
            fixed (ushort* __text1 = &text)
            {
                var __arg1 = __text1;
                var __ret = __Internal.FPDFTextSetText(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the text using charcodes for a text object. If it had text, it will be</para>
        /// <para>replaced.</para>
        /// <para>text_object  - handle to the text object.</para>
        /// <para>charcodes    - pointer to an array of charcodes to be added.</para>
        /// <para>count        - number of elements in |charcodes|.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFTextSetCharcodes(global::PDFiumCore.FpdfPageobjectT text_object, ref uint charcodes, ulong count)
        {
            var __arg0 = text_object is null ? __IntPtr.Zero : text_object.__Instance;
            fixed (uint* __charcodes1 = &charcodes)
            {
                var __arg1 = __charcodes1;
                var __ret = __Internal.FPDFTextSetCharcodes(__arg0, __arg1, count);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a font object loaded from a stream of data. The font is loaded</para>
        /// <para>into the document.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>data       - the stream of data, which will be copied by the font object.</para>
        /// <para>size       - size of the stream, in bytes.</para>
        /// <para>font_type  - FPDF_FONT_TYPE1 or FPDF_FONT_TRUETYPE depending on the font</para>
        /// <para>type.</para>
        /// <para>cid        - a boolean specifying if the font is a CID font or not.</para>
        /// <para>The loaded font can be closed using FPDFFont_Close.</para>
        /// <para>Returns NULL on failure</para>
        /// </summary>
        public static global::PDFiumCore.FpdfFontT FPDFTextLoadFont(global::PDFiumCore.FpdfDocumentT document, byte* data, uint size, int font_type, int cid)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFTextLoadFont(__arg0, data, size, font_type, cid);
            var __result0 = global::PDFiumCore.FpdfFontT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Loads one of the standard 14 fonts per PDF spec 1.7 page 416. The preferred</para>
        /// <para>way of using font style is using a dash to separate the name from the style,</para>
        /// <para>for example 'Helvetica-BoldItalic'.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>font       - string containing the font name, without spaces.</para>
        /// <para>The loaded font can be closed using FPDFFont_Close.</para>
        /// <para>Returns NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfFontT FPDFTextLoadStandardFont(global::PDFiumCore.FpdfDocumentT document, string font)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFTextLoadStandardFont(__arg0, font);
            var __result0 = global::PDFiumCore.FpdfFontT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the font size of a text object.</para>
        /// <para>text - handle to a text.</para>
        /// <para>size - pointer to the font size of the text object, measured in points</para>
        /// <para>(about 1/72 inch)</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFTextObjGetFontSize(global::PDFiumCore.FpdfPageobjectT text, ref float size)
        {
            var __arg0 = text is null ? __IntPtr.Zero : text.__Instance;
            fixed (float* __size1 = &size)
            {
                var __arg1 = __size1;
                var __ret = __Internal.FPDFTextObjGetFontSize(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Close a loaded PDF font.</para>
        /// <para>font   - Handle to the loaded font.</para>
        /// </summary>
        public static void FPDFFontClose(global::PDFiumCore.FpdfFontT font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.FPDFFontClose(__arg0);
        }

        /// <summary>
        /// <para>Create a new text object using a loaded font.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>font       - handle to the font object.</para>
        /// <para>font_size  - the font size for the new text object.</para>
        /// <para>Returns a handle to a new text object, or NULL on failure</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjCreateTextObj(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfFontT font, float font_size)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            var __ret = __Internal.FPDFPageObjCreateTextObj(__arg0, __arg1, font_size);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the text rendering mode of a text object.</para>
        /// <para>text     - the handle to the text object.</para>
        /// <para>Returns one of the known FPDF_TEXT_RENDERMODE enum values on success,</para>
        /// <para>FPDF_TEXTRENDERMODE_UNKNOWN on error.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextObjGetTextRenderMode(global::PDFiumCore.FpdfPageobjectT text)
        {
            var __arg0 = text is null ? __IntPtr.Zero : text.__Instance;
            var __ret = __Internal.FPDFTextObjGetTextRenderMode(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the text rendering mode of a text object.</para>
        /// <para>text         - the handle to the text object.</para>
        /// <para>render_mode  - the FPDF_TEXT_RENDERMODE enum value to be set (cannot set to</para>
        /// <para>FPDF_TEXTRENDERMODE_UNKNOWN).</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFTextObjSetTextRenderMode(global::PDFiumCore.FpdfPageobjectT text, global::PDFiumCore.FPDF_TEXT_RENDERMODE render_mode)
        {
            var __arg0 = text is null ? __IntPtr.Zero : text.__Instance;
            var __ret = __Internal.FPDFTextObjSetTextRenderMode(__arg0, render_mode);
            return __ret;
        }

        /// <summary>
        /// <para>Get the text of a text object.</para>
        /// <para>text_object      - the handle to the text object.</para>
        /// <para>text_page        - the handle to the text page.</para>
        /// <para>buffer           - the address of a buffer that receives the text.</para>
        /// <para>length           - the size, in bytes, of |buffer|.</para>
        /// <para>Returns the number of bytes in the text (including the trailing NUL</para>
        /// <para>character) on success, 0 on error.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-16LE encoding.</para>
        /// <para>If |length| is less than the returned length, or |buffer| is NULL, |buffer|</para>
        /// <para>will not be modified.</para>
        /// </summary>
        public static uint FPDFTextObjGetText(global::PDFiumCore.FpdfPageobjectT text_object, global::PDFiumCore.FpdfTextpageT text_page, ref ushort buffer, uint length)
        {
            var __arg0 = text_object is null ? __IntPtr.Zero : text_object.__Instance;
            var __arg1 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFTextObjGetText(__arg0, __arg1, __arg2, length);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get a bitmap rasterization of |text_object|. To render correctly, the caller</para>
        /// <para>must provide the |document| associated with |text_object|. If there is a</para>
        /// <para>|page| associated with |text_object|, the caller should provide that as well.</para>
        /// <para>The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()</para>
        /// <para>must be called on the returned bitmap when it is no longer needed.</para>
        /// <para>document    - handle to a document associated with |text_object|.</para>
        /// <para>page        - handle to an optional page associated with |text_object|.</para>
        /// <para>text_object - handle to a text object.</para>
        /// <para>scale       - the scaling factor, which must be greater than 0.</para>
        /// <para>Returns the bitmap or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFTextObjGetRenderedBitmap(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfPageobjectT text_object, float scale)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg2 = text_object is null ? __IntPtr.Zero : text_object.__Instance;
            var __ret = __Internal.FPDFTextObjGetRenderedBitmap(__arg0, __arg1, __arg2, scale);
            var __result0 = global::PDFiumCore.FpdfBitmapT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the font of a text object.</para>
        /// <para>text - the handle to the text object.</para>
        /// <para>Returns a handle to the font object held by |text| which retains ownership.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfFontT FPDFTextObjGetFont(global::PDFiumCore.FpdfPageobjectT text)
        {
            var __arg0 = text is null ? __IntPtr.Zero : text.__Instance;
            var __ret = __Internal.FPDFTextObjGetFont(__arg0);
            var __result0 = global::PDFiumCore.FpdfFontT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the font name of a font.</para>
        /// <para>font   - the handle to the font object.</para>
        /// <para>buffer - the address of a buffer that receives the font name.</para>
        /// <para>length - the size, in bytes, of |buffer|.</para>
        /// <para>Returns the number of bytes in the font name (including the trailing NUL</para>
        /// <para>character) on success, 0 on error.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-8 encoding.</para>
        /// <para>If |length| is less than the returned length, or |buffer| is NULL, |buffer|</para>
        /// <para>will not be modified.</para>
        /// </summary>
        public static uint FPDFFontGetFontName(global::PDFiumCore.FpdfFontT font, sbyte* buffer, uint length)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __ret = __Internal.FPDFFontGetFontName(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the decoded data from the |font| object.</para>
        /// <para>font       - The handle to the font object. (Required)</para>
        /// <para>buffer     - The address of a buffer that receives the font data.</para>
        /// <para>buflen     - Length of the buffer.</para>
        /// <para>out_buflen - Pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the font data. Not filled if the return value is</para>
        /// <para>FALSE. (Required)</para>
        /// <para>Returns TRUE on success. In which case, |out_buflen| will be filled, and</para>
        /// <para>|buffer| will be filled if it is large enough. Returns FALSE if any of the</para>
        /// <para>required parameters are null.</para>
        /// <para>The decoded data is the uncompressed font data. i.e. the raw font data after</para>
        /// <para>having all stream filters applied, when the data is embedded.</para>
        /// <para>If the font is not embedded, then this API will instead return the data for</para>
        /// <para>the substitution font it is using.</para>
        /// </summary>
        public static int FPDFFontGetFontData(global::PDFiumCore.FpdfFontT font, byte* buffer, ulong buflen, ref ulong out_buflen)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (ulong* __out_buflen3 = &out_buflen)
            {
                var __arg3 = __out_buflen3;
                var __ret = __Internal.FPDFFontGetFontData(__arg0, buffer, buflen, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get whether |font| is embedded or not.</para>
        /// <para>font - the handle to the font object.</para>
        /// <para>Returns 1 if the font is embedded, 0 if it not, and -1 on failure.</para>
        /// </summary>
        public static int FPDFFontGetIsEmbedded(global::PDFiumCore.FpdfFontT font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __ret = __Internal.FPDFFontGetIsEmbedded(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the descriptor flags of a font.</para>
        /// <para>font - the handle to the font object.</para>
        /// <para>Returns the bit flags specifying various characteristics of the font as</para>
        /// <para>defined in ISO 32000-1:2008, table 123, -1 on failure.</para>
        /// </summary>
        public static int FPDFFontGetFlags(global::PDFiumCore.FpdfFontT font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __ret = __Internal.FPDFFontGetFlags(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the font weight of a font.</para>
        /// <para>font - the handle to the font object.</para>
        /// <para>Returns the font weight, -1 on failure.</para>
        /// <para>Typical values are 400 (normal) and 700 (bold).</para>
        /// </summary>
        public static int FPDFFontGetWeight(global::PDFiumCore.FpdfFontT font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __ret = __Internal.FPDFFontGetWeight(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the italic angle of a font.</para>
        /// <para>font  - the handle to the font object.</para>
        /// <para>angle - pointer where the italic angle will be stored</para>
        /// <para>The italic angle of a |font| is defined as degrees counterclockwise</para>
        /// <para>from vertical. For a font that slopes to the right, this will be negative.</para>
        /// <para>Returns TRUE on success; |angle| unmodified on failure.</para>
        /// </summary>
        public static int FPDFFontGetItalicAngle(global::PDFiumCore.FpdfFontT font, ref int angle)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (int* __angle1 = &angle)
            {
                var __arg1 = __angle1;
                var __ret = __Internal.FPDFFontGetItalicAngle(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get ascent distance of a font.</para>
        /// <para>font       - the handle to the font object.</para>
        /// <para>font_size  - the size of the |font|.</para>
        /// <para>ascent     - pointer where the font ascent will be stored</para>
        /// <para>Ascent is the maximum distance in points above the baseline reached by the</para>
        /// <para>glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm).</para>
        /// <para>Returns TRUE on success; |ascent| unmodified on failure.</para>
        /// </summary>
        public static int FPDFFontGetAscent(global::PDFiumCore.FpdfFontT font, float font_size, ref float ascent)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (float* __ascent2 = &ascent)
            {
                var __arg2 = __ascent2;
                var __ret = __Internal.FPDFFontGetAscent(__arg0, font_size, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get descent distance of a font.</para>
        /// <para>font       - the handle to the font object.</para>
        /// <para>font_size  - the size of the |font|.</para>
        /// <para>descent    - pointer where the font descent will be stored</para>
        /// <para>Descent is the maximum distance in points below the baseline reached by the</para>
        /// <para>glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm).</para>
        /// <para>Returns TRUE on success; |descent| unmodified on failure.</para>
        /// </summary>
        public static int FPDFFontGetDescent(global::PDFiumCore.FpdfFontT font, float font_size, ref float descent)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (float* __descent2 = &descent)
            {
                var __arg2 = __descent2;
                var __ret = __Internal.FPDFFontGetDescent(__arg0, font_size, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the width of a glyph in a font.</para>
        /// <para>font       - the handle to the font object.</para>
        /// <para>glyph      - the glyph.</para>
        /// <para>font_size  - the size of the font.</para>
        /// <para>width      - pointer where the glyph width will be stored</para>
        /// <para>Glyph width is the distance from the end of the prior glyph to the next</para>
        /// <para>glyph. This will be the vertical distance for vertical writing.</para>
        /// <para>Returns TRUE on success; |width| unmodified on failure.</para>
        /// </summary>
        public static int FPDFFontGetGlyphWidth(global::PDFiumCore.FpdfFontT font, uint glyph, float font_size, ref float width)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (float* __width3 = &width)
            {
                var __arg3 = __width3;
                var __ret = __Internal.FPDFFontGetGlyphWidth(__arg0, glyph, font_size, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the glyphpath describing how to draw a font glyph.</para>
        /// <para>font       - the handle to the font object.</para>
        /// <para>glyph      - the glyph being drawn.</para>
        /// <para>font_size  - the size of the font.</para>
        /// <para>Returns the handle to the segment, or NULL on faiure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfGlyphpathT FPDFFontGetGlyphPath(global::PDFiumCore.FpdfFontT font, uint glyph, float font_size)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __ret = __Internal.FPDFFontGetGlyphPath(__arg0, glyph, font_size);
            var __result0 = global::PDFiumCore.FpdfGlyphpathT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of segments inside glyphpath.</para>
        /// <para>glyphpath - handle to a glyph path.</para>
        /// <para>Returns the number of objects in |glyphpath| or -1 on failure.</para>
        /// </summary>
        public static int FPDFGlyphPathCountGlyphSegments(global::PDFiumCore.FpdfGlyphpathT glyphpath)
        {
            var __arg0 = glyphpath is null ? __IntPtr.Zero : glyphpath.__Instance;
            var __ret = __Internal.FPDFGlyphPathCountGlyphSegments(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get segment in glyphpath at index.</para>
        /// <para>glyphpath  - handle to a glyph path.</para>
        /// <para>index      - the index of a segment.</para>
        /// <para>Returns the handle to the segment, or NULL on faiure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPathsegmentT FPDFGlyphPathGetGlyphPathSegment(global::PDFiumCore.FpdfGlyphpathT glyphpath, int index)
        {
            var __arg0 = glyphpath is null ? __IntPtr.Zero : glyphpath.__Instance;
            var __ret = __Internal.FPDFGlyphPathGetGlyphPathSegment(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfPathsegmentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get number of page objects inside |form_object|.</para>
        /// <para>form_object - handle to a form object.</para>
        /// <para>Returns the number of objects in |form_object| on success, -1 on error.</para>
        /// </summary>
        public static int FPDFFormObjCountObjects(global::PDFiumCore.FpdfPageobjectT form_object)
        {
            var __arg0 = form_object is null ? __IntPtr.Zero : form_object.__Instance;
            var __ret = __Internal.FPDFFormObjCountObjects(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get page object in |form_object| at |index|.</para>
        /// <para>form_object - handle to a form object.</para>
        /// <para>index       - the 0-based index of a page object.</para>
        /// <para>Returns the handle to the page object, or NULL on error.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFFormObjGetObject(global::PDFiumCore.FpdfPageobjectT form_object, uint index)
        {
            var __arg0 = form_object is null ? __IntPtr.Zero : form_object.__Instance;
            var __ret = __Internal.FPDFFormObjGetObject(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }
    }

    public unsafe partial class fpdf_flatten
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_Flatten", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageFlatten(__IntPtr page, int nFlag);
        }

        /// <summary>
        /// <para>Flatten annotations and form fields into the page contents.</para>
        /// <para>page  - handle to the page.</para>
        /// <para>nFlag - One of the |FLAT_*| values denoting the page usage.</para>
        /// <para>Returns one of the |FLATTEN_*| values.</para>
        /// <para>Currently, all failures return |FLATTEN_FAIL| with no indication of the</para>
        /// <para>cause.</para>
        /// </summary>
        public static int FPDFPageFlatten(global::PDFiumCore.FpdfPageT page, int nFlag)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageFlatten(__arg0, nFlag);
            return __ret;
        }
    }

    [Flags]
    public enum FWL_EVENTFLAG
    {
        FWL_EVENTFLAG_ShiftKey = 1,
        FWL_EVENTFLAG_ControlKey = 2,
        FWL_EVENTFLAG_AltKey = 4,
        FWL_EVENTFLAG_MetaKey = 8,
        FWL_EVENTFLAG_KeyPad = 16,
        FWL_EVENTFLAG_AutoRepeat = 32,
        FWL_EVENTFLAG_LeftButtonDown = 64,
        FWL_EVENTFLAG_MiddleButtonDown = 128,
        FWL_EVENTFLAG_RightButtonDown = 256
    }

    public enum FWL_VKEYCODE
    {
        FWL_VKEY_Back = 8,
        FWL_VKEY_Tab = 9,
        FWL_VKEY_NewLine = 10,
        FWL_VKEY_Clear = 12,
        FWL_VKEY_Return = 13,
        FWL_VKEY_Shift = 16,
        FWL_VKEY_Control = 17,
        FWL_VKEY_Menu = 18,
        FWL_VKEY_Pause = 19,
        FWL_VKEY_Capital = 20,
        FWL_VKEY_Kana = 21,
        FWL_VKEY_Hangul = 21,
        FWL_VKEY_Junja = 23,
        FWL_VKEY_Final = 24,
        FWL_VKEY_Hanja = 25,
        FWL_VKEY_Kanji = 25,
        FWL_VKEY_Escape = 27,
        FWL_VKEY_Convert = 28,
        FWL_VKEY_NonConvert = 29,
        FWL_VKEY_Accept = 30,
        FWL_VKEY_ModeChange = 31,
        FWL_VKEY_Space = 32,
        FWL_VKEY_Prior = 33,
        FWL_VKEY_Next = 34,
        FWL_VKEY_End = 35,
        FWL_VKEY_Home = 36,
        FWL_VKEY_Left = 37,
        FWL_VKEY_Up = 38,
        FWL_VKEY_Right = 39,
        FWL_VKEY_Down = 40,
        FWL_VKEY_Select = 41,
        FWL_VKEY_Print = 42,
        FWL_VKEY_Execute = 43,
        FWL_VKEY_Snapshot = 44,
        FWL_VKEY_Insert = 45,
        FWL_VKEY_Delete = 46,
        FWL_VKEY_Help = 47,
        FWL_VKEY_0 = 48,
        FWL_VKEY_1 = 49,
        FWL_VKEY_2 = 50,
        FWL_VKEY_3 = 51,
        FWL_VKEY_4 = 52,
        FWL_VKEY_5 = 53,
        FWL_VKEY_6 = 54,
        FWL_VKEY_7 = 55,
        FWL_VKEY_8 = 56,
        FWL_VKEY_9 = 57,
        FWL_VKEY_A = 65,
        FWL_VKEY_B = 66,
        FWL_VKEY_C = 67,
        FWL_VKEY_D = 68,
        FWL_VKEY_E = 69,
        FWL_VKEY_F = 70,
        FWL_VKEY_G = 71,
        FWL_VKEY_H = 72,
        FWL_VKEY_I = 73,
        FWL_VKEY_J = 74,
        FWL_VKEY_K = 75,
        FWL_VKEY_L = 76,
        FWL_VKEY_M = 77,
        FWL_VKEY_N = 78,
        FWL_VKEY_O = 79,
        FWL_VKEY_P = 80,
        FWL_VKEY_Q = 81,
        FWL_VKEY_R = 82,
        FWL_VKEY_S = 83,
        FWL_VKEY_T = 84,
        FWL_VKEY_U = 85,
        FWL_VKEY_V = 86,
        FWL_VKEY_W = 87,
        FWL_VKEY_X = 88,
        FWL_VKEY_Y = 89,
        FWL_VKEY_Z = 90,
        FWL_VKEY_LWin = 91,
        FWL_VKEY_Command = 91,
        FWL_VKEY_RWin = 92,
        FWL_VKEY_Apps = 93,
        FWL_VKEY_Sleep = 95,
        FWL_VKEY_NumPad0 = 96,
        FWL_VKEY_NumPad1 = 97,
        FWL_VKEY_NumPad2 = 98,
        FWL_VKEY_NumPad3 = 99,
        FWL_VKEY_NumPad4 = 100,
        FWL_VKEY_NumPad5 = 101,
        FWL_VKEY_NumPad6 = 102,
        FWL_VKEY_NumPad7 = 103,
        FWL_VKEY_NumPad8 = 104,
        FWL_VKEY_NumPad9 = 105,
        FWL_VKEY_Multiply = 106,
        FWL_VKEY_Add = 107,
        FWL_VKEY_Separator = 108,
        FWL_VKEY_Subtract = 109,
        FWL_VKEY_Decimal = 110,
        FWL_VKEY_Divide = 111,
        FWL_VKEY_F1 = 112,
        FWL_VKEY_F2 = 113,
        FWL_VKEY_F3 = 114,
        FWL_VKEY_F4 = 115,
        FWL_VKEY_F5 = 116,
        FWL_VKEY_F6 = 117,
        FWL_VKEY_F7 = 118,
        FWL_VKEY_F8 = 119,
        FWL_VKEY_F9 = 120,
        FWL_VKEY_F10 = 121,
        FWL_VKEY_F11 = 122,
        FWL_VKEY_F12 = 123,
        FWL_VKEY_F13 = 124,
        FWL_VKEY_F14 = 125,
        FWL_VKEY_F15 = 126,
        FWL_VKEY_F16 = 127,
        FWL_VKEY_F17 = 128,
        FWL_VKEY_F18 = 129,
        FWL_VKEY_F19 = 130,
        FWL_VKEY_F20 = 131,
        FWL_VKEY_F21 = 132,
        FWL_VKEY_F22 = 133,
        FWL_VKEY_F23 = 134,
        FWL_VKEY_F24 = 135,
        FWL_VKEY_NunLock = 144,
        FWL_VKEY_Scroll = 145,
        FWL_VKEY_LShift = 160,
        FWL_VKEY_RShift = 161,
        FWL_VKEY_LControl = 162,
        FWL_VKEY_RControl = 163,
        FWL_VKEY_LMenu = 164,
        FWL_VKEY_RMenu = 165,
        FWL_VKEY_BROWSER_Back = 166,
        FWL_VKEY_BROWSER_Forward = 167,
        FWL_VKEY_BROWSER_Refresh = 168,
        FWL_VKEY_BROWSER_Stop = 169,
        FWL_VKEY_BROWSER_Search = 170,
        FWL_VKEY_BROWSER_Favorites = 171,
        FWL_VKEY_BROWSER_Home = 172,
        FWL_VKEY_VOLUME_Mute = 173,
        FWL_VKEY_VOLUME_Down = 174,
        FWL_VKEY_VOLUME_Up = 175,
        FWL_VKEY_MEDIA_NEXT_Track = 176,
        FWL_VKEY_MEDIA_PREV_Track = 177,
        FWL_VKEY_MEDIA_Stop = 178,
        FWL_VKEY_MEDIA_PLAY_Pause = 179,
        FWL_VKEY_MEDIA_LAUNCH_Mail = 180,
        FWL_VKEY_MEDIA_LAUNCH_MEDIA_Select = 181,
        FWL_VKEY_MEDIA_LAUNCH_APP1 = 182,
        FWL_VKEY_MEDIA_LAUNCH_APP2 = 183,
        FWL_VKEY_OEM_1 = 186,
        FWL_VKEY_OEM_Plus = 187,
        FWL_VKEY_OEM_Comma = 188,
        FWL_VKEY_OEM_Minus = 189,
        FWL_VKEY_OEM_Period = 190,
        FWL_VKEY_OEM_2 = 191,
        FWL_VKEY_OEM_3 = 192,
        FWL_VKEY_OEM_4 = 219,
        FWL_VKEY_OEM_5 = 220,
        FWL_VKEY_OEM_6 = 221,
        FWL_VKEY_OEM_7 = 222,
        FWL_VKEY_OEM_8 = 223,
        FWL_VKEY_OEM_102 = 226,
        FWL_VKEY_ProcessKey = 229,
        FWL_VKEY_Packet = 231,
        FWL_VKEY_Attn = 246,
        FWL_VKEY_Crsel = 247,
        FWL_VKEY_Exsel = 248,
        FWL_VKEY_Ereof = 249,
        FWL_VKEY_Play = 250,
        FWL_VKEY_Zoom = 251,
        FWL_VKEY_NoName = 252,
        FWL_VKEY_PA1 = 253,
        FWL_VKEY_OEM_Clear = 254,
        FWL_VKEY_Unknown = 0
    }

    public unsafe partial class fpdf_javascript
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDoc_GetJavaScriptActionCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFDocGetJavaScriptActionCount(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDoc_GetJavaScriptAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFDocGetJavaScriptAction(__IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFDoc_CloseJavaScriptAction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFDocCloseJavaScriptAction(__IntPtr javascript);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFJavaScriptAction_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFJavaScriptActionGetName(__IntPtr javascript, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFJavaScriptAction_GetScript", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFJavaScriptActionGetScript(__IntPtr javascript, ushort* buffer, uint buflen);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of JavaScript actions in |document|.</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns the number of JavaScript actions in |document| or -1 on error.</para>
        /// </summary>
        public static int FPDFDocGetJavaScriptActionCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetJavaScriptActionCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the JavaScript action at |index| in |document|.</para>
        /// <para>document - handle to a document.</para>
        /// <para>index    - the index of the requested JavaScript action.</para>
        /// <para>Returns the handle to the JavaScript action, or NULL on failure.</para>
        /// <para>Caller owns the returned handle and must close it with</para>
        /// <para>FPDFDoc_CloseJavaScriptAction().</para>
        /// </summary>
        public static global::PDFiumCore.FpdfJavascriptActionT FPDFDocGetJavaScriptAction(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetJavaScriptAction(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfJavascriptActionT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>javascript - Handle to a JavaScript action.</summary>
        public static void FPDFDocCloseJavaScriptAction(global::PDFiumCore.FpdfJavascriptActionT javascript)
        {
            var __arg0 = javascript is null ? __IntPtr.Zero : javascript.__Instance;
            __Internal.FPDFDocCloseJavaScriptAction(__arg0);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the name from the |javascript| handle. |buffer| is only modified if</para>
        /// <para>|buflen| is longer than the length of the name. On errors, |buffer| is</para>
        /// <para>unmodified and the returned length is 0.</para>
        /// <para>javascript - handle to an JavaScript action.</para>
        /// <para>buffer     - buffer for holding the name, encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the JavaScript action name in bytes.</para>
        /// </summary>
        public static uint FPDFJavaScriptActionGetName(global::PDFiumCore.FpdfJavascriptActionT javascript, ref ushort buffer, uint buflen)
        {
            var __arg0 = javascript is null ? __IntPtr.Zero : javascript.__Instance;
            fixed (ushort* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFJavaScriptActionGetName(__arg0, __arg1, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the script from the |javascript| handle. |buffer| is only modified if</para>
        /// <para>|buflen| is longer than the length of the script. On errors, |buffer| is</para>
        /// <para>unmodified and the returned length is 0.</para>
        /// <para>javascript - handle to an JavaScript action.</para>
        /// <para>buffer     - buffer for holding the name, encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the JavaScript action name in bytes.</para>
        /// </summary>
        public static uint FPDFJavaScriptActionGetScript(global::PDFiumCore.FpdfJavascriptActionT javascript, ref ushort buffer, uint buflen)
        {
            var __arg0 = javascript is null ? __IntPtr.Zero : javascript.__Instance;
            fixed (ushort* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFJavaScriptActionGetScript(__arg0, __arg1, buflen);
                return __ret;
            }
        }
    }

    public unsafe partial class fpdf_ppo
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_ImportPagesByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_ImportPagesByIndex(__IntPtr dest_doc, __IntPtr src_doc, int* page_indices, uint length, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_ImportPages", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_ImportPages(__IntPtr dest_doc, __IntPtr src_doc, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pagerange, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_ImportNPagesToOne", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_ImportNPagesToOne(__IntPtr src_doc, float output_width, float output_height, ulong num_pages_on_x_axis, ulong num_pages_on_y_axis);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_NewXObjectFromPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_NewXObjectFromPage(__IntPtr dest_doc, __IntPtr src_doc, int src_page_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_CloseXObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_CloseXObject(__IntPtr xobject);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_NewFormObjectFromXObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_NewFormObjectFromXObject(__IntPtr xobject);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_CopyViewerPreferences", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_CopyViewerPreferences(__IntPtr dest_doc, __IntPtr src_doc);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Import pages to a FPDF_DOCUMENT.</para>
        /// <para>dest_doc     - The destination document for the pages.</para>
        /// <para>src_doc      - The document to be imported.</para>
        /// <para>page_indices - An array of page indices to be imported. The first page is</para>
        /// <para>zero. If |page_indices| is NULL, all pages from |src_doc|</para>
        /// <para>are imported.</para>
        /// <para>length       - The length of the |page_indices| array.</para>
        /// <para>index        - The page index at which to insert the first imported page</para>
        /// <para>into |dest_doc|. The first page is zero.</para>
        /// <para>Returns TRUE on success. Returns FALSE if any pages in |page_indices| is</para>
        /// <para>invalid.</para>
        /// </summary>
        public static int FPDF_ImportPagesByIndex(global::PDFiumCore.FpdfDocumentT dest_doc, global::PDFiumCore.FpdfDocumentT src_doc, ref int page_indices, uint length, int index)
        {
            var __arg0 = dest_doc is null ? __IntPtr.Zero : dest_doc.__Instance;
            var __arg1 = src_doc is null ? __IntPtr.Zero : src_doc.__Instance;
            fixed (int* __page_indices2 = &page_indices)
            {
                var __arg2 = __page_indices2;
                var __ret = __Internal.FPDF_ImportPagesByIndex(__arg0, __arg1, __arg2, length, index);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Import pages to a FPDF_DOCUMENT.</para>
        /// <para>dest_doc  - The destination document for the pages.</para>
        /// <para>src_doc   - The document to be imported.</para>
        /// <para>pagerange - A page range string, Such as &quot;1,3,5-7&quot;. The first page is one.</para>
        /// <para>If |pagerange| is NULL, all pages from |src_doc| are imported.</para>
        /// <para>index     - The page index at which to insert the first imported page into</para>
        /// <para>|dest_doc|. The first page is zero.</para>
        /// <para>Returns TRUE on success. Returns FALSE if any pages in |pagerange| is</para>
        /// <para>invalid or if |pagerange| cannot be read.</para>
        /// </summary>
        public static int FPDF_ImportPages(global::PDFiumCore.FpdfDocumentT dest_doc, global::PDFiumCore.FpdfDocumentT src_doc, string pagerange, int index)
        {
            var __arg0 = dest_doc is null ? __IntPtr.Zero : dest_doc.__Instance;
            var __arg1 = src_doc is null ? __IntPtr.Zero : src_doc.__Instance;
            var __ret = __Internal.FPDF_ImportPages(__arg0, __arg1, pagerange, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Create a new document from |src_doc|.  The pages of |src_doc| will be</para>
        /// <para>combined to provide |num_pages_on_x_axis x num_pages_on_y_axis| pages per</para>
        /// <para>|output_doc| page.</para>
        /// <para>src_doc             - The document to be imported.</para>
        /// <para>output_width        - The output page width in PDF &quot;user space&quot; units.</para>
        /// <para>output_height       - The output page height in PDF &quot;user space&quot; units.</para>
        /// <para>num_pages_on_x_axis - The number of pages on X Axis.</para>
        /// <para>num_pages_on_y_axis - The number of pages on Y Axis.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the created document, or NULL on failure.</para>
        /// <para>Comments:</para>
        /// <para>number of pages per page = num_pages_on_x_axis * num_pages_on_y_axis</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_ImportNPagesToOne(global::PDFiumCore.FpdfDocumentT src_doc, float output_width, float output_height, ulong num_pages_on_x_axis, ulong num_pages_on_y_axis)
        {
            var __arg0 = src_doc is null ? __IntPtr.Zero : src_doc.__Instance;
            var __ret = __Internal.FPDF_ImportNPagesToOne(__arg0, output_width, output_height, num_pages_on_x_axis, num_pages_on_y_axis);
            var __result0 = global::PDFiumCore.FpdfDocumentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Create a template to generate form xobjects from |src_doc|'s page at</para>
        /// <para>|src_page_index|, for use in |dest_doc|.</para>
        /// <para>Returns a handle on success, or NULL on failure. Caller owns the newly</para>
        /// <para>created object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfXobjectT FPDF_NewXObjectFromPage(global::PDFiumCore.FpdfDocumentT dest_doc, global::PDFiumCore.FpdfDocumentT src_doc, int src_page_index)
        {
            var __arg0 = dest_doc is null ? __IntPtr.Zero : dest_doc.__Instance;
            var __arg1 = src_doc is null ? __IntPtr.Zero : src_doc.__Instance;
            var __ret = __Internal.FPDF_NewXObjectFromPage(__arg0, __arg1, src_page_index);
            var __result0 = global::PDFiumCore.FpdfXobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Close an FPDF_XOBJECT handle created by FPDF_NewXObjectFromPage().</para>
        /// <para>FPDF_PAGEOBJECTs created from the FPDF_XOBJECT handle are not affected.</para>
        /// </summary>
        public static void FPDF_CloseXObject(global::PDFiumCore.FpdfXobjectT xobject)
        {
            var __arg0 = xobject is null ? __IntPtr.Zero : xobject.__Instance;
            __Internal.FPDF_CloseXObject(__arg0);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Create a new form object from an FPDF_XOBJECT object.</para>
        /// <para>Returns a new form object on success, or NULL on failure. Caller owns the</para>
        /// <para>newly created object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDF_NewFormObjectFromXObject(global::PDFiumCore.FpdfXobjectT xobject)
        {
            var __arg0 = xobject is null ? __IntPtr.Zero : xobject.__Instance;
            var __ret = __Internal.FPDF_NewFormObjectFromXObject(__arg0);
            var __result0 = global::PDFiumCore.FpdfPageobjectT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Copy the viewer preferences from |src_doc| into |dest_doc|.</para>
        /// <para>dest_doc - Document to write the viewer preferences into.</para>
        /// <para>src_doc  - Document to read the viewer preferences from.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDF_CopyViewerPreferences(global::PDFiumCore.FpdfDocumentT dest_doc, global::PDFiumCore.FpdfDocumentT src_doc)
        {
            var __arg0 = dest_doc is null ? __IntPtr.Zero : dest_doc.__Instance;
            var __arg1 = src_doc is null ? __IntPtr.Zero : src_doc.__Instance;
            var __ret = __Internal.FPDF_CopyViewerPreferences(__arg0, __arg1);
            return __ret;
        }
    }

    public unsafe partial class IFSDK_PAUSE : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr NeedToPauseNow;
            internal __IntPtr user;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_IFSDK_PAUSE@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IFSDK_PAUSE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IFSDK_PAUSE>();

        protected bool __ownsNativeInstance;

        internal static IFSDK_PAUSE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new IFSDK_PAUSE(native.ToPointer(), skipVTables);
        }

        internal static IFSDK_PAUSE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (IFSDK_PAUSE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static IFSDK_PAUSE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IFSDK_PAUSE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IFSDK_PAUSE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IFSDK_PAUSE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public IFSDK_PAUSE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IFSDK_PAUSE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public IFSDK_PAUSE(global::PDFiumCore.IFSDK_PAUSE _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IFSDK_PAUSE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.IFSDK_PAUSE.__Internal*) __Instance) = *((global::PDFiumCore.IFSDK_PAUSE.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr NeedToPauseNow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->NeedToPauseNow;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->NeedToPauseNow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr User
        {
            get
            {
                return ((__Internal*)__Instance)->user;
            }

            set
            {
                ((__Internal*)__Instance)->user = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class fpdf_progressive
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_RenderPageBitmapWithColorScheme_Start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_RenderPageBitmapWithColorSchemeStart(__IntPtr bitmap, __IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, __IntPtr color_scheme, __IntPtr pause);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_RenderPageBitmap_Start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_RenderPageBitmapStart(__IntPtr bitmap, __IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, __IntPtr pause);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_RenderPage_Continue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_RenderPageContinue(__IntPtr page, __IntPtr pause);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_RenderPage_Close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_RenderPageClose(__IntPtr page);
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmapWithColorScheme_Start</para>
        /// <para>Start to render page contents to a device independent bitmap</para>
        /// <para>progressively with a specified color scheme for the content.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap       -   Handle to the device independent bitmap (as the output buffer). Bitmap handle can be created by FPDFBitmap_Create function.</para>
        /// <para>page         -   Handle to the page as returned by FPDF_LoadPage function.</para>
        /// <para>start_x      -   Left pixel position of the display area in the bitmap coordinate.</para>
        /// <para>start_y      -   Top pixel position of the display area in the bitmap coordinate.</para>
        /// <para>size_x       -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y       -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate       -   Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</para>
        /// <para>flags        -   0 for normal display, or combination of flags defined in fpdfview.h. With FPDF_ANNOT flag, it renders all annotations that does not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>color_scheme -   Color scheme to be used in rendering the |page|. If null, this function will work similar to FPDF_RenderPageBitmap_Start().</para>
        /// <para>pause        -   The IFSDK_PAUSE interface. A callback mechanism allowing the page rendering process.</para>
        /// <para>Return value:</para>
        /// <para>Rendering Status. See flags for progressive process status for the</para>
        /// <para>details.</para>
        /// </summary>
        public static int FPDF_RenderPageBitmapWithColorSchemeStart(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, global::PDFiumCore.FPDF_COLORSCHEME_ color_scheme, global::PDFiumCore.IFSDK_PAUSE pause)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg8 = color_scheme is null ? __IntPtr.Zero : color_scheme.__Instance;
            var __arg9 = pause is null ? __IntPtr.Zero : pause.__Instance;
            var __ret = __Internal.FPDF_RenderPageBitmapWithColorSchemeStart(__arg0, __arg1, start_x, start_y, size_x, size_y, rotate, flags, __arg8, __arg9);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmap_Start</para>
        /// <para>Start to render page contents to a device independent bitmap</para>
        /// <para>progressively.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the device independent bitmap (as the output buffer). Bitmap handle can be created by FPDFBitmap_Create().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>start_x     -   Left pixel position of the display area in the bitmap coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in the bitmap coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</para>
        /// <para>flags       -   0 for normal display, or combination of flags defined in fpdfview.h. With FPDF_ANNOT flag, it renders all annotations that does not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>pause       -   The IFSDK_PAUSE interface.A callback mechanism allowing the page rendering process</para>
        /// <para>Return value:</para>
        /// <para>Rendering Status. See flags for progressive process status for the</para>
        /// <para>details.</para>
        /// </summary>
        public static int FPDF_RenderPageBitmapStart(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, global::PDFiumCore.IFSDK_PAUSE pause)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg8 = pause is null ? __IntPtr.Zero : pause.__Instance;
            var __ret = __Internal.FPDF_RenderPageBitmapStart(__arg0, __arg1, start_x, start_y, size_x, size_y, rotate, flags, __arg8);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPage_Continue</para>
        /// <para>Continue rendering a PDF page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>pause       -   The IFSDK_PAUSE interface (a callback mechanism allowing the page rendering process to be paused before it's finished). This can be NULL if you don't want to pause.</para>
        /// <para>Return value:</para>
        /// <para>The rendering status. See flags for progressive process status for</para>
        /// <para>the details.</para>
        /// </summary>
        public static int FPDF_RenderPageContinue(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.IFSDK_PAUSE pause)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = pause is null ? __IntPtr.Zero : pause.__Instance;
            var __ret = __Internal.FPDF_RenderPageContinue(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPage_Close</para>
        /// <para>Release the resource allocate during page rendering. Need to be</para>
        /// <para>called after finishing rendering or</para>
        /// <para>cancel the rendering.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_RenderPageClose(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDF_RenderPageClose(__arg0);
        }
    }

    public unsafe partial class FPDF_FILEWRITE_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr WriteBlock;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_FILEWRITE_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEWRITE_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEWRITE_>();

        protected bool __ownsNativeInstance;

        internal static FPDF_FILEWRITE_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_FILEWRITE_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_FILEWRITE_ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_FILEWRITE_)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_FILEWRITE_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_FILEWRITE_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEWRITE_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FILEWRITE_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_FILEWRITE_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEWRITE_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_FILEWRITE_(global::PDFiumCore.FPDF_FILEWRITE_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEWRITE_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_uint WriteBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->WriteBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->WriteBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class fpdf_save
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_SaveAsCopy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_SaveAsCopy(__IntPtr document, __IntPtr pFileWrite, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_SaveWithVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_SaveWithVersion(__IntPtr document, __IntPtr pFileWrite, uint flags, int fileVersion);
        }

        /// <summary>
        /// <para>Function: FPDF_SaveAsCopy</para>
        /// <para>Saves the copy of specified document in custom way.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to document, as returned by FPDF_LoadDocument() or FPDF_CreateNewDocument().</para>
        /// <para>pFileWrite      -   A pointer to a custom file write structure.</para>
        /// <para>flags           -   The creating flags.</para>
        /// <para>Return value:</para>
        /// <para>TRUE for succeed, FALSE for failed.</para>
        /// </summary>
        public static int FPDF_SaveAsCopy(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FILEWRITE_ pFileWrite, uint flags)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = pFileWrite is null ? __IntPtr.Zero : pFileWrite.__Instance;
            var __ret = __Internal.FPDF_SaveAsCopy(__arg0, __arg1, flags);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_SaveWithVersion</para>
        /// <para>Same as FPDF_SaveAsCopy(), except the file version of the</para>
        /// <para>saved document can be specified by the caller.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to document.</para>
        /// <para>pFileWrite      -   A pointer to a custom file write structure.</para>
        /// <para>flags           -   The creating flags.</para>
        /// <para>fileVersion     -   The PDF file version. File version: 14 for 1.4, 15 for 1.5, ...</para>
        /// <para>Return value:</para>
        /// <para>TRUE if succeed, FALSE if failed.</para>
        /// </summary>
        public static int FPDF_SaveWithVersion(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FILEWRITE_ pFileWrite, uint flags, int fileVersion)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = pFileWrite is null ? __IntPtr.Zero : pFileWrite.__Instance;
            var __ret = __Internal.FPDF_SaveWithVersion(__arg0, __arg1, flags, fileVersion);
            return __ret;
        }
    }

    public unsafe partial class fpdf_searchex
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetCharIndexFromTextIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetCharIndexFromTextIndex(__IntPtr text_page, int nTextIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetTextIndexFromCharIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetTextIndexFromCharIndex(__IntPtr text_page, int nCharIndex);
        }

        /// <summary>
        /// <para>Get the character index in |text_page| internal character list.</para>
        /// <para>text_page  - a text page information structure.</para>
        /// <para>nTextIndex - index of the text returned from FPDFText_GetText().</para>
        /// <para>Returns the index of the character in internal character list. -1 for error.</para>
        /// </summary>
        public static int FPDFTextGetCharIndexFromTextIndex(global::PDFiumCore.FpdfTextpageT text_page, int nTextIndex)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetCharIndexFromTextIndex(__arg0, nTextIndex);
            return __ret;
        }

        /// <summary>
        /// <para>Get the text index in |text_page| internal character list.</para>
        /// <para>text_page  - a text page information structure.</para>
        /// <para>nCharIndex - index of the character in internal character list.</para>
        /// <para>Returns the index of the text returned from FPDFText_GetText(). -1 for error.</para>
        /// </summary>
        public static int FPDFTextGetTextIndexFromCharIndex(global::PDFiumCore.FpdfTextpageT text_page, int nCharIndex)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetTextIndexFromCharIndex(__arg0, nCharIndex);
            return __ret;
        }
    }

    public unsafe partial class fpdf_signature
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetSignatureCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetSignatureCount(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetSignatureObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetSignatureObject(__IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFSignatureObj_GetContents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFSignatureObjGetContents(__IntPtr signature, __IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFSignatureObj_GetByteRange", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFSignatureObjGetByteRange(__IntPtr signature, int* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFSignatureObj_GetSubFilter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFSignatureObjGetSubFilter(__IntPtr signature, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFSignatureObj_GetReason", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFSignatureObjGetReason(__IntPtr signature, __IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFSignatureObj_GetTime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFSignatureObjGetTime(__IntPtr signature, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFSignatureObj_GetDocMDPPermission", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFSignatureObjGetDocMDPPermission(__IntPtr signature);
        }

        /// <summary>
        /// <para>Function: FPDF_GetSignatureCount</para>
        /// <para>Get total number of signatures in the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>Return value:</para>
        /// <para>Total number of signatures in the document on success, -1 on error.</para>
        /// </summary>
        public static int FPDF_GetSignatureCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetSignatureCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetSignatureObject</para>
        /// <para>Get the Nth signature of the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>index       -   Index into the array of signatures of the document.</para>
        /// <para>Return value:</para>
        /// <para>Returns the handle to the signature, or NULL on failure. The caller</para>
        /// <para>does not take ownership of the returned FPDF_SIGNATURE. Instead, it</para>
        /// <para>remains valid until FPDF_CloseDocument() is called for the document.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfSignatureT FPDF_GetSignatureObject(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetSignatureObject(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfSignatureT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetContents</para>
        /// <para>Get the contents of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the contents.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the contents on success, 0 on error.</para>
        /// <para>For public-key signatures, |buffer| is either a DER-encoded PKCS#1 binary or</para>
        /// <para>a DER-encoded PKCS#7 binary. If |length| is less than the returned length, or</para>
        /// <para>|buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetContents(global::PDFiumCore.FpdfSignatureT signature, __IntPtr buffer, uint length)
        {
            var __arg0 = signature is null ? __IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetContents(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetByteRange</para>
        /// <para>Get the byte range of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the byte range.</para>
        /// <para>length      -   The size, in ints, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of ints in the byte range on</para>
        /// <para>success, 0 on error.</para>
        /// <para>|buffer| is an array of pairs of integers (starting byte offset,</para>
        /// <para>length in bytes) that describes the exact byte range for the digest</para>
        /// <para>calculation. If |length| is less than the returned length, or</para>
        /// <para>|buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetByteRange(global::PDFiumCore.FpdfSignatureT signature, ref int buffer, uint length)
        {
            var __arg0 = signature is null ? __IntPtr.Zero : signature.__Instance;
            fixed (int* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFSignatureObjGetByteRange(__arg0, __arg1, length);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetSubFilter</para>
        /// <para>Get the encoding of the value of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the encoding.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the encoding name (including the</para>
        /// <para>trailing NUL character) on success, 0 on error.</para>
        /// <para>The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the</para>
        /// <para>returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetSubFilter(global::PDFiumCore.FpdfSignatureT signature, sbyte* buffer, uint length)
        {
            var __arg0 = signature is null ? __IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetSubFilter(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetReason</para>
        /// <para>Get the reason (comment) of the signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the reason.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the reason on success, 0 on error.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The</para>
        /// <para>string is terminated by a UTF16 NUL character. If |length| is less than the</para>
        /// <para>returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetReason(global::PDFiumCore.FpdfSignatureT signature, __IntPtr buffer, uint length)
        {
            var __arg0 = signature is null ? __IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetReason(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetTime</para>
        /// <para>Get the time of signing of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the time.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the encoding name (including the</para>
        /// <para>trailing NUL character) on success, 0 on error.</para>
        /// <para>The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the</para>
        /// <para>returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>The format of time is expected to be D:YYYYMMDDHHMMSS+XX'YY', i.e. it's</para>
        /// <para>percision is seconds, with timezone information. This value should be used</para>
        /// <para>only when the time of signing is not available in the (PKCS#7 binary)</para>
        /// <para>signature.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetTime(global::PDFiumCore.FpdfSignatureT signature, sbyte* buffer, uint length)
        {
            var __arg0 = signature is null ? __IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetTime(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetDocMDPPermission</para>
        /// <para>Get the DocMDP permission of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>Return value:</para>
        /// <para>Returns the permission (1, 2 or 3) on success, 0 on error.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetDocMDPPermission(global::PDFiumCore.FpdfSignatureT signature)
        {
            var __arg0 = signature is null ? __IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetDocMDPPermission(__arg0);
            return __ret;
        }
    }

    public unsafe partial class fpdf_structtree
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructTree_GetForPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_StructTreeGetForPage(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructTree_Close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_StructTreeClose(__IntPtr struct_tree);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructTree_CountChildren", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructTreeCountChildren(__IntPtr struct_tree);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructTree_GetChildAtIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_StructTreeGetChildAtIndex(__IntPtr struct_tree, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetAltText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetAltText(__IntPtr struct_element, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetActualText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetActualText(__IntPtr struct_element, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetID(__IntPtr struct_element, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetLang", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetLang(__IntPtr struct_element, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetStringAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetStringAttribute(__IntPtr struct_element, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string attr_name, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetMarkedContentID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementGetMarkedContentID(__IntPtr struct_element);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetType(__IntPtr struct_element, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetObjType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetObjType(__IntPtr struct_element, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetTitle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_StructElementGetTitle(__IntPtr struct_element, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_CountChildren", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementCountChildren(__IntPtr struct_element);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetChildAtIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_StructElementGetChildAtIndex(__IntPtr struct_element, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetChildMarkedContentID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementGetChildMarkedContentID(__IntPtr struct_element, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetParent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_StructElementGetParent(__IntPtr struct_element);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetAttributeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementGetAttributeCount(__IntPtr struct_element);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetAttributeAtIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_StructElementGetAttributeAtIndex(__IntPtr struct_element, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_Attr_GetCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementAttrGetCount(__IntPtr struct_attribute);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_Attr_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementAttrGetName(__IntPtr struct_attribute, int index, __IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_Attr_GetType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementAttrGetType(__IntPtr struct_attribute, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_Attr_GetBooleanValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementAttrGetBooleanValue(__IntPtr struct_attribute, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, int* out_value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_Attr_GetNumberValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementAttrGetNumberValue(__IntPtr struct_attribute, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, float* out_value);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_Attr_GetStringValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementAttrGetStringValue(__IntPtr struct_attribute, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_Attr_GetBlobValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementAttrGetBlobValue(__IntPtr struct_attribute, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetMarkedContentIdCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementGetMarkedContentIdCount(__IntPtr struct_element);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_StructElement_GetMarkedContentIdAtIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_StructElementGetMarkedContentIdAtIndex(__IntPtr struct_element, int index);
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_GetForPage</para>
        /// <para>Get the structure tree for a page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>A handle to the structure tree or NULL on error.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructtreeT FPDF_StructTreeGetForPage(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_StructTreeGetForPage(__arg0);
            var __result0 = global::PDFiumCore.FpdfStructtreeT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_Close</para>
        /// <para>Release a resource allocated by FPDF_StructTree_GetForPage().</para>
        /// <para>Parameters:</para>
        /// <para>struct_tree -   Handle to the structure tree, as returned by FPDF_StructTree_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_StructTreeClose(global::PDFiumCore.FpdfStructtreeT struct_tree)
        {
            var __arg0 = struct_tree is null ? __IntPtr.Zero : struct_tree.__Instance;
            __Internal.FPDF_StructTreeClose(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_CountChildren</para>
        /// <para>Count the number of children for the structure tree.</para>
        /// <para>Parameters:</para>
        /// <para>struct_tree -   Handle to the structure tree, as returned by FPDF_StructTree_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>The number of children, or -1 on error.</para>
        /// </summary>
        public static int FPDF_StructTreeCountChildren(global::PDFiumCore.FpdfStructtreeT struct_tree)
        {
            var __arg0 = struct_tree is null ? __IntPtr.Zero : struct_tree.__Instance;
            var __ret = __Internal.FPDF_StructTreeCountChildren(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_GetChildAtIndex</para>
        /// <para>Get a child in the structure tree.</para>
        /// <para>Parameters:</para>
        /// <para>struct_tree -   Handle to the structure tree, as returned by FPDF_StructTree_LoadPage().</para>
        /// <para>index       -   The index for the child, 0-based.</para>
        /// <para>Return value:</para>
        /// <para>The child at the n-th index or NULL on error.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructelementT FPDF_StructTreeGetChildAtIndex(global::PDFiumCore.FpdfStructtreeT struct_tree, int index)
        {
            var __arg0 = struct_tree is null ? __IntPtr.Zero : struct_tree.__Instance;
            var __ret = __Internal.FPDF_StructTreeGetChildAtIndex(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfStructelementT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetAltText</para>
        /// <para>Get the alt text for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>buffer         -   A buffer for output the alt text. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the alt text, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetAltText(global::PDFiumCore.FpdfStructelementT struct_element, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetAltText(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetActualText</para>
        /// <para>Get the actual text for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>buffer         -   A buffer for output the actual text. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the actual text, including the terminating</para>
        /// <para>NUL character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetActualText(global::PDFiumCore.FpdfStructelementT struct_element, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetActualText(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetID</para>
        /// <para>Get the ID for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>buffer         -   A buffer for output the ID string. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the ID string, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetID(global::PDFiumCore.FpdfStructelementT struct_element, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetID(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetLang</para>
        /// <para>Get the case-insensitive IETF BCP 47 language code for an element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>buffer         -   A buffer for output the lang string. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the ID string, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetLang(global::PDFiumCore.FpdfStructelementT struct_element, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetLang(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetStringAttribute</para>
        /// <para>Get a struct element attribute of type &quot;name&quot; or &quot;string&quot;.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>attr_name      -   The name of the attribute to retrieve.</para>
        /// <para>buffer         -   A buffer for output. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the attribute value, including the</para>
        /// <para>terminating NUL character. The number of bytes is returned</para>
        /// <para>regardless of the |buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetStringAttribute(global::PDFiumCore.FpdfStructelementT struct_element, string attr_name, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetStringAttribute(__arg0, attr_name, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetMarkedContentID</para>
        /// <para>Get the marked content ID for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>Return value:</para>
        /// <para>The marked content ID of the element. If no ID exists, returns</para>
        /// <para>-1.</para>
        /// </summary>
        public static int FPDF_StructElementGetMarkedContentID(global::PDFiumCore.FpdfStructelementT struct_element)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetMarkedContentID(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetType</para>
        /// <para>Get the type (/S) for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element - Handle to the struct element.</para>
        /// <para>buffer         - A buffer for output. May be NULL.</para>
        /// <para>buflen         - The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the type, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetType(global::PDFiumCore.FpdfStructelementT struct_element, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetType(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetObjType</para>
        /// <para>Get the object type (/Type) for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element - Handle to the struct element.</para>
        /// <para>buffer         - A buffer for output. May be NULL.</para>
        /// <para>buflen         - The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the object type, including the terminating</para>
        /// <para>NUL character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetObjType(global::PDFiumCore.FpdfStructelementT struct_element, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetObjType(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetTitle</para>
        /// <para>Get the title (/T) for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element - Handle to the struct element.</para>
        /// <para>buffer         - A buffer for output. May be NULL.</para>
        /// <para>buflen         - The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the title, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetTitle(global::PDFiumCore.FpdfStructelementT struct_element, __IntPtr buffer, uint buflen)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetTitle(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_CountChildren</para>
        /// <para>Count the number of children for the structure element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>Return value:</para>
        /// <para>The number of children, or -1 on error.</para>
        /// </summary>
        public static int FPDF_StructElementCountChildren(global::PDFiumCore.FpdfStructelementT struct_element)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementCountChildren(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetChildAtIndex</para>
        /// <para>Get a child in the structure element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>index          -   The index for the child, 0-based.</para>
        /// <para>Return value:</para>
        /// <para>The child at the n-th index or NULL on error.</para>
        /// <para>Comments: If the child exists but is not an element, then this function will return NULL. This will also return NULL for out of bounds indices.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructelementT FPDF_StructElementGetChildAtIndex(global::PDFiumCore.FpdfStructelementT struct_element, int index)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetChildAtIndex(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfStructelementT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetChildMarkedContentID</para>
        /// <para>Get the child's content id</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>index          -   The index for the child, 0-based.</para>
        /// <para>Return value:</para>
        /// <para>The marked content ID of the child. If no ID exists, returns -1.</para>
        /// <para>Comments: If the child exists but is not a stream or object, then this function will return -1. This will also return -1 for out of bounds indices. Compared to FPDF_StructElement_GetMarkedContentIdAtIndex, it is scoped to the current page.</para>
        /// </summary>
        public static int FPDF_StructElementGetChildMarkedContentID(global::PDFiumCore.FpdfStructelementT struct_element, int index)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetChildMarkedContentID(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetParent</para>
        /// <para>Get the parent of the structure element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>Return value:</para>
        /// <para>The parent structure element or NULL on error.</para>
        /// <para>Comments: If structure element is StructTreeRoot, then this function will return NULL.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructelementT FPDF_StructElementGetParent(global::PDFiumCore.FpdfStructelementT struct_element)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetParent(__arg0);
            var __result0 = global::PDFiumCore.FpdfStructelementT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetAttributeCount</para>
        /// <para>Count the number of attributes for the structure element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>Return value:</para>
        /// <para>The number of attributes, or -1 on error.</para>
        /// </summary>
        public static int FPDF_StructElementGetAttributeCount(global::PDFiumCore.FpdfStructelementT struct_element)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetAttributeCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetAttributeAtIndex</para>
        /// <para>Get an attribute object in the structure element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>index          -   The index for the attribute object, 0-based.</para>
        /// <para>Return value:</para>
        /// <para>The attribute object at the n-th index or NULL on error.</para>
        /// <para>Comments: If the attribute object exists but is not a dict, then this function will return NULL. This will also return NULL for out of bounds indices.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructelementAttrT FPDF_StructElementGetAttributeAtIndex(global::PDFiumCore.FpdfStructelementT struct_element, int index)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetAttributeAtIndex(__arg0, index);
            var __result0 = global::PDFiumCore.FpdfStructelementAttrT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_Attr_GetCount</para>
        /// <para>Count the number of attributes in a structure element attribute map.</para>
        /// <para>Parameters:</para>
        /// <para>struct_attribute - Handle to the struct element attribute.</para>
        /// <para>Return value:</para>
        /// <para>The number of attributes, or -1 on error.</para>
        /// </summary>
        public static int FPDF_StructElementAttrGetCount(global::PDFiumCore.FpdfStructelementAttrT struct_attribute)
        {
            var __arg0 = struct_attribute is null ? __IntPtr.Zero : struct_attribute.__Instance;
            var __ret = __Internal.FPDF_StructElementAttrGetCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_Attr_GetName</para>
        /// <para>Get the name of an attribute in a structure element attribute map.</para>
        /// <para>Parameters:</para>
        /// <para>struct_attribute   - Handle to the struct element attribute.</para>
        /// <para>index              - The index of attribute in the map.</para>
        /// <para>buffer             - A buffer for output. May be NULL. This is only modified if |buflen| is longer than the length of the key. Optional, pass null to just retrieve the size of the buffer needed.</para>
        /// <para>buflen             - The length of the buffer.</para>
        /// <para>out_buflen         - A pointer to variable that will receive the minimum buffer size to contain the key. Not filled if FALSE is returned.</para>
        /// <para>Return value:</para>
        /// <para>TRUE if the operation was successful, FALSE otherwise.</para>
        /// </summary>
        public static int FPDF_StructElementAttrGetName(global::PDFiumCore.FpdfStructelementAttrT struct_attribute, int index, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = struct_attribute is null ? __IntPtr.Zero : struct_attribute.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDF_StructElementAttrGetName(__arg0, index, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_Attr_GetType</para>
        /// <para>Get the type of an attribute in a structure element attribute map.</para>
        /// <para>Parameters:</para>
        /// <para>struct_attribute   - Handle to the struct element attribute.</para>
        /// <para>name               - The attribute name.</para>
        /// <para>Return value:</para>
        /// <para>Returns the type of the value, or FPDF_OBJECT_UNKNOWN in case of</para>
        /// <para>failure.</para>
        /// </summary>
        public static int FPDF_StructElementAttrGetType(global::PDFiumCore.FpdfStructelementAttrT struct_attribute, string name)
        {
            var __arg0 = struct_attribute is null ? __IntPtr.Zero : struct_attribute.__Instance;
            var __ret = __Internal.FPDF_StructElementAttrGetType(__arg0, name);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_Attr_GetBooleanValue</para>
        /// <para>Get the value of a boolean attribute in an attribute map by name as</para>
        /// <para>FPDF_BOOL. FPDF_StructElement_Attr_GetType() should have returned</para>
        /// <para>FPDF_OBJECT_BOOLEAN for this property.</para>
        /// <para>Parameters:</para>
        /// <para>struct_attribute   - Handle to the struct element attribute.</para>
        /// <para>name               - The attribute name.</para>
        /// <para>out_value          - A pointer to variable that will receive the value. Not filled if false is returned.</para>
        /// <para>Return value:</para>
        /// <para>Returns TRUE if the name maps to a boolean value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDF_StructElementAttrGetBooleanValue(global::PDFiumCore.FpdfStructelementAttrT struct_attribute, string name, ref int out_value)
        {
            var __arg0 = struct_attribute is null ? __IntPtr.Zero : struct_attribute.__Instance;
            fixed (int* __out_value2 = &out_value)
            {
                var __arg2 = __out_value2;
                var __ret = __Internal.FPDF_StructElementAttrGetBooleanValue(__arg0, name, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_Attr_GetNumberValue</para>
        /// <para>Get the value of a number attribute in an attribute map by name as</para>
        /// <para>float. FPDF_StructElement_Attr_GetType() should have returned</para>
        /// <para>FPDF_OBJECT_NUMBER for this property.</para>
        /// <para>Parameters:</para>
        /// <para>struct_attribute   - Handle to the struct element attribute.</para>
        /// <para>name               - The attribute name.</para>
        /// <para>out_value          - A pointer to variable that will receive the value. Not filled if false is returned.</para>
        /// <para>Return value:</para>
        /// <para>Returns TRUE if the name maps to a number value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDF_StructElementAttrGetNumberValue(global::PDFiumCore.FpdfStructelementAttrT struct_attribute, string name, ref float out_value)
        {
            var __arg0 = struct_attribute is null ? __IntPtr.Zero : struct_attribute.__Instance;
            fixed (float* __out_value2 = &out_value)
            {
                var __arg2 = __out_value2;
                var __ret = __Internal.FPDF_StructElementAttrGetNumberValue(__arg0, name, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_Attr_GetStringValue</para>
        /// <para>Get the value of a string attribute in an attribute map by name as</para>
        /// <para>string. FPDF_StructElement_Attr_GetType() should have returned</para>
        /// <para>FPDF_OBJECT_STRING or FPDF_OBJECT_NAME for this property.</para>
        /// <para>Parameters:</para>
        /// <para>struct_attribute   - Handle to the struct element attribute.</para>
        /// <para>name               - The attribute name.</para>
        /// <para>buffer             - A buffer for holding the returned key in UTF-16LE. This is only modified if |buflen| is longer than the length of the key. Optional, pass null to just retrieve the size of the buffer needed.</para>
        /// <para>buflen             - The length of the buffer.</para>
        /// <para>out_buflen         - A pointer to variable that will receive the minimum buffer size to contain the key. Not filled if FALSE is returned.</para>
        /// <para>Return value:</para>
        /// <para>Returns TRUE if the name maps to a string value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDF_StructElementAttrGetStringValue(global::PDFiumCore.FpdfStructelementAttrT struct_attribute, string name, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = struct_attribute is null ? __IntPtr.Zero : struct_attribute.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDF_StructElementAttrGetStringValue(__arg0, name, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_Attr_GetBlobValue</para>
        /// <para>Get the value of a blob attribute in an attribute map by name as</para>
        /// <para>string.</para>
        /// <para>Parameters:</para>
        /// <para>struct_attribute   - Handle to the struct element attribute.</para>
        /// <para>name               - The attribute name.</para>
        /// <para>buffer             - A buffer for holding the returned value. This is only modified if |buflen| is at least as long as the length of the value. Optional, pass null to just retrieve the size of the buffer needed.</para>
        /// <para>buflen             - The length of the buffer.</para>
        /// <para>out_buflen         - A pointer to variable that will receive the minimum buffer size to contain the key. Not filled if FALSE is returned.</para>
        /// <para>Return value:</para>
        /// <para>Returns TRUE if the name maps to a string value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDF_StructElementAttrGetBlobValue(global::PDFiumCore.FpdfStructelementAttrT struct_attribute, string name, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = struct_attribute is null ? __IntPtr.Zero : struct_attribute.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDF_StructElementAttrGetBlobValue(__arg0, name, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetMarkedContentIdCount</para>
        /// <para>Get the count of marked content ids for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>Return value:</para>
        /// <para>The count of marked content ids or -1 if none exists.</para>
        /// </summary>
        public static int FPDF_StructElementGetMarkedContentIdCount(global::PDFiumCore.FpdfStructelementT struct_element)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetMarkedContentIdCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetMarkedContentIdAtIndex</para>
        /// <para>Get the marked content id at a given index for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>index          -   The index of the marked content id, 0-based.</para>
        /// <para>Return value:</para>
        /// <para>The marked content ID of the element. If no ID exists, returns</para>
        /// <para>-1.</para>
        /// </summary>
        public static int FPDF_StructElementGetMarkedContentIdAtIndex(global::PDFiumCore.FpdfStructelementT struct_element, int index)
        {
            var __arg0 = struct_element is null ? __IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetMarkedContentIdAtIndex(__arg0, index);
            return __ret;
        }
    }

    public unsafe partial class FPDF_SYSFONTINFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr Release;
            internal __IntPtr EnumFonts;
            internal __IntPtr MapFont;
            internal __IntPtr GetFont;
            internal __IntPtr GetFontData;
            internal __IntPtr GetFaceName;
            internal __IntPtr GetFontCharset;
            internal __IntPtr DeleteFont;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0_FPDF_SYSFONTINFO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSFONTINFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSFONTINFO>();

        protected bool __ownsNativeInstance;

        internal static FPDF_SYSFONTINFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_SYSFONTINFO(native.ToPointer(), skipVTables);
        }

        internal static FPDF_SYSFONTINFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_SYSFONTINFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_SYSFONTINFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_SYSFONTINFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_SYSFONTINFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_SYSFONTINFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_SYSFONTINFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_SYSFONTINFO(global::PDFiumCore.FPDF_SYSFONTINFO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr Release
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Release;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Release = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr EnumFonts
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->EnumFonts;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->EnumFonts = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_int_int_int_int_string8_intPtr MapFont
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->MapFont;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_int_int_int_int_string8_intPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_int_int_int_int_string8_intPtr));
            }

            set
            {
                ((__Internal*)__Instance)->MapFont = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_string8 GetFont
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetFont;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func___IntPtr___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->GetFont = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_uint___IntPtr___IntPtr_uint_bytePtr_uint GetFontData
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetFontData;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_uint___IntPtr___IntPtr_uint_bytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_uint___IntPtr___IntPtr_uint_bytePtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->GetFontData = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_uint___IntPtr___IntPtr_sbytePtr_uint GetFaceName
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetFaceName;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_uint___IntPtr___IntPtr_sbytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_uint___IntPtr___IntPtr_sbytePtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->GetFaceName = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr GetFontCharset
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetFontCharset;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->GetFontCharset = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action___IntPtr___IntPtr DeleteFont
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->DeleteFont;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->DeleteFont = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FPDF_CharsetFontMap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int charset;
            internal __IntPtr fontname;

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "??0FPDF_CharsetFontMap_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_CharsetFontMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_CharsetFontMap>();

        private bool __fontname_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static FPDF_CharsetFontMap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new FPDF_CharsetFontMap(native.ToPointer(), skipVTables);
        }

        internal static FPDF_CharsetFontMap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (FPDF_CharsetFontMap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static FPDF_CharsetFontMap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_CharsetFontMap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_CharsetFontMap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_CharsetFontMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_CharsetFontMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_CharsetFontMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_CharsetFontMap(global::PDFiumCore.FPDF_CharsetFontMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_CharsetFontMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) _0.__Instance);
            if (_0.__fontname_OwnsNativeMemory)
                this.Fontname = _0.Fontname;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__fontname_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->fontname);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Charset
        {
            get
            {
                return ((__Internal*)__Instance)->charset;
            }

            set
            {
                ((__Internal*)__Instance)->charset = value;
            }
        }

        public string Fontname
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->fontname);
            }

            set
            {
                if (__fontname_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->fontname);
                __fontname_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->fontname = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->fontname = (__IntPtr) __bytePtr0;
            }
        }
    }

    public unsafe partial class fpdf_sysfontinfo
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetDefaultTTFMap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetDefaultTTFMap();

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_AddInstalledFont", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_AddInstalledFont(__IntPtr mapper, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string face, int charset);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_SetSystemFontInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_SetSystemFontInfo(__IntPtr pFontInfo);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_GetDefaultSystemFontInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetDefaultSystemFontInfo();

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_FreeDefaultSystemFontInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_FreeDefaultSystemFontInfo(__IntPtr pFontInfo);
        }

        /// <summary>
        /// <para>Function: FPDF_GetDefaultTTFMap</para>
        /// <para>Returns a pointer to the default character set to TT Font name map. The</para>
        /// <para>map is an array of FPDF_CharsetFontMap structs, with its end indicated</para>
        /// <para>by a { -1, NULL } entry.</para>
        /// <para>Parameters:</para>
        /// <para>None.</para>
        /// <para>Return Value:</para>
        /// <para>Pointer to the Charset Font Map.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_CharsetFontMap FPDF_GetDefaultTTFMap()
        {
            var __ret = __Internal.FPDF_GetDefaultTTFMap();
            var __result0 = global::PDFiumCore.FPDF_CharsetFontMap.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_AddInstalledFont</para>
        /// <para>Add a system font to the list in PDFium.</para>
        /// <para>Comments: This function is only called during the system font list building process.</para>
        /// <para>Parameters:</para>
        /// <para>mapper          -   Opaque pointer to Foxit font mapper</para>
        /// <para>face            -   The font face name</para>
        /// <para>charset         -   Font character set. See above defined constants.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_AddInstalledFont(__IntPtr mapper, string face, int charset)
        {
            __Internal.FPDF_AddInstalledFont(mapper, face, charset);
        }

        /// <summary>
        /// <para>Function: FPDF_SetSystemFontInfo</para>
        /// <para>Set the system font info interface into PDFium</para>
        /// <para>Parameters:</para>
        /// <para>pFontInfo       -   Pointer to a FPDF_SYSFONTINFO structure</para>
        /// <para>Return Value:</para>
        /// <para>None</para>
        /// <para>Comments: Platform support implementation should implement required methods of FFDF_SYSFONTINFO interface, then call this function during PDFium initialization process.</para>
        /// </summary>
        public static void FPDF_SetSystemFontInfo(global::PDFiumCore.FPDF_SYSFONTINFO pFontInfo)
        {
            var __arg0 = pFontInfo is null ? __IntPtr.Zero : pFontInfo.__Instance;
            __Internal.FPDF_SetSystemFontInfo(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_GetDefaultSystemFontInfo</para>
        /// <para>Get default system font info interface for current platform</para>
        /// <para>Parameters:</para>
        /// <para>None</para>
        /// <para>Return Value:</para>
        /// <para>Pointer to a FPDF_SYSFONTINFO structure describing the default</para>
        /// <para>interface, or NULL if the platform doesn't have a default interface.</para>
        /// <para>Application should call FPDF_FreeDefaultSystemFontInfo to free the</para>
        /// <para>returned pointer.</para>
        /// <para>Comments: For some platforms, PDFium implements a default version of system font info interface. The default implementation can be passed to FPDF_SetSystemFontInfo().</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_SYSFONTINFO FPDF_GetDefaultSystemFontInfo()
        {
            var __ret = __Internal.FPDF_GetDefaultSystemFontInfo();
            var __result0 = global::PDFiumCore.FPDF_SYSFONTINFO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_FreeDefaultSystemFontInfo</para>
        /// <para>Free a default system font info interface</para>
        /// <para>Parameters:</para>
        /// <para>pFontInfo       -   Pointer to a FPDF_SYSFONTINFO structure</para>
        /// <para>Return Value:</para>
        /// <para>None</para>
        /// <para>Comments: This function should be called on the output from FPDF_SetSystemFontInfo() once it is no longer needed.</para>
        /// </summary>
        public static void FPDF_FreeDefaultSystemFontInfo(global::PDFiumCore.FPDF_SYSFONTINFO pFontInfo)
        {
            var __arg0 = pFontInfo is null ? __IntPtr.Zero : pFontInfo.__Instance;
            __Internal.FPDF_FreeDefaultSystemFontInfo(__arg0);
        }
    }

    public unsafe partial class fpdf_text
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_LoadPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFTextLoadPage(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_ClosePage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFTextClosePage(__IntPtr text_page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_CountChars", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextCountChars(__IntPtr text_page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetUnicode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFTextGetUnicode(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_IsGenerated", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextIsGenerated(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_IsHyphen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextIsHyphen(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_HasUnicodeMapError", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextHasUnicodeMapError(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetFontSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double FPDFTextGetFontSize(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetFontInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFTextGetFontInfo(__IntPtr text_page, int index, __IntPtr buffer, uint buflen, int* flags);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetFontWeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetFontWeight(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetTextRenderMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextGetTextRenderMode(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetFillColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetFillColor(__IntPtr text_page, int index, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetStrokeColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetStrokeColor(__IntPtr text_page, int index, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetCharAngle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float FPDFTextGetCharAngle(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetCharBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetCharBox(__IntPtr text_page, int index, double* left, double* right, double* bottom, double* top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetLooseCharBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetLooseCharBox(__IntPtr text_page, int index, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetMatrix(__IntPtr text_page, int index, __IntPtr matrix);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetCharOrigin", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetCharOrigin(__IntPtr text_page, int index, double* x, double* y);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetCharIndexAtPos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetCharIndexAtPos(__IntPtr text_page, double x, double y, double xTolerance, double yTolerance);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetText(__IntPtr text_page, int start_index, int count, ushort* result);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_CountRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextCountRects(__IntPtr text_page, int start_index, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetRect(__IntPtr text_page, int rect_index, double* left, double* top, double* right, double* bottom);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetBoundedText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetBoundedText(__IntPtr text_page, double left, double top, double right, double bottom, ushort* buffer, int buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_FindStart", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFTextFindStart(__IntPtr text_page, ushort* findwhat, uint flags, int start_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_FindNext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextFindNext(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_FindPrev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextFindPrev(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetSchResultIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetSchResultIndex(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_GetSchCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFTextGetSchCount(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFText_FindClose", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFTextFindClose(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_LoadWebLinks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFLinkLoadWebLinks(__IntPtr text_page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_CountWebLinks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkCountWebLinks(__IntPtr link_page);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetURL", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkGetURL(__IntPtr link_page, int link_index, ushort* buffer, int buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_CountRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkCountRects(__IntPtr link_page, int link_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkGetRect(__IntPtr link_page, int link_index, int rect_index, double* left, double* top, double* right, double* bottom);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_GetTextRange", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLinkGetTextRange(__IntPtr link_page, int link_index, int* start_char_index, int* char_count);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFLink_CloseWebLinks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFLinkCloseWebLinks(__IntPtr link_page);
        }

        /// <summary>
        /// <para>Function: FPDFText_LoadPage</para>
        /// <para>Prepare information about all characters in a page.</para>
        /// <para>Parameters:</para>
        /// <para>page    -   Handle to the page. Returned by FPDF_LoadPage function (in FPDFVIEW module).</para>
        /// <para>Return value:</para>
        /// <para>A handle to the text page information structure.</para>
        /// <para>NULL if something goes wrong.</para>
        /// <para>Comments: Application must call FPDFText_ClosePage to release the text page information.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfTextpageT FPDFTextLoadPage(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFTextLoadPage(__arg0);
            var __result0 = global::PDFiumCore.FpdfTextpageT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFText_ClosePage</para>
        /// <para>Release all resources allocated for a text page information</para>
        /// <para>structure.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDFTextClosePage(global::PDFiumCore.FpdfTextpageT text_page)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            __Internal.FPDFTextClosePage(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDFText_CountChars</para>
        /// <para>Get number of characters in a page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>Return value:</para>
        /// <para>Number of characters in the page. Return -1 for error.</para>
        /// <para>Generated characters, like additional space characters, new line</para>
        /// <para>characters, are also counted.</para>
        /// <para>Comments: Characters in a page form a &quot;stream&quot;, inside the stream, each character has an index. We will use the index parameters in many of FPDFTEXT functions. The first character in the page has an index value of zero.</para>
        /// </summary>
        public static int FPDFTextCountChars(global::PDFiumCore.FpdfTextpageT text_page)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextCountChars(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetUnicode</para>
        /// <para>Get Unicode of a character in a page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>The Unicode of the particular character.</para>
        /// <para>If a character is not encoded in Unicode and Foxit engine can't</para>
        /// <para>convert to Unicode,</para>
        /// <para>the return value will be zero.</para>
        /// </summary>
        public static uint FPDFTextGetUnicode(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetUnicode(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_IsGenerated</para>
        /// <para>Get if a character in a page is generated by PDFium.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>1 if the character is generated by PDFium.</para>
        /// <para>0 if the character is not generated by PDFium.</para>
        /// <para>-1 if there was an error.</para>
        /// </summary>
        public static int FPDFTextIsGenerated(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextIsGenerated(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_IsHyphen</para>
        /// <para>Get if a character in a page is a hyphen.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>1 if the character is a hyphen.</para>
        /// <para>0 if the character is not a hyphen.</para>
        /// <para>-1 if there was an error.</para>
        /// </summary>
        public static int FPDFTextIsHyphen(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextIsHyphen(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_HasUnicodeMapError</para>
        /// <para>Get if a character in a page has an invalid unicode mapping.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>1 if the character has an invalid unicode mapping.</para>
        /// <para>0 if the character has no known unicode mapping issues.</para>
        /// <para>-1 if there was an error.</para>
        /// </summary>
        public static int FPDFTextHasUnicodeMapError(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextHasUnicodeMapError(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFontSize</para>
        /// <para>Get the font size of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>The font size of the particular character, measured in points (about</para>
        /// <para>1/72 inch). This is the typographic size of the font (so called</para>
        /// <para>&quot;em size&quot;).</para>
        /// </summary>
        public static double FPDFTextGetFontSize(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetFontSize(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFontInfo</para>
        /// <para>Get the font name and flags of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page - Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index     - Zero-based index of the character.</para>
        /// <para>buffer    - A buffer receiving the font name.</para>
        /// <para>buflen    - The length of |buffer| in bytes.</para>
        /// <para>flags     - Optional pointer to an int receiving the font flags. These flags should be interpreted per PDF spec 1.7 Section 5.7.1 Font Descriptor Flags.</para>
        /// <para>Return value:</para>
        /// <para>On success, return the length of the font name, including the</para>
        /// <para>trailing NUL character, in bytes. If this length is less than or</para>
        /// <para>equal to |length|, |buffer| is set to the font name, |flags| is</para>
        /// <para>set to the font flags. |buffer| is in UTF-8 encoding. Return 0 on</para>
        /// <para>failure.</para>
        /// </summary>
        public static uint FPDFTextGetFontInfo(global::PDFiumCore.FpdfTextpageT text_page, int index, __IntPtr buffer, uint buflen, ref int flags)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (int* __flags4 = &flags)
            {
                var __arg4 = __flags4;
                var __ret = __Internal.FPDFTextGetFontInfo(__arg0, index, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFontWeight</para>
        /// <para>Get the font weight of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>On success, return the font weight of the particular character. If</para>
        /// <para>|text_page| is invalid, if |index| is out of bounds, or if the</para>
        /// <para>character's text object is undefined, return -1.</para>
        /// </summary>
        public static int FPDFTextGetFontWeight(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetFontWeight(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetTextRenderMode</para>
        /// <para>Get text rendering mode of character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return the render mode value. A valid value is of type</para>
        /// <para>FPDF_TEXT_RENDERMODE. If |text_page| is invalid, if |index| is out</para>
        /// <para>of bounds, or if the text object is undefined, then return</para>
        /// <para>FPDF_TEXTRENDERMODE_UNKNOWN.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextGetTextRenderMode(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetTextRenderMode(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFillColor</para>
        /// <para>Get the fill color of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page      -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index          -   Zero-based index of the character.</para>
        /// <para>R              -   Pointer to an unsigned int number receiving the red value of the fill color.</para>
        /// <para>G              -   Pointer to an unsigned int number receiving the green value of the fill color.</para>
        /// <para>B              -   Pointer to an unsigned int number receiving the blue value of the fill color.</para>
        /// <para>A              -   Pointer to an unsigned int number receiving the alpha value of the fill color.</para>
        /// <para>Return value:</para>
        /// <para>Whether the call succeeded. If false, |R|, |G|, |B| and |A| are</para>
        /// <para>unchanged.</para>
        /// </summary>
        public static int FPDFTextGetFillColor(global::PDFiumCore.FpdfTextpageT text_page, int index, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var __ret = __Internal.FPDFTextGetFillColor(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetStrokeColor</para>
        /// <para>Get the stroke color of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page      -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index          -   Zero-based index of the character.</para>
        /// <para>R              -   Pointer to an unsigned int number receiving the red value of the stroke color.</para>
        /// <para>G              -   Pointer to an unsigned int number receiving the green value of the stroke color.</para>
        /// <para>B              -   Pointer to an unsigned int number receiving the blue value of the stroke color.</para>
        /// <para>A              -   Pointer to an unsigned int number receiving the alpha value of the stroke color.</para>
        /// <para>Return value:</para>
        /// <para>Whether the call succeeded. If false, |R|, |G|, |B| and |A| are</para>
        /// <para>unchanged.</para>
        /// </summary>
        public static int FPDFTextGetStrokeColor(global::PDFiumCore.FpdfTextpageT text_page, int index, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var __ret = __Internal.FPDFTextGetStrokeColor(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharAngle</para>
        /// <para>Get character rotation angle.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return the angle value in radian. Value will always be</para>
        /// <para>greater or equal to 0. If |text_page| is invalid, or if |index| is</para>
        /// <para>out of bounds, then return -1.</para>
        /// </summary>
        public static float FPDFTextGetCharAngle(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetCharAngle(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharBox</para>
        /// <para>Get bounding box of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>left        -   Pointer to a double number receiving left position of the character box.</para>
        /// <para>right       -   Pointer to a double number receiving right position of the character box.</para>
        /// <para>bottom      -   Pointer to a double number receiving bottom position of the character box.</para>
        /// <para>top         -   Pointer to a double number receiving top position of the character box.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |left|, |right|, |bottom|, and</para>
        /// <para>|top|. If |text_page| is invalid, or if |index| is out of bounds,</para>
        /// <para>then return FALSE, and the out parameters remain unmodified.</para>
        /// <para>Comments: All positions are measured in PDF &quot;user space&quot;.</para>
        /// </summary>
        public static int FPDFTextGetCharBox(global::PDFiumCore.FpdfTextpageT text_page, int index, ref double left, ref double right, ref double bottom, ref double top)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (double* __left2 = &left)
            {
                var __arg2 = __left2;
                fixed (double* __right3 = &right)
                {
                    var __arg3 = __right3;
                    fixed (double* __bottom4 = &bottom)
                    {
                        var __arg4 = __bottom4;
                        fixed (double* __top5 = &top)
                        {
                            var __arg5 = __top5;
                            var __ret = __Internal.FPDFTextGetCharBox(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetLooseCharBox</para>
        /// <para>Get a &quot;loose&quot; bounding box of a particular character, i.e., covering</para>
        /// <para>the entire glyph bounds, without taking the actual glyph shape into</para>
        /// <para>account.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>rect        -   Pointer to a FS_RECTF receiving the character box.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |rect|. If |text_page| is</para>
        /// <para>invalid, or if |index| is out of bounds, then return FALSE, and the</para>
        /// <para>|rect| out parameter remains unmodified.</para>
        /// <para>Comments: All positions are measured in PDF &quot;user space&quot;.</para>
        /// </summary>
        public static int FPDFTextGetLooseCharBox(global::PDFiumCore.FpdfTextpageT text_page, int index, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __arg2 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFTextGetLooseCharBox(__arg0, index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetMatrix</para>
        /// <para>Get the effective transformation matrix for a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage().</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>matrix      -   Pointer to a FS_MATRIX receiving the transformation matrix.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |matrix|. If |text_page| is</para>
        /// <para>invalid, or if |index| is out of bounds, or if |matrix| is NULL,</para>
        /// <para>then return FALSE, and |matrix| remains unmodified.</para>
        /// </summary>
        public static int FPDFTextGetMatrix(global::PDFiumCore.FpdfTextpageT text_page, int index, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __arg2 = matrix is null ? __IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFTextGetMatrix(__arg0, index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharOrigin</para>
        /// <para>Get origin of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>x           -   Pointer to a double number receiving x coordinate of the character origin.</para>
        /// <para>y           -   Pointer to a double number receiving y coordinate of the character origin.</para>
        /// <para>Return Value:</para>
        /// <para>Whether the call succeeded. If false, x and y are unchanged.</para>
        /// <para>Comments: All positions are measured in PDF &quot;user space&quot;.</para>
        /// </summary>
        public static int FPDFTextGetCharOrigin(global::PDFiumCore.FpdfTextpageT text_page, int index, ref double x, ref double y)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (double* __x2 = &x)
            {
                var __arg2 = __x2;
                fixed (double* __y3 = &y)
                {
                    var __arg3 = __y3;
                    var __ret = __Internal.FPDFTextGetCharOrigin(__arg0, index, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharIndexAtPos</para>
        /// <para>Get the index of a character at or nearby a certain position on the</para>
        /// <para>page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>x           -   X position in PDF &quot;user space&quot;.</para>
        /// <para>y           -   Y position in PDF &quot;user space&quot;.</para>
        /// <para>xTolerance  -   An x-axis tolerance value for character hit detection, in point units.</para>
        /// <para>yTolerance  -   A y-axis tolerance value for character hit detection, in point units.</para>
        /// <para>Return Value:</para>
        /// <para>The zero-based index of the character at, or nearby the point (x,y).</para>
        /// <para>If there is no character at or nearby the point, return value will</para>
        /// <para>be -1. If an error occurs, -3 will be returned.</para>
        /// </summary>
        public static int FPDFTextGetCharIndexAtPos(global::PDFiumCore.FpdfTextpageT text_page, double x, double y, double xTolerance, double yTolerance)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetCharIndexAtPos(__arg0, x, y, xTolerance, yTolerance);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetText</para>
        /// <para>Extract unicode text string from the page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>start_index -   Index for the start characters.</para>
        /// <para>count       -   Number of characters to be extracted.</para>
        /// <para>result      -   A buffer (allocated by application) receiving the extracted unicodes. The size of the buffer must be able to hold the number of characters plus a terminator.</para>
        /// <para>Return Value:</para>
        /// <para>Number of characters written into the result buffer, including the</para>
        /// <para>trailing terminator.</para>
        /// <para>Comments: This function ignores characters without unicode information. It returns all characters on the page, even those that are not visible when the page has a cropbox. To filter out the characters outside of the cropbox, use FPDF_GetPageBoundingBox() and FPDFText_GetCharBox().</para>
        /// </summary>
        public static int FPDFTextGetText(global::PDFiumCore.FpdfTextpageT text_page, int start_index, int count, ref ushort result)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __result3 = &result)
            {
                var __arg3 = __result3;
                var __ret = __Internal.FPDFTextGetText(__arg0, start_index, count, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_CountRects</para>
        /// <para>Counts number of rectangular areas occupied by a segment of text,</para>
        /// <para>and caches the result for subsequent FPDFText_GetRect() calls.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>start_index -   Index for the start character.</para>
        /// <para>count       -   Number of characters, or -1 for all remaining.</para>
        /// <para>Return value:</para>
        /// <para>Number of rectangles, 0 if text_page is null, or -1 on bad</para>
        /// <para>start_index.</para>
        /// <para>Comments: This function, along with FPDFText_GetRect can be used by applications to detect the position on the page for a text segment, so proper areas can be highlighted. The FPDFText_* functions will automatically merge small character boxes into bigger one if those characters are on the same line and use same font settings.</para>
        /// </summary>
        public static int FPDFTextCountRects(global::PDFiumCore.FpdfTextpageT text_page, int start_index, int count)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextCountRects(__arg0, start_index, count);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetRect</para>
        /// <para>Get a rectangular area from the result generated by</para>
        /// <para>FPDFText_CountRects.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>rect_index  -   Zero-based index for the rectangle.</para>
        /// <para>left        -   Pointer to a double value receiving the rectangle left boundary.</para>
        /// <para>top         -   Pointer to a double value receiving the rectangle top boundary.</para>
        /// <para>right       -   Pointer to a double value receiving the rectangle right boundary.</para>
        /// <para>bottom      -   Pointer to a double value receiving the rectangle bottom boundary.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |left|, |top|, |right|, and</para>
        /// <para>|bottom|. If |text_page| is invalid then return FALSE, and the out</para>
        /// <para>parameters remain unmodified. If |text_page| is valid but</para>
        /// <para>|rect_index| is out of bounds, then return FALSE and set the out</para>
        /// <para>parameters to 0.</para>
        /// </summary>
        public static int FPDFTextGetRect(global::PDFiumCore.FpdfTextpageT text_page, int rect_index, ref double left, ref double top, ref double right, ref double bottom)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (double* __left2 = &left)
            {
                var __arg2 = __left2;
                fixed (double* __top3 = &top)
                {
                    var __arg3 = __top3;
                    fixed (double* __right4 = &right)
                    {
                        var __arg4 = __right4;
                        fixed (double* __bottom5 = &bottom)
                        {
                            var __arg5 = __bottom5;
                            var __ret = __Internal.FPDFTextGetRect(__arg0, rect_index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetBoundedText</para>
        /// <para>Extract unicode text within a rectangular boundary on the page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>left        -   Left boundary.</para>
        /// <para>top         -   Top boundary.</para>
        /// <para>right       -   Right boundary.</para>
        /// <para>bottom      -   Bottom boundary.</para>
        /// <para>buffer      -   A unicode buffer.</para>
        /// <para>buflen      -   Number of characters (not bytes) for the buffer, excluding an additional terminator.</para>
        /// <para>Return Value:</para>
        /// <para>If buffer is NULL or buflen is zero, return number of characters</para>
        /// <para>(not bytes) of text present within the rectangle, excluding a</para>
        /// <para>terminating NUL. Generally you should pass a buffer at least one</para>
        /// <para>larger than this if you want a terminating NUL, which will be</para>
        /// <para>provided if space is available. Otherwise, return number of</para>
        /// <para>characters copied into the buffer, including the terminating NUL</para>
        /// <para>when space for it is available.</para>
        /// <para>Comment:</para>
        /// <para>If the buffer is too small, as much text as will fit is copied into</para>
        /// <para>it.</para>
        /// </summary>
        public static int FPDFTextGetBoundedText(global::PDFiumCore.FpdfTextpageT text_page, double left, double top, double right, double bottom, ref ushort buffer, int buflen)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __buffer5 = &buffer)
            {
                var __arg5 = __buffer5;
                var __ret = __Internal.FPDFTextGetBoundedText(__arg0, left, top, right, bottom, __arg5, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_FindStart</para>
        /// <para>Start a search.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>findwhat    -   A unicode match pattern.</para>
        /// <para>flags       -   Option flags.</para>
        /// <para>start_index -   Start from this character. -1 for end of the page.</para>
        /// <para>Return Value:</para>
        /// <para>A handle for the search context. FPDFText_FindClose must be called</para>
        /// <para>to release this handle.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfSchhandleT FPDFTextFindStart(global::PDFiumCore.FpdfTextpageT text_page, ref ushort findwhat, uint flags, int start_index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __findwhat1 = &findwhat)
            {
                var __arg1 = __findwhat1;
                var __ret = __Internal.FPDFTextFindStart(__arg0, __arg1, flags, start_index);
                var __result0 = global::PDFiumCore.FpdfSchhandleT.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_FindNext</para>
        /// <para>Search in the direction from page start to end.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Whether a match is found.</para>
        /// </summary>
        public static int FPDFTextFindNext(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextFindNext(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_FindPrev</para>
        /// <para>Search in the direction from page end to start.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Whether a match is found.</para>
        /// </summary>
        public static int FPDFTextFindPrev(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextFindPrev(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetSchResultIndex</para>
        /// <para>Get the starting character index of the search result.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Index for the starting character.</para>
        /// </summary>
        public static int FPDFTextGetSchResultIndex(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextGetSchResultIndex(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetSchCount</para>
        /// <para>Get the number of matched characters in the search result.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Number of matched characters.</para>
        /// </summary>
        public static int FPDFTextGetSchCount(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextGetSchCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_FindClose</para>
        /// <para>Release a search context.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDFTextFindClose(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            __Internal.FPDFTextFindClose(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDFLink_LoadWebLinks</para>
        /// <para>Prepare information about weblinks in a page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>Return Value:</para>
        /// <para>A handle to the page's links information structure, or</para>
        /// <para>NULL if something goes wrong.</para>
        /// <para>Comments: Weblinks are those links implicitly embedded in PDF pages. PDF also has a type of annotation called &quot;link&quot; (FPDFTEXT doesn't deal with that kind of link). FPDFTEXT weblink feature is useful for automatically detecting links in the page contents. For example, things like &quot;https://www.example.com&quot; will be detected, so applications can allow user to click on those characters to activate the link, even the PDF doesn't come with link annotations.</para>
        /// <para>FPDFLink_CloseWebLinks must be called to release resources.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPagelinkT FPDFLinkLoadWebLinks(global::PDFiumCore.FpdfTextpageT text_page)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFLinkLoadWebLinks(__arg0);
            var __result0 = global::PDFiumCore.FpdfPagelinkT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFLink_CountWebLinks</para>
        /// <para>Count number of detected web links.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>Return Value:</para>
        /// <para>Number of detected web links.</para>
        /// </summary>
        public static int FPDFLinkCountWebLinks(global::PDFiumCore.FpdfPagelinkT link_page)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            var __ret = __Internal.FPDFLinkCountWebLinks(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFLink_GetURL</para>
        /// <para>Fetch the URL information for a detected web link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index  -   Zero-based index for the link.</para>
        /// <para>buffer      -   A unicode buffer for the result.</para>
        /// <para>buflen      -   Number of 16-bit code units (not bytes) for the buffer, including an additional terminator.</para>
        /// <para>Return Value:</para>
        /// <para>If |buffer| is NULL or |buflen| is zero, return the number of 16-bit</para>
        /// <para>code units (not bytes) needed to buffer the result (an additional</para>
        /// <para>terminator is included in this count).</para>
        /// <para>Otherwise, copy the result into |buffer|, truncating at |buflen| if</para>
        /// <para>the result is too large to fit, and return the number of 16-bit code</para>
        /// <para>units actually copied into the buffer (the additional terminator is</para>
        /// <para>also included in this count).</para>
        /// <para>If |link_index| does not correspond to a valid link, then the result</para>
        /// <para>is an empty string.</para>
        /// </summary>
        public static int FPDFLinkGetURL(global::PDFiumCore.FpdfPagelinkT link_page, int link_index, ref ushort buffer, int buflen)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFLinkGetURL(__arg0, link_index, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFLink_CountRects</para>
        /// <para>Count number of rectangular areas for the link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index  -   Zero-based index for the link.</para>
        /// <para>Return Value:</para>
        /// <para>Number of rectangular areas for the link.  If |link_index| does</para>
        /// <para>not correspond to a valid link, then 0 is returned.</para>
        /// </summary>
        public static int FPDFLinkCountRects(global::PDFiumCore.FpdfPagelinkT link_page, int link_index)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            var __ret = __Internal.FPDFLinkCountRects(__arg0, link_index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFLink_GetRect</para>
        /// <para>Fetch the boundaries of a rectangle for a link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index  -   Zero-based index for the link.</para>
        /// <para>rect_index  -   Zero-based index for a rectangle.</para>
        /// <para>left        -   Pointer to a double value receiving the rectangle left boundary.</para>
        /// <para>top         -   Pointer to a double value receiving the rectangle top boundary.</para>
        /// <para>right       -   Pointer to a double value receiving the rectangle right boundary.</para>
        /// <para>bottom      -   Pointer to a double value receiving the rectangle bottom boundary.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |left|, |top|, |right|, and</para>
        /// <para>|bottom|. If |link_page| is invalid or if |link_index| does not</para>
        /// <para>correspond to a valid link, then return FALSE, and the out</para>
        /// <para>parameters remain unmodified.</para>
        /// </summary>
        public static int FPDFLinkGetRect(global::PDFiumCore.FpdfPagelinkT link_page, int link_index, int rect_index, ref double left, ref double top, ref double right, ref double bottom)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            fixed (double* __left3 = &left)
            {
                var __arg3 = __left3;
                fixed (double* __top4 = &top)
                {
                    var __arg4 = __top4;
                    fixed (double* __right5 = &right)
                    {
                        var __arg5 = __right5;
                        fixed (double* __bottom6 = &bottom)
                        {
                            var __arg6 = __bottom6;
                            var __ret = __Internal.FPDFLinkGetRect(__arg0, link_index, rect_index, __arg3, __arg4, __arg5, __arg6);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFLink_GetTextRange</para>
        /// <para>Fetch the start char index and char count for a link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page         -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index        -   Zero-based index for the link.</para>
        /// <para>start_char_index  -   pointer to int receiving the start char index</para>
        /// <para>char_count        -   pointer to int receiving the char count</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |start_char_index| and</para>
        /// <para>|char_count|. if |link_page| is invalid or if |link_index| does</para>
        /// <para>not correspond to a valid link, then return FALSE and the out</para>
        /// <para>parameters remain unmodified.</para>
        /// </summary>
        public static int FPDFLinkGetTextRange(global::PDFiumCore.FpdfPagelinkT link_page, int link_index, ref int start_char_index, ref int char_count)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            fixed (int* __start_char_index2 = &start_char_index)
            {
                var __arg2 = __start_char_index2;
                fixed (int* __char_count3 = &char_count)
                {
                    var __arg3 = __char_count3;
                    var __ret = __Internal.FPDFLinkGetTextRange(__arg0, link_index, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFLink_CloseWebLinks</para>
        /// <para>Release resources used by weblink feature.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDFLinkCloseWebLinks(global::PDFiumCore.FpdfPagelinkT link_page)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            __Internal.FPDFLinkCloseWebLinks(__arg0);
        }
    }

    public unsafe partial class fpdf_thumbnail
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetDecodedThumbnailData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFPageGetDecodedThumbnailData(__IntPtr page, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetRawThumbnailData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFPageGetRawThumbnailData(__IntPtr page, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetThumbnailAsBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageGetThumbnailAsBitmap(__IntPtr page);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the decoded data from the thumbnail of |page| if it exists.</para>
        /// <para>This only modifies |buffer| if |buflen| less than or equal to the</para>
        /// <para>size of the decoded data. Returns the size of the decoded</para>
        /// <para>data or 0 if thumbnail DNE. Optional, pass null to just retrieve</para>
        /// <para>the size of the buffer needed.</para>
        /// <para>page    - handle to a page.</para>
        /// <para>buffer  - buffer for holding the decoded image data.</para>
        /// <para>buflen  - length of the buffer in bytes.</para>
        /// </summary>
        public static uint FPDFPageGetDecodedThumbnailData(global::PDFiumCore.FpdfPageT page, __IntPtr buffer, uint buflen)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetDecodedThumbnailData(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the raw data from the thumbnail of |page| if it exists.</para>
        /// <para>This only modifies |buffer| if |buflen| is less than or equal to</para>
        /// <para>the size of the raw data. Returns the size of the raw data or 0</para>
        /// <para>if thumbnail DNE. Optional, pass null to just retrieve the size</para>
        /// <para>of the buffer needed.</para>
        /// <para>page    - handle to a page.</para>
        /// <para>buffer  - buffer for holding the raw image data.</para>
        /// <para>buflen  - length of the buffer in bytes.</para>
        /// </summary>
        public static uint FPDFPageGetRawThumbnailData(global::PDFiumCore.FpdfPageT page, __IntPtr buffer, uint buflen)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetRawThumbnailData(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Returns the thumbnail of |page| as a FPDF_BITMAP. Returns a nullptr</para>
        /// <para>if unable to access the thumbnail's stream.</para>
        /// <para>page - handle to a page.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFPageGetThumbnailAsBitmap(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetThumbnailAsBitmap(__arg0);
            var __result0 = global::PDFiumCore.FpdfBitmapT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }
    }

    public unsafe partial class fpdf_transformpage
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_SetMediaBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageSetMediaBox(__IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_SetCropBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageSetCropBox(__IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_SetBleedBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageSetBleedBox(__IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_SetTrimBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageSetTrimBox(__IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_SetArtBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageSetArtBox(__IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetMediaBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetMediaBox(__IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetCropBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetCropBox(__IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetBleedBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetBleedBox(__IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetTrimBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetTrimBox(__IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_GetArtBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageGetArtBox(__IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_TransFormWithClip", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFPageTransFormWithClip(__IntPtr page, __IntPtr matrix, __IntPtr clipRect);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_TransformClipPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageObjTransformClipPath(__IntPtr page_object, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPageObj_GetClipPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFPageObjGetClipPath(__IntPtr page_object);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFClipPath_CountPaths", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFClipPathCountPaths(__IntPtr clip_path);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFClipPath_CountPathSegments", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFClipPathCountPathSegments(__IntPtr clip_path, int path_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFClipPath_GetPathSegment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFClipPathGetPathSegment(__IntPtr clip_path, int path_index, int segment_index);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_CreateClipPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_CreateClipPath(float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDF_DestroyClipPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_DestroyClipPath(__IntPtr clipPath);

            [SuppressUnmanagedCodeSecurity, DllImport("pdfium", EntryPoint = "FPDFPage_InsertClipPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFPageInsertClipPath(__IntPtr page, __IntPtr clipPath);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;MediaBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetMediaBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetMediaBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;CropBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetCropBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetCropBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;BleedBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetBleedBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetBleedBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;TrimBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetTrimBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetTrimBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;ArtBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetArtBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetArtBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;MediaBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetMediaBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetMediaBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;CropBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetCropBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetCropBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;BleedBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetBleedBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetBleedBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;TrimBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetTrimBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetTrimBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;ArtBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetArtBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetArtBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Apply transforms to |page|.</para>
        /// <para>If |matrix| is provided it will be applied to transform the page.</para>
        /// <para>If |clipRect| is provided it will be used to clip the resulting page.</para>
        /// <para>If neither |matrix| or |clipRect| are provided this method returns |false|.</para>
        /// <para>Returns |true| if transforms are applied.</para>
        /// <para>This function will transform the whole page, and would take effect to all the</para>
        /// <para>objects in the page.</para>
        /// <para>page        - Page handle.</para>
        /// <para>matrix      - Transform matrix.</para>
        /// <para>clipRect    - Clipping rectangle.</para>
        /// </summary>
        public static int FPDFPageTransFormWithClip(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_MATRIX_ matrix, global::PDFiumCore.FS_RECTF_ clipRect)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = matrix is null ? __IntPtr.Zero : matrix.__Instance;
            var __arg2 = clipRect is null ? __IntPtr.Zero : clipRect.__Instance;
            var __ret = __Internal.FPDFPageTransFormWithClip(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Transform (scale, rotate, shear, move) the clip path of page object.</para>
        /// <para>page_object - Handle to a page object. Returned by</para>
        /// <para>FPDFPageObj_NewImageObj().</para>
        /// <para>a  - The coefficient &quot;a&quot; of the matrix.</para>
        /// <para>b  - The coefficient &quot;b&quot; of the matrix.</para>
        /// <para>c  - The coefficient &quot;c&quot; of the matrix.</para>
        /// <para>d  - The coefficient &quot;d&quot; of the matrix.</para>
        /// <para>e  - The coefficient &quot;e&quot; of the matrix.</para>
        /// <para>f  - The coefficient &quot;f&quot; of the matrix.</para>
        /// </summary>
        public static void FPDFPageObjTransformClipPath(global::PDFiumCore.FpdfPageobjectT page_object, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            __Internal.FPDFPageObjTransformClipPath(__arg0, a, b, c, d, e, f);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the clip path of the page object.</para>
        /// <para>page object - Handle to a page object. Returned by e.g.</para>
        /// <para>FPDFPage_GetObject().</para>
        /// <para>Returns the handle to the clip path, or NULL on failure. The caller does not</para>
        /// <para>take ownership of the returned FPDF_CLIPPATH. Instead, it remains valid until</para>
        /// <para>FPDF_ClosePage() is called for the page containing |page_object|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfClippathT FPDFPageObjGetClipPath(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = page_object is null ? __IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetClipPath(__arg0);
            var __result0 = global::PDFiumCore.FpdfClippathT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of paths inside |clip_path|.</para>
        /// <para>clip_path - handle to a clip_path.</para>
        /// <para>Returns the number of objects in |clip_path| or -1 on failure.</para>
        /// </summary>
        public static int FPDFClipPathCountPaths(global::PDFiumCore.FpdfClippathT clip_path)
        {
            var __arg0 = clip_path is null ? __IntPtr.Zero : clip_path.__Instance;
            var __ret = __Internal.FPDFClipPathCountPaths(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of segments inside one path of |clip_path|.</para>
        /// <para>clip_path  - handle to a clip_path.</para>
        /// <para>path_index - index into the array of paths of the clip path.</para>
        /// <para>Returns the number of segments or -1 on failure.</para>
        /// </summary>
        public static int FPDFClipPathCountPathSegments(global::PDFiumCore.FpdfClippathT clip_path, int path_index)
        {
            var __arg0 = clip_path is null ? __IntPtr.Zero : clip_path.__Instance;
            var __ret = __Internal.FPDFClipPathCountPathSegments(__arg0, path_index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get segment in one specific path of |clip_path| at index.</para>
        /// <para>clip_path     - handle to a clip_path.</para>
        /// <para>path_index    - the index of a path.</para>
        /// <para>segment_index - the index of a segment.</para>
        /// <para>Returns the handle to the segment, or NULL on failure. The caller does not</para>
        /// <para>take ownership of the returned FPDF_PATHSEGMENT. Instead, it remains valid</para>
        /// <para>until FPDF_ClosePage() is called for the page containing |clip_path|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPathsegmentT FPDFClipPathGetPathSegment(global::PDFiumCore.FpdfClippathT clip_path, int path_index, int segment_index)
        {
            var __arg0 = clip_path is null ? __IntPtr.Zero : clip_path.__Instance;
            var __ret = __Internal.FPDFClipPathGetPathSegment(__arg0, path_index, segment_index);
            var __result0 = global::PDFiumCore.FpdfPathsegmentT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Create a new clip path, with a rectangle inserted.</para>
        /// <para>Caller takes ownership of the returned FPDF_CLIPPATH. It should be freed with</para>
        /// <para>FPDF_DestroyClipPath().</para>
        /// <para>left   - The left of the clip box.</para>
        /// <para>bottom - The bottom of the clip box.</para>
        /// <para>right  - The right of the clip box.</para>
        /// <para>top    - The top of the clip box.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfClippathT FPDF_CreateClipPath(float left, float bottom, float right, float top)
        {
            var __ret = __Internal.FPDF_CreateClipPath(left, bottom, right, top);
            var __result0 = global::PDFiumCore.FpdfClippathT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Destroy the clip path.</para>
        /// <para>clipPath - A handle to the clip path. It will be invalid after this call.</para>
        /// </summary>
        public static void FPDF_DestroyClipPath(global::PDFiumCore.FpdfClippathT clipPath)
        {
            var __arg0 = clipPath is null ? __IntPtr.Zero : clipPath.__Instance;
            __Internal.FPDF_DestroyClipPath(__arg0);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Clip the page content, the page content that outside the clipping region</para>
        /// <para>become invisible.</para>
        /// <para>A clip path will be inserted before the page content stream or content array.</para>
        /// <para>In this way, the page content will be clipped by this clip path.</para>
        /// <para>page        - A page handle.</para>
        /// <para>clipPath    - A handle to the clip path. (Does not take ownership.)</para>
        /// </summary>
        public static void FPDFPageInsertClipPath(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfClippathT clipPath)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = clipPath is null ? __IntPtr.Zero : clipPath.__Instance;
            __Internal.FPDFPageInsertClipPath(__arg0, __arg1);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_uint_bytePtr_uint(__IntPtr param, uint position, byte* pBuf, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr clientData);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint___IntPtr(__IntPtr clientData);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_uint___IntPtr_uint(__IntPtr clientData, uint offset, __IntPtr buffer, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr(__IntPtr clientData);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_uint(__IntPtr clientData, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_ushortPtr_ushortPtr_int_int(__IntPtr pThis, ushort* Msg, ushort* Title, int Type, int Icon);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int(__IntPtr pThis, int nType);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int___IntPtr_int(__IntPtr pThis, ushort* Question, ushort* Title, ushort* Default, ushort* cLabel, int bPassword, __IntPtr response, int length);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr_int(__IntPtr pThis, __IntPtr filePath, int length);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr(__IntPtr pThis, __IntPtr mailData, int length, int bUI, ushort* To, ushort* Subject, ushort* CC, ushort* BCC, ushort* Msg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int_int_int_int_int_int_int_int(__IntPtr pThis, int bUI, int nStart, int nEnd, int bSilent, int bShrinkToFit, int bPrintAsImage, int bReverse, int bAnnotations);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_int_ushortPtr(__IntPtr pThis, __IntPtr formData, int length, ushort* URL);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_double_double_double_double(__IntPtr pThis, __IntPtr page, double left, double top, double right, double bottom);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_int_PDFiumCore_TimerCallback(__IntPtr pThis, int uElapse, global::PDFiumCore.TimerCallback lpTimerFunc);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::PDFiumCore.FPDF_SYSTEMTIME.__Internal Func_PDFiumCore__FPDF_SYSTEMTIME___Internal___IntPtr(__IntPtr pThis);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_int(__IntPtr pThis, __IntPtr document, int nPageIndex);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr(__IntPtr pThis, __IntPtr document);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr(__IntPtr pThis, __IntPtr page);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_string8(__IntPtr pThis, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string namedAction);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_ushortPtr_uint_int(__IntPtr pThis, ushort* value, uint valueLen, int is_focus);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int_int_floatPtr_int(__IntPtr pThis, int nPageIndex, int zoomMode, float* fPosArray, int sizeofArray);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_int_double_double_double_double(__IntPtr pThis, __IntPtr page, int bVisible, double left, double top, double right, double bottom);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_int(__IntPtr pThis, __IntPtr document, int iCurPage);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_ushortPtr(__IntPtr pThis, __IntPtr document, ushort* wsURL);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_doublePtr_doublePtr_doublePtr_doublePtr(__IntPtr pThis, __IntPtr page, double* left, double* top, double* right, double* bottom);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int_uint(__IntPtr pThis, int page_count, uint event_type);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr___IntPtr_int_float_float(__IntPtr pThis, __IntPtr page, __IntPtr hWidget, int menuFlag, float x, float y);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr_int_ushortPtr_string8(__IntPtr pThis, int fileFlag, ushort* wsURL, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mode);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr(__IntPtr pThis, __IntPtr fileHandler, ushort* pTo, ushort* pSubject, ushort* pCC, ushort* pBcc, ushort* pMsg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr_ushortPtr(__IntPtr pThis, ushort* URL);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr___IntPtr(__IntPtr pThis, ushort* wsURL, ushort* wsData, ushort* wsContentType, ushort* wsEncode, ushort* wsHeader, __IntPtr response);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_ushortPtr_ushortPtr_ushortPtr(__IntPtr pThis, ushort* wsURL, ushort* wsData, ushort* wsEncode);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_string8_int(__IntPtr param, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string uri, int modifiers);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_ulong_ulong(__IntPtr pThis, ulong offset, ulong size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_ulong_ulong(__IntPtr pThis, ulong offset, ulong size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr_uint(__IntPtr pThis, __IntPtr pData, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr pThis, __IntPtr pMapper);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr_int_int_int_int_string8_intPtr(__IntPtr pThis, int weight, int bItalic, int charset, int pitch_family, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string face, int* bExact);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8(__IntPtr pThis, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string face);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint___IntPtr___IntPtr_uint_bytePtr_uint(__IntPtr pThis, __IntPtr hFont, uint table, byte* buffer, uint buf_size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint___IntPtr___IntPtr_sbytePtr_uint(__IntPtr pThis, __IntPtr hFont, sbyte* buffer, uint buf_size);
    }
}
